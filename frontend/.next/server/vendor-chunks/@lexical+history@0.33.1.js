"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+history@0.33.1";
exports.ids = ["vendor-chunks/@lexical+history@0.33.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@lexical+history@0.33.1/node_modules/@lexical/history/LexicalHistory.dev.mjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+history@0.33.1/node_modules/@lexical/history/LexicalHistory.dev.mjs ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEmptyHistoryState: () => (/* binding */ createEmptyHistoryState),\n/* harmony export */   registerHistory: () => (/* binding */ registerHistory)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/.pnpm/@lexical+utils@0.33.1/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/.pnpm/lexical@0.33.1/node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n    if (dirtyElement !== undefined && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n  return nodes;\n}\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(nextSelection) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  }\n\n  // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n    return OTHER;\n  }\n  const nextDirtyNode = dirtyNodes[0];\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevDirtyNode) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n  if (prevText === nextText) {\n    return OTHER;\n  }\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n  return OTHER;\n}\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n  const nextNode = nextEditorState._nodeMap.get(key);\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  const isDeletingLine = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(nextSelection) && prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  if (!isDeletingLine && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevNode) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextNode) && prevNode.__parent === nextNode.__parent) {\n    // This has the assumption that object key order won't change if the\n    // content did not change, which should normally be safe given\n    // the manner in which nodes and exportJSON are typically implemented.\n    return JSON.stringify(prevEditorState.read(() => prevNode.exportJSON())) === JSON.stringify(nextEditorState.read(() => nextNode.exportJSON()));\n  }\n  return false;\n}\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now();\n\n    // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n    if (tags.has(lexical__WEBPACK_IMPORTED_MODULE_0__.HISTORIC_TAG)) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has(lexical__WEBPACK_IMPORTED_MODULE_0__.HISTORY_PUSH_TAG);\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has(lexical__WEBPACK_IMPORTED_MODULE_0__.HISTORY_MERGE_TAG);\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      }\n\n      // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n      return HISTORY_PUSH;\n    })();\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, true);\n    }\n    const historyStateEntry = redoStack.pop();\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: lexical__WEBPACK_IMPORTED_MODULE_0__.HISTORIC_TAG\n      });\n    }\n  }\n}\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, true);\n    }\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: lexical__WEBPACK_IMPORTED_MODULE_0__.HISTORIC_TAG\n      });\n    }\n  }\n}\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n\n/**\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\n * @param editor - The lexical editor.\n * @param historyState - The history state, containing the current state and the undo/redo stack.\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\n * instead of merging the current changes with the current stack.\n * @returns The listeners cleanup callback function.\n */\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n      }\n      if (current !== null) {\n        undoStack.push({\n          ...current\n        });\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    }\n\n    // Else we merge\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n  const unregister = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, false);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  return unregister;\n}\n\n/**\n * Creates an empty history state.\n * @returns - The empty history state, as an object.\n */\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwraGlzdG9yeUAwLjMzLjEvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2hpc3RvcnkvTGV4aWNhbEhpc3RvcnkuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStDO0FBQ2dOOztBQUUvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvREFBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywwREFBaUIsb0JBQW9CLDBEQUFpQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLG9EQUFXO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sb0RBQVcsb0JBQW9CLG9EQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBEQUFpQixtQkFBbUIsMERBQWlCO0FBQzlFLHlCQUF5QixvREFBVyxjQUFjLG9EQUFXO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGlEQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFEQUFnQjtBQUN6RCxnRkFBZ0Ysc0RBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxREFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFEQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaURBQVk7QUFDekIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxREFBZ0I7QUFDN0M7QUFDQTtBQUNBLDZCQUE2QixxREFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlEQUFZO0FBQ3pCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxREFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsK0JBQStCLHFEQUFnQjtBQUMvQztBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2REFBYSx3QkFBd0IsaURBQVk7QUFDdEU7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLGlEQUFZO0FBQ2xFO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQix5REFBb0I7QUFDMUU7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLDBEQUFxQjtBQUMzRTtBQUNBLDJCQUEyQixxREFBZ0I7QUFDM0MsMkJBQTJCLHFEQUFnQjtBQUMzQztBQUNBLEdBQUcsRUFBRSw0REFBdUI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvRCIsInNvdXJjZXMiOlsiL1VzZXJzL2Fua2l0aHJlZGR5L0Rlc2t0b3AvaGFja2F0aG9ucy9rYWdnbGVnZW1tYS9sZXJlcGFpcmJvdGluZmVyZW5jZS9mcm9udGVuZC9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwraGlzdG9yeUAwLjMzLjEvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2hpc3RvcnkvTGV4aWNhbEhpc3RvcnkuZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IG1lcmdlUmVnaXN0ZXIgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyBVTkRPX0NPTU1BTkQsIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SLCBSRURPX0NPTU1BTkQsIENMRUFSX0VESVRPUl9DT01NQU5ELCBDTEVBUl9ISVNUT1JZX0NPTU1BTkQsIENBTl9SRURPX0NPTU1BTkQsIENBTl9VTkRPX0NPTU1BTkQsIEhJU1RPUklDX1RBRywgSElTVE9SWV9QVVNIX1RBRywgSElTVE9SWV9NRVJHRV9UQUcsICRpc1JhbmdlU2VsZWN0aW9uLCAkaXNUZXh0Tm9kZSwgJGlzUm9vdE5vZGUgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBISVNUT1JZX01FUkdFID0gMDtcbmNvbnN0IEhJU1RPUllfUFVTSCA9IDE7XG5jb25zdCBESVNDQVJEX0hJU1RPUllfQ0FORElEQVRFID0gMjtcbmNvbnN0IE9USEVSID0gMDtcbmNvbnN0IENPTVBPU0lOR19DSEFSQUNURVIgPSAxO1xuY29uc3QgSU5TRVJUX0NIQVJBQ1RFUl9BRlRFUl9TRUxFQ1RJT04gPSAyO1xuY29uc3QgREVMRVRFX0NIQVJBQ1RFUl9CRUZPUkVfU0VMRUNUSU9OID0gMztcbmNvbnN0IERFTEVURV9DSEFSQUNURVJfQUZURVJfU0VMRUNUSU9OID0gNDtcbmZ1bmN0aW9uIGdldERpcnR5Tm9kZXMoZWRpdG9yU3RhdGUsIGRpcnR5TGVhdmVzLCBkaXJ0eUVsZW1lbnRzKSB7XG4gIGNvbnN0IG5vZGVNYXAgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgZm9yIChjb25zdCBkaXJ0eUxlYWZLZXkgb2YgZGlydHlMZWF2ZXMpIHtcbiAgICBjb25zdCBkaXJ0eUxlYWYgPSBub2RlTWFwLmdldChkaXJ0eUxlYWZLZXkpO1xuICAgIGlmIChkaXJ0eUxlYWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9kZXMucHVzaChkaXJ0eUxlYWYpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IFtkaXJ0eUVsZW1lbnRLZXksIGludGVudGlvbmFsbHlNYXJrZWRBc0RpcnR5XSBvZiBkaXJ0eUVsZW1lbnRzKSB7XG4gICAgaWYgKCFpbnRlbnRpb25hbGx5TWFya2VkQXNEaXJ0eSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGRpcnR5RWxlbWVudCA9IG5vZGVNYXAuZ2V0KGRpcnR5RWxlbWVudEtleSk7XG4gICAgaWYgKGRpcnR5RWxlbWVudCAhPT0gdW5kZWZpbmVkICYmICEkaXNSb290Tm9kZShkaXJ0eUVsZW1lbnQpKSB7XG4gICAgICBub2Rlcy5wdXNoKGRpcnR5RWxlbWVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2Rlcztcbn1cbmZ1bmN0aW9uIGdldENoYW5nZVR5cGUocHJldkVkaXRvclN0YXRlLCBuZXh0RWRpdG9yU3RhdGUsIGRpcnR5TGVhdmVzU2V0LCBkaXJ0eUVsZW1lbnRzU2V0LCBpc0NvbXBvc2luZykge1xuICBpZiAocHJldkVkaXRvclN0YXRlID09PSBudWxsIHx8IGRpcnR5TGVhdmVzU2V0LnNpemUgPT09IDAgJiYgZGlydHlFbGVtZW50c1NldC5zaXplID09PSAwICYmICFpc0NvbXBvc2luZykge1xuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuICBjb25zdCBuZXh0U2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBwcmV2RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgcmV0dXJuIENPTVBPU0lOR19DSEFSQUNURVI7XG4gIH1cbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKSB8fCAhJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgfHwgIXByZXZTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCAhbmV4dFNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG4gIGNvbnN0IGRpcnR5Tm9kZXMgPSBnZXREaXJ0eU5vZGVzKG5leHRFZGl0b3JTdGF0ZSwgZGlydHlMZWF2ZXNTZXQsIGRpcnR5RWxlbWVudHNTZXQpO1xuICBpZiAoZGlydHlOb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cblxuICAvLyBDYXRjaGluZyB0aGUgY2FzZSB3aGVuIGluc2VydGluZyBuZXcgdGV4dCBub2RlIGludG8gYW4gZWxlbWVudCAoZS5nLiBmaXJzdCBjaGFyIGluIHBhcmFncmFwaC9saXN0KSxcbiAgLy8gb3IgYWZ0ZXIgZXhpc3Rpbmcgbm9kZS5cbiAgaWYgKGRpcnR5Tm9kZXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IG5leHROb2RlTWFwID0gbmV4dEVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICAgIGNvbnN0IG5leHRBbmNob3JOb2RlID0gbmV4dE5vZGVNYXAuZ2V0KG5leHRTZWxlY3Rpb24uYW5jaG9yLmtleSk7XG4gICAgY29uc3QgcHJldkFuY2hvck5vZGUgPSBuZXh0Tm9kZU1hcC5nZXQocHJldlNlbGVjdGlvbi5hbmNob3Iua2V5KTtcbiAgICBpZiAobmV4dEFuY2hvck5vZGUgJiYgcHJldkFuY2hvck5vZGUgJiYgIXByZXZFZGl0b3JTdGF0ZS5fbm9kZU1hcC5oYXMobmV4dEFuY2hvck5vZGUuX19rZXkpICYmICRpc1RleHROb2RlKG5leHRBbmNob3JOb2RlKSAmJiBuZXh0QW5jaG9yTm9kZS5fX3RleHQubGVuZ3RoID09PSAxICYmIG5leHRTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gMSkge1xuICAgICAgcmV0dXJuIElOU0VSVF9DSEFSQUNURVJfQUZURVJfU0VMRUNUSU9OO1xuICAgIH1cbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cbiAgY29uc3QgbmV4dERpcnR5Tm9kZSA9IGRpcnR5Tm9kZXNbMF07XG4gIGNvbnN0IHByZXZEaXJ0eU5vZGUgPSBwcmV2RWRpdG9yU3RhdGUuX25vZGVNYXAuZ2V0KG5leHREaXJ0eU5vZGUuX19rZXkpO1xuICBpZiAoISRpc1RleHROb2RlKHByZXZEaXJ0eU5vZGUpIHx8ICEkaXNUZXh0Tm9kZShuZXh0RGlydHlOb2RlKSB8fCBwcmV2RGlydHlOb2RlLl9fbW9kZSAhPT0gbmV4dERpcnR5Tm9kZS5fX21vZGUpIHtcbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cbiAgY29uc3QgcHJldlRleHQgPSBwcmV2RGlydHlOb2RlLl9fdGV4dDtcbiAgY29uc3QgbmV4dFRleHQgPSBuZXh0RGlydHlOb2RlLl9fdGV4dDtcbiAgaWYgKHByZXZUZXh0ID09PSBuZXh0VGV4dCkge1xuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuICBjb25zdCBuZXh0QW5jaG9yID0gbmV4dFNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IHByZXZBbmNob3IgPSBwcmV2U2VsZWN0aW9uLmFuY2hvcjtcbiAgaWYgKG5leHRBbmNob3Iua2V5ICE9PSBwcmV2QW5jaG9yLmtleSB8fCBuZXh0QW5jaG9yLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuICBjb25zdCBuZXh0QW5jaG9yT2Zmc2V0ID0gbmV4dEFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IHByZXZBbmNob3JPZmZzZXQgPSBwcmV2QW5jaG9yLm9mZnNldDtcbiAgY29uc3QgdGV4dERpZmYgPSBuZXh0VGV4dC5sZW5ndGggLSBwcmV2VGV4dC5sZW5ndGg7XG4gIGlmICh0ZXh0RGlmZiA9PT0gMSAmJiBwcmV2QW5jaG9yT2Zmc2V0ID09PSBuZXh0QW5jaG9yT2Zmc2V0IC0gMSkge1xuICAgIHJldHVybiBJTlNFUlRfQ0hBUkFDVEVSX0FGVEVSX1NFTEVDVElPTjtcbiAgfVxuICBpZiAodGV4dERpZmYgPT09IC0xICYmIHByZXZBbmNob3JPZmZzZXQgPT09IG5leHRBbmNob3JPZmZzZXQgKyAxKSB7XG4gICAgcmV0dXJuIERFTEVURV9DSEFSQUNURVJfQkVGT1JFX1NFTEVDVElPTjtcbiAgfVxuICBpZiAodGV4dERpZmYgPT09IC0xICYmIHByZXZBbmNob3JPZmZzZXQgPT09IG5leHRBbmNob3JPZmZzZXQpIHtcbiAgICByZXR1cm4gREVMRVRFX0NIQVJBQ1RFUl9BRlRFUl9TRUxFQ1RJT047XG4gIH1cbiAgcmV0dXJuIE9USEVSO1xufVxuZnVuY3Rpb24gaXNUZXh0Tm9kZVVuY2hhbmdlZChrZXksIHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IHByZXZOb2RlID0gcHJldkVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChrZXkpO1xuICBjb25zdCBuZXh0Tm9kZSA9IG5leHRFZGl0b3JTdGF0ZS5fbm9kZU1hcC5nZXQoa2V5KTtcbiAgY29uc3QgcHJldlNlbGVjdGlvbiA9IHByZXZFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBuZXh0U2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IGlzRGVsZXRpbmdMaW5lID0gJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgJGlzUmFuZ2VTZWxlY3Rpb24obmV4dFNlbGVjdGlvbikgJiYgcHJldlNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIHByZXZTZWxlY3Rpb24uZm9jdXMudHlwZSA9PT0gJ2VsZW1lbnQnICYmIG5leHRTZWxlY3Rpb24uYW5jaG9yLnR5cGUgPT09ICd0ZXh0JyAmJiBuZXh0U2VsZWN0aW9uLmZvY3VzLnR5cGUgPT09ICd0ZXh0JztcbiAgaWYgKCFpc0RlbGV0aW5nTGluZSAmJiAkaXNUZXh0Tm9kZShwcmV2Tm9kZSkgJiYgJGlzVGV4dE5vZGUobmV4dE5vZGUpICYmIHByZXZOb2RlLl9fcGFyZW50ID09PSBuZXh0Tm9kZS5fX3BhcmVudCkge1xuICAgIC8vIFRoaXMgaGFzIHRoZSBhc3N1bXB0aW9uIHRoYXQgb2JqZWN0IGtleSBvcmRlciB3b24ndCBjaGFuZ2UgaWYgdGhlXG4gICAgLy8gY29udGVudCBkaWQgbm90IGNoYW5nZSwgd2hpY2ggc2hvdWxkIG5vcm1hbGx5IGJlIHNhZmUgZ2l2ZW5cbiAgICAvLyB0aGUgbWFubmVyIGluIHdoaWNoIG5vZGVzIGFuZCBleHBvcnRKU09OIGFyZSB0eXBpY2FsbHkgaW1wbGVtZW50ZWQuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByZXZFZGl0b3JTdGF0ZS5yZWFkKCgpID0+IHByZXZOb2RlLmV4cG9ydEpTT04oKSkpID09PSBKU09OLnN0cmluZ2lmeShuZXh0RWRpdG9yU3RhdGUucmVhZCgoKSA9PiBuZXh0Tm9kZS5leHBvcnRKU09OKCkpKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVNZXJnZUFjdGlvbkdldHRlcihlZGl0b3IsIGRlbGF5KSB7XG4gIGxldCBwcmV2Q2hhbmdlVGltZSA9IERhdGUubm93KCk7XG4gIGxldCBwcmV2Q2hhbmdlVHlwZSA9IE9USEVSO1xuICByZXR1cm4gKHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlLCBjdXJyZW50SGlzdG9yeUVudHJ5LCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cywgdGFncykgPT4ge1xuICAgIGNvbnN0IGNoYW5nZVRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gSWYgYXBwbHlpbmcgY2hhbmdlcyBmcm9tIGhpc3Rvcnkgc3RhY2sgdGhlcmUncyBubyBuZWVkXG4gICAgLy8gdG8gcnVuIGhpc3RvcnkgbG9naWMgYWdhaW4sIGFzIGhpc3RvcnkgZW50cmllcyBhbHJlYWR5IGNhbGN1bGF0ZWRcbiAgICBpZiAodGFncy5oYXMoSElTVE9SSUNfVEFHKSkge1xuICAgICAgcHJldkNoYW5nZVR5cGUgPSBPVEhFUjtcbiAgICAgIHByZXZDaGFuZ2VUaW1lID0gY2hhbmdlVGltZTtcbiAgICAgIHJldHVybiBESVNDQVJEX0hJU1RPUllfQ0FORElEQVRFO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VUeXBlID0gZ2V0Q2hhbmdlVHlwZShwcmV2RWRpdG9yU3RhdGUsIG5leHRFZGl0b3JTdGF0ZSwgZGlydHlMZWF2ZXMsIGRpcnR5RWxlbWVudHMsIGVkaXRvci5pc0NvbXBvc2luZygpKTtcbiAgICBjb25zdCBtZXJnZUFjdGlvbiA9ICgoKSA9PiB7XG4gICAgICBjb25zdCBpc1NhbWVFZGl0b3IgPSBjdXJyZW50SGlzdG9yeUVudHJ5ID09PSBudWxsIHx8IGN1cnJlbnRIaXN0b3J5RW50cnkuZWRpdG9yID09PSBlZGl0b3I7XG4gICAgICBjb25zdCBzaG91bGRQdXNoSGlzdG9yeSA9IHRhZ3MuaGFzKEhJU1RPUllfUFVTSF9UQUcpO1xuICAgICAgY29uc3Qgc2hvdWxkTWVyZ2VIaXN0b3J5ID0gIXNob3VsZFB1c2hIaXN0b3J5ICYmIGlzU2FtZUVkaXRvciAmJiB0YWdzLmhhcyhISVNUT1JZX01FUkdFX1RBRyk7XG4gICAgICBpZiAoc2hvdWxkTWVyZ2VIaXN0b3J5KSB7XG4gICAgICAgIHJldHVybiBISVNUT1JZX01FUkdFO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZFZGl0b3JTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gSElTVE9SWV9QVVNIO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gICAgICBjb25zdCBoYXNEaXJ0eU5vZGVzID0gZGlydHlMZWF2ZXMuc2l6ZSA+IDAgfHwgZGlydHlFbGVtZW50cy5zaXplID4gMDtcbiAgICAgIGlmICghaGFzRGlydHlOb2Rlcykge1xuICAgICAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIEhJU1RPUllfTUVSR0U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERJU0NBUkRfSElTVE9SWV9DQU5ESURBVEU7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUHVzaEhpc3RvcnkgPT09IGZhbHNlICYmIGNoYW5nZVR5cGUgIT09IE9USEVSICYmIGNoYW5nZVR5cGUgPT09IHByZXZDaGFuZ2VUeXBlICYmIGNoYW5nZVRpbWUgPCBwcmV2Q2hhbmdlVGltZSArIGRlbGF5ICYmIGlzU2FtZUVkaXRvcikge1xuICAgICAgICByZXR1cm4gSElTVE9SWV9NRVJHRTtcbiAgICAgIH1cblxuICAgICAgLy8gQSBzaW5nbGUgbm9kZSBtaWdodCBoYXZlIGJlZW4gbWFya2VkIGFzIGRpcnR5LCBidXQgbm90IGhhdmUgY2hhbmdlZFxuICAgICAgLy8gZHVlIHRvIHNvbWUgbm9kZSB0cmFuc2Zvcm0gcmV2ZXJ0aW5nIHRoZSBjaGFuZ2UuXG4gICAgICBpZiAoZGlydHlMZWF2ZXMuc2l6ZSA9PT0gMSkge1xuICAgICAgICBjb25zdCBkaXJ0eUxlYWZLZXkgPSBBcnJheS5mcm9tKGRpcnR5TGVhdmVzKVswXTtcbiAgICAgICAgaWYgKGlzVGV4dE5vZGVVbmNoYW5nZWQoZGlydHlMZWFmS2V5LCBwcmV2RWRpdG9yU3RhdGUsIG5leHRFZGl0b3JTdGF0ZSkpIHtcbiAgICAgICAgICByZXR1cm4gSElTVE9SWV9NRVJHRTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIEhJU1RPUllfUFVTSDtcbiAgICB9KSgpO1xuICAgIHByZXZDaGFuZ2VUaW1lID0gY2hhbmdlVGltZTtcbiAgICBwcmV2Q2hhbmdlVHlwZSA9IGNoYW5nZVR5cGU7XG4gICAgcmV0dXJuIG1lcmdlQWN0aW9uO1xuICB9O1xufVxuZnVuY3Rpb24gcmVkbyhlZGl0b3IsIGhpc3RvcnlTdGF0ZSkge1xuICBjb25zdCByZWRvU3RhY2sgPSBoaXN0b3J5U3RhdGUucmVkb1N0YWNrO1xuICBjb25zdCB1bmRvU3RhY2sgPSBoaXN0b3J5U3RhdGUudW5kb1N0YWNrO1xuICBpZiAocmVkb1N0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBoaXN0b3J5U3RhdGUuY3VycmVudDtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdW5kb1N0YWNrLnB1c2goY3VycmVudCk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKENBTl9VTkRPX0NPTU1BTkQsIHRydWUpO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5U3RhdGVFbnRyeSA9IHJlZG9TdGFjay5wb3AoKTtcbiAgICBpZiAocmVkb1N0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fUkVET19DT01NQU5ELCBmYWxzZSk7XG4gICAgfVxuICAgIGhpc3RvcnlTdGF0ZS5jdXJyZW50ID0gaGlzdG9yeVN0YXRlRW50cnkgfHwgbnVsbDtcbiAgICBpZiAoaGlzdG9yeVN0YXRlRW50cnkpIHtcbiAgICAgIGhpc3RvcnlTdGF0ZUVudHJ5LmVkaXRvci5zZXRFZGl0b3JTdGF0ZShoaXN0b3J5U3RhdGVFbnRyeS5lZGl0b3JTdGF0ZSwge1xuICAgICAgICB0YWc6IEhJU1RPUklDX1RBR1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1bmRvKGVkaXRvciwgaGlzdG9yeVN0YXRlKSB7XG4gIGNvbnN0IHJlZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2s7XG4gIGNvbnN0IHVuZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS51bmRvU3RhY2s7XG4gIGNvbnN0IHVuZG9TdGFja0xlbmd0aCA9IHVuZG9TdGFjay5sZW5ndGg7XG4gIGlmICh1bmRvU3RhY2tMZW5ndGggIT09IDApIHtcbiAgICBjb25zdCBjdXJyZW50ID0gaGlzdG9yeVN0YXRlLmN1cnJlbnQ7XG4gICAgY29uc3QgaGlzdG9yeVN0YXRlRW50cnkgPSB1bmRvU3RhY2sucG9wKCk7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHJlZG9TdGFjay5wdXNoKGN1cnJlbnQpO1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fUkVET19DT01NQU5ELCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHVuZG9TdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoQ0FOX1VORE9fQ09NTUFORCwgZmFsc2UpO1xuICAgIH1cbiAgICBoaXN0b3J5U3RhdGUuY3VycmVudCA9IGhpc3RvcnlTdGF0ZUVudHJ5IHx8IG51bGw7XG4gICAgaWYgKGhpc3RvcnlTdGF0ZUVudHJ5KSB7XG4gICAgICBoaXN0b3J5U3RhdGVFbnRyeS5lZGl0b3Iuc2V0RWRpdG9yU3RhdGUoaGlzdG9yeVN0YXRlRW50cnkuZWRpdG9yU3RhdGUsIHtcbiAgICAgICAgdGFnOiBISVNUT1JJQ19UQUdcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2xlYXJIaXN0b3J5KGhpc3RvcnlTdGF0ZSkge1xuICBoaXN0b3J5U3RhdGUudW5kb1N0YWNrID0gW107XG4gIGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2sgPSBbXTtcbiAgaGlzdG9yeVN0YXRlLmN1cnJlbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBuZWNlc3NhcnkgbGlzdGVuZXJzIHRvIG1hbmFnZSB1bmRvL3JlZG8gaGlzdG9yeSBzdGFjayBhbmQgcmVsYXRlZCBlZGl0b3IgY29tbWFuZHMuXG4gKiBJdCByZXR1cm5zIGB1bnJlZ2lzdGVyYCBjYWxsYmFjayB0aGF0IGNsZWFucyB1cCBhbGwgbGlzdGVuZXJzIGFuZCBzaG91bGQgYmUgY2FsbGVkIG9uIGVkaXRvciB1bm1vdW50LlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqIEBwYXJhbSBoaXN0b3J5U3RhdGUgLSBUaGUgaGlzdG9yeSBzdGF0ZSwgY29udGFpbmluZyB0aGUgY3VycmVudCBzdGF0ZSBhbmQgdGhlIHVuZG8vcmVkbyBzdGFjay5cbiAqIEBwYXJhbSBkZWxheSAtIFRoZSB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRoZSBlZGl0b3Igc2hvdWxkIGRlbGF5IGdlbmVyYXRpbmcgYSBuZXcgaGlzdG9yeSBzdGFjayxcbiAqIGluc3RlYWQgb2YgbWVyZ2luZyB0aGUgY3VycmVudCBjaGFuZ2VzIHdpdGggdGhlIGN1cnJlbnQgc3RhY2suXG4gKiBAcmV0dXJucyBUaGUgbGlzdGVuZXJzIGNsZWFudXAgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVySGlzdG9yeShlZGl0b3IsIGhpc3RvcnlTdGF0ZSwgZGVsYXkpIHtcbiAgY29uc3QgZ2V0TWVyZ2VBY3Rpb24gPSBjcmVhdGVNZXJnZUFjdGlvbkdldHRlcihlZGl0b3IsIGRlbGF5KTtcbiAgY29uc3QgYXBwbHlDaGFuZ2UgPSAoe1xuICAgIGVkaXRvclN0YXRlLFxuICAgIHByZXZFZGl0b3JTdGF0ZSxcbiAgICBkaXJ0eUxlYXZlcyxcbiAgICBkaXJ0eUVsZW1lbnRzLFxuICAgIHRhZ3NcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBoaXN0b3J5U3RhdGUuY3VycmVudDtcbiAgICBjb25zdCByZWRvU3RhY2sgPSBoaXN0b3J5U3RhdGUucmVkb1N0YWNrO1xuICAgIGNvbnN0IHVuZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS51bmRvU3RhY2s7XG4gICAgY29uc3QgY3VycmVudEVkaXRvclN0YXRlID0gY3VycmVudCA9PT0gbnVsbCA/IG51bGwgOiBjdXJyZW50LmVkaXRvclN0YXRlO1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGVkaXRvclN0YXRlID09PSBjdXJyZW50RWRpdG9yU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VBY3Rpb24gPSBnZXRNZXJnZUFjdGlvbihwcmV2RWRpdG9yU3RhdGUsIGVkaXRvclN0YXRlLCBjdXJyZW50LCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cywgdGFncyk7XG4gICAgaWYgKG1lcmdlQWN0aW9uID09PSBISVNUT1JZX1BVU0gpIHtcbiAgICAgIGlmIChyZWRvU3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2sgPSBbXTtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fUkVET19DT01NQU5ELCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICB1bmRvU3RhY2sucHVzaCh7XG4gICAgICAgICAgLi4uY3VycmVudFxuICAgICAgICB9KTtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fVU5ET19DT01NQU5ELCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1lcmdlQWN0aW9uID09PSBESVNDQVJEX0hJU1RPUllfQ0FORElEQVRFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRWxzZSB3ZSBtZXJnZVxuICAgIGhpc3RvcnlTdGF0ZS5jdXJyZW50ID0ge1xuICAgICAgZWRpdG9yLFxuICAgICAgZWRpdG9yU3RhdGVcbiAgICB9O1xuICB9O1xuICBjb25zdCB1bnJlZ2lzdGVyID0gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFVORE9fQ09NTUFORCwgKCkgPT4ge1xuICAgIHVuZG8oZWRpdG9yLCBoaXN0b3J5U3RhdGUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoUkVET19DT01NQU5ELCAoKSA9PiB7XG4gICAgcmVkbyhlZGl0b3IsIGhpc3RvcnlTdGF0ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDTEVBUl9FRElUT1JfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNsZWFySGlzdG9yeShoaXN0b3J5U3RhdGUpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENMRUFSX0hJU1RPUllfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNsZWFySGlzdG9yeShoaXN0b3J5U3RhdGUpO1xuICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoQ0FOX1JFRE9fQ09NTUFORCwgZmFsc2UpO1xuICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoQ0FOX1VORE9fQ09NTUFORCwgZmFsc2UpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKGFwcGx5Q2hhbmdlKSk7XG4gIHJldHVybiB1bnJlZ2lzdGVyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW1wdHkgaGlzdG9yeSBzdGF0ZS5cbiAqIEByZXR1cm5zIC0gVGhlIGVtcHR5IGhpc3Rvcnkgc3RhdGUsIGFzIGFuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogbnVsbCxcbiAgICByZWRvU3RhY2s6IFtdLFxuICAgIHVuZG9TdGFjazogW11cbiAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGUsIHJlZ2lzdGVySGlzdG9yeSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lexical+history@0.33.1/node_modules/@lexical/history/LexicalHistory.dev.mjs\n");

/***/ })

};
;