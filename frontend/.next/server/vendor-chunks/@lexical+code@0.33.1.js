"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+code@0.33.1";
exports.ids = ["vendor-chunks/@lexical+code@0.33.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@lexical+code@0.33.1/node_modules/@lexical/code/LexicalCode.dev.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+code@0.33.1/node_modules/@lexical/code/LexicalCode.dev.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createCodeHighlightNode: () => (/* binding */ $createCodeHighlightNode),\n/* harmony export */   $createCodeNode: () => (/* binding */ $createCodeNode),\n/* harmony export */   $getEndOfCodeInLine: () => (/* binding */ $getEndOfCodeInLine),\n/* harmony export */   $getFirstCodeNodeOfLine: () => (/* binding */ $getFirstCodeNodeOfLine),\n/* harmony export */   $getLastCodeNodeOfLine: () => (/* binding */ $getLastCodeNodeOfLine),\n/* harmony export */   $getStartOfCodeInLine: () => (/* binding */ $getStartOfCodeInLine),\n/* harmony export */   $isCodeHighlightNode: () => (/* binding */ $isCodeHighlightNode),\n/* harmony export */   $isCodeNode: () => (/* binding */ $isCodeNode),\n/* harmony export */   CODE_LANGUAGE_FRIENDLY_NAME_MAP: () => (/* binding */ CODE_LANGUAGE_FRIENDLY_NAME_MAP),\n/* harmony export */   CODE_LANGUAGE_MAP: () => (/* binding */ CODE_LANGUAGE_MAP),\n/* harmony export */   CodeHighlightNode: () => (/* binding */ CodeHighlightNode),\n/* harmony export */   CodeNode: () => (/* binding */ CodeNode),\n/* harmony export */   DEFAULT_CODE_LANGUAGE: () => (/* binding */ DEFAULT_CODE_LANGUAGE),\n/* harmony export */   PrismTokenizer: () => (/* binding */ PrismTokenizer),\n/* harmony export */   getCodeLanguages: () => (/* binding */ getCodeLanguages),\n/* harmony export */   getDefaultCodeLanguage: () => (/* binding */ getDefaultCodeLanguage),\n/* harmony export */   getEndOfCodeInLine: () => (/* binding */ getEndOfCodeInLine),\n/* harmony export */   getFirstCodeNodeOfLine: () => (/* binding */ getFirstCodeNodeOfLine),\n/* harmony export */   getLanguageFriendlyName: () => (/* binding */ getLanguageFriendlyName),\n/* harmony export */   getLastCodeNodeOfLine: () => (/* binding */ getLastCodeNodeOfLine),\n/* harmony export */   getStartOfCodeInLine: () => (/* binding */ getStartOfCodeInLine),\n/* harmony export */   normalizeCodeLang: () => (/* binding */ normalizeCodeLang),\n/* harmony export */   registerCodeHighlighting: () => (/* binding */ registerCodeHighlighting)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/.pnpm/lexical@0.33.1/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/.pnpm/@lexical+utils@0.33.1/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prismjs */ \"(ssr)/./node_modules/.pnpm/prismjs@1.30.0/node_modules/prismjs/prism.js\");\n/* harmony import */ var prismjs_components_prism_clike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prismjs/components/prism-clike.js */ \"(ssr)/./node_modules/.pnpm/prismjs@1.30.0/node_modules/prismjs/components/prism-clike.js\");\n/* harmony import */ var prismjs_components_prism_javascript_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prismjs/components/prism-javascript.js */ \"(ssr)/./node_modules/.pnpm/prismjs@1.30.0/node_modules/prismjs/components/prism-javascript.js\");\n/* harmony import */ var prismjs_components_prism_markup_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prismjs/components/prism-markup.js */ \"(ssr)/./node_modules/.pnpm/prismjs@1.30.0/node_modules/prismjs/components/prism-markup.js\");\n/* harmony import */ var prismjs_components_prism_markdown_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prismjs/components/prism-markdown.js */ \"(ssr)/./node_modules/.pnpm/prismjs@1.30.0/node_modules/prismjs/components/prism-markdown.js\");\n/* harmony import */ var prismjs_components_prism_c_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! prismjs/components/prism-c.js */ \"(ssr)/./node_modules/.pnpm/prismjs@1.30.0/node_modules/prismjs/components/prism-c.js\");\n/* harmony import */ var prismjs_components_prism_css_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prismjs/components/prism-css.js */ \"(ssr)/./node_modules/.pnpm/prismjs@1.30.0/node_modules/prismjs/components/prism-css.js\");\n/* harmony import */ var prismjs_components_prism_objectivec_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! prismjs/components/prism-objectivec.js */ \"(ssr)/./node_modules/.pnpm/prismjs@1.30.0/node_modules/prismjs/components/prism-objectivec.js\");\n/* harmony import */ var prismjs_components_prism_sql_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prismjs/components/prism-sql.js */ \"(ssr)/./node_modules/.pnpm/prismjs@1.30.0/node_modules/prismjs/components/prism-sql.js\");\n/* harmony import */ var prismjs_components_prism_powershell_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! prismjs/components/prism-powershell.js */ \"(ssr)/./node_modules/.pnpm/prismjs@1.30.0/node_modules/prismjs/components/prism-powershell.js\");\n/* harmony import */ var prismjs_components_prism_python_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! prismjs/components/prism-python.js */ \"(ssr)/./node_modules/.pnpm/prismjs@1.30.0/node_modules/prismjs/components/prism-python.js\");\n/* harmony import */ var prismjs_components_prism_rust_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! prismjs/components/prism-rust.js */ \"(ssr)/./node_modules/.pnpm/prismjs@1.30.0/node_modules/prismjs/components/prism-rust.js\");\n/* harmony import */ var prismjs_components_prism_swift_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! prismjs/components/prism-swift.js */ \"(ssr)/./node_modules/.pnpm/prismjs@1.30.0/node_modules/prismjs/components/prism-swift.js\");\n/* harmony import */ var prismjs_components_prism_typescript_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! prismjs/components/prism-typescript.js */ \"(ssr)/./node_modules/.pnpm/prismjs@1.30.0/node_modules/prismjs/components/prism-typescript.js\");\n/* harmony import */ var prismjs_components_prism_java_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! prismjs/components/prism-java.js */ \"(ssr)/./node_modules/.pnpm/prismjs@1.30.0/node_modules/prismjs/components/prism-java.js\");\n/* harmony import */ var prismjs_components_prism_cpp_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! prismjs/components/prism-cpp.js */ \"(ssr)/./node_modules/.pnpm/prismjs@1.30.0/node_modules/prismjs/components/prism-cpp.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// invariant(condition, message) will refine types based on \"condition\", and\n// if \"condition\" is false will throw an error. This function is special-cased\n// in flow itself, so we can't name it anything else.\nfunction invariant(cond, message, ...args) {\n  if (cond) {\n    return;\n  }\n  throw new Error('Internal Lexical error: invariant() is meant to be replaced at compile ' + 'time. There is no runtime version. Error: ' + message);\n}\n\n(function (Prism) {\n\n\tPrism.languages.diff = {\n\t\t'coord': [\n\t\t\t// Match all kinds of coord lines (prefixed by \"+++\", \"---\" or \"***\").\n\t\t\t/^(?:\\*{3}|-{3}|\\+{3}).*$/m,\n\t\t\t// Match \"@@ ... @@\" coord lines in unified diff.\n\t\t\t/^@@.*@@$/m,\n\t\t\t// Match coord lines in normal diff (starts with a number).\n\t\t\t/^\\d.*$/m\n\t\t]\n\n\t\t// deleted, inserted, unchanged, diff\n\t};\n\n\t/**\n\t * A map from the name of a block to its line prefix.\n\t *\n\t * @type {Object<string, string>}\n\t */\n\tvar PREFIXES = {\n\t\t'deleted-sign': '-',\n\t\t'deleted-arrow': '<',\n\t\t'inserted-sign': '+',\n\t\t'inserted-arrow': '>',\n\t\t'unchanged': ' ',\n\t\t'diff': '!',\n\t};\n\n\t// add a token for each prefix\n\tObject.keys(PREFIXES).forEach(function (name) {\n\t\tvar prefix = PREFIXES[name];\n\n\t\tvar alias = [];\n\t\tif (!/^\\w+$/.test(name)) { // \"deleted-sign\" -> \"deleted\"\n\t\t\talias.push(/\\w+/.exec(name)[0]);\n\t\t}\n\t\tif (name === 'diff') {\n\t\t\talias.push('bold');\n\t\t}\n\n\t\tPrism.languages.diff[name] = {\n\t\t\tpattern: RegExp('^(?:[' + prefix + '].*(?:\\r\\n?|\\n|(?![\\\\s\\\\S])))+', 'm'),\n\t\t\talias: alias,\n\t\t\tinside: {\n\t\t\t\t'line': {\n\t\t\t\t\tpattern: /(.)(?=[\\s\\S]).*(?:\\r\\n?|\\n)?/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'prefix': {\n\t\t\t\t\tpattern: /[\\s\\S]/,\n\t\t\t\t\talias: /\\w+/.exec(name)[0]\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t});\n\n\t// make prefixes available to Diff plugin\n\tObject.defineProperty(Prism.languages.diff, 'PREFIXES', {\n\t\tvalue: PREFIXES\n\t});\n\n}(Prism));\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst Prism$1 = globalThis.Prism || window.Prism;\n\n// The following code is extracted/adapted from prismjs v2\n// It will probably be possible to use it directly from prism v2\n// in the future when prismjs v2 is published and Lexical upgrades\n// the prismsjs dependency\n\nfunction getTextContent(token) {\n  if (typeof token === 'string') {\n    return token;\n  } else if (Array.isArray(token)) {\n    return token.map(getTextContent).join('');\n  } else {\n    return getTextContent(token.content);\n  }\n}\nfunction tokenizeDiffHighlight(tokens, language) {\n  const diffLanguage = language;\n  const diffGrammar = Prism$1.languages[diffLanguage];\n  const env = {\n    tokens\n  };\n  const PREFIXES = Prism$1.languages.diff.PREFIXES;\n  for (const token of env.tokens) {\n    if (typeof token === 'string' || !(token.type in PREFIXES) || !Array.isArray(token.content)) {\n      continue;\n    }\n    const type = token.type;\n    let insertedPrefixes = 0;\n    const getPrefixToken = () => {\n      insertedPrefixes++;\n      return new Prism$1.Token('prefix', PREFIXES[type], type.replace(/^(\\w+).*/, '$1'));\n    };\n    const withoutPrefixes = token.content.filter(t => typeof t === 'string' || t.type !== 'prefix');\n    const prefixCount = token.content.length - withoutPrefixes.length;\n    const diffTokens = Prism$1.tokenize(getTextContent(withoutPrefixes), diffGrammar);\n\n    // re-insert prefixes\n    // always add a prefix at the start\n    diffTokens.unshift(getPrefixToken());\n    const LINE_BREAK = /\\r\\n|\\n/g;\n    const insertAfterLineBreakString = text => {\n      const result = [];\n      LINE_BREAK.lastIndex = 0;\n      let last = 0;\n      let m;\n      while (insertedPrefixes < prefixCount && (m = LINE_BREAK.exec(text))) {\n        const end = m.index + m[0].length;\n        result.push(text.slice(last, end));\n        last = end;\n        result.push(getPrefixToken());\n      }\n      if (result.length === 0) {\n        return undefined;\n      }\n      if (last < text.length) {\n        result.push(text.slice(last));\n      }\n      return result;\n    };\n    const insertAfterLineBreak = toks => {\n      for (let i = 0; i < toks.length && insertedPrefixes < prefixCount; i++) {\n        const tok = toks[i];\n        if (typeof tok === 'string') {\n          const inserted = insertAfterLineBreakString(tok);\n          if (inserted) {\n            toks.splice(i, 1, ...inserted);\n            i += inserted.length - 1;\n          }\n        } else if (typeof tok.content === 'string') {\n          const inserted = insertAfterLineBreakString(tok.content);\n          if (inserted) {\n            tok.content = inserted;\n          }\n        } else if (Array.isArray(tok.content)) {\n          insertAfterLineBreak(tok.content);\n        } else {\n          insertAfterLineBreak([tok.content]);\n        }\n      }\n    };\n    insertAfterLineBreak(diffTokens);\n    if (insertedPrefixes < prefixCount) {\n      // we are missing the last prefix\n      diffTokens.push(getPrefixToken());\n    }\n    token.content = diffTokens;\n  }\n  return env.tokens;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst isLanguageSupportedByPrism = language => {\n  const DIFF_LANGUAGE_REGEX = /^diff-([\\w-]+)/i;\n  try {\n    if (!language) {\n      return false;\n    }\n    const langMatch = DIFF_LANGUAGE_REGEX.exec(language);\n    if (langMatch) {\n      return (\n        // eslint-disable-next-line no-prototype-builtins\n        Prism$1.languages.hasOwnProperty('diff') &&\n        // eslint-disable-next-line no-prototype-builtins\n        Prism$1.languages.hasOwnProperty(langMatch[1])\n      );\n    } else {\n      // eslint-disable-next-line no-prototype-builtins\n      return Prism$1.languages.hasOwnProperty(language);\n    }\n  } catch (_unused) {\n    return false;\n  }\n};\nfunction hasChildDOMNodeTag(node, tagName) {\n  for (const child of node.childNodes) {\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.isHTMLElement)(child) && child.tagName === tagName) {\n      return true;\n    }\n    hasChildDOMNodeTag(child, tagName);\n  }\n  return false;\n}\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-language';\nconst HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\n\n/** @noInheritDoc */\nclass CodeNode extends _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'code';\n  }\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n  constructor(language, key) {\n    super(key);\n    this.__language = language || undefined;\n    this.__isSyntaxHighlightSupported = isLanguageSupportedByPrism(language);\n  }\n\n  // View\n  createDOM(config) {\n    const element = document.createElement('code');\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.addClassNamesToElement)(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      if (this.getIsSyntaxHighlightSupported()) {\n        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n        if (this.__isSyntaxHighlightSupported) {\n          dom.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n        }\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n      if (prevNode.__isSyntaxHighlightSupported) {\n        dom.removeAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE);\n      }\n    }\n    return false;\n  }\n  exportDOM(editor) {\n    const element = document.createElement('pre');\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.addClassNamesToElement)(element, editor._config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      if (this.getIsSyntaxHighlightSupported()) {\n        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importDOM() {\n    return {\n      // Typically <pre> is used for code blocks, and <code> for inline code styles\n      // but if it's a multi line <code> we'll create a block. Pass through to\n      // inline format handled by TextNode otherwise.\n      code: node => {\n        const isMultiLine = node.textContent != null && (/\\r?\\n/.test(node.textContent) || hasChildDOMNodeTag(node, 'BR'));\n        return isMultiLine ? {\n          conversion: $convertPreElement,\n          priority: 1\n        } : null;\n      },\n      div: () => ({\n        conversion: $convertDivElement,\n        priority: 1\n      }),\n      pre: () => ({\n        conversion: $convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        const table = node;\n        // domNode is a <table> since we matched it by nodeName\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: $convertTableElement,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      td: node => {\n        // element is a <td> since we matched it by nodeName\n        const td = node;\n        const table = td.closest('table');\n        if (isGitHubCodeCell(td) || table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      tr: node => {\n        // element is a <tr> since we matched it by nodeName\n        const tr = node;\n        const table = tr.closest('table');\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createCodeNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setLanguage(serializedNode.language);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      language: this.getLanguage()\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createParagraphNode)();\n      this.insertAfter(newElement, restoreSelection);\n      return newElement;\n    }\n\n    // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n    const {\n      anchor,\n      focus\n    } = selection;\n    const firstPoint = anchor.isBefore(focus) ? anchor : focus;\n    const firstSelectionNode = firstPoint.getNode();\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTextNode)(firstSelectionNode)) {\n      let node = $getFirstCodeNodeOfLine(firstSelectionNode);\n      const insertNodes = [];\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(node)) {\n          insertNodes.push((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)());\n          node = node.getNextSibling();\n        } else if ($isCodeHighlightNode(node)) {\n          let spaces = 0;\n          const text = node.getTextContent();\n          const textSize = node.getTextContentSize();\n          while (spaces < textSize && text[spaces] === ' ') {\n            spaces++;\n          }\n          if (spaces !== 0) {\n            insertNodes.push($createCodeHighlightNode(' '.repeat(spaces)));\n          }\n          if (spaces !== textSize) {\n            break;\n          }\n          node = node.getNextSibling();\n        } else {\n          break;\n        }\n      }\n      const split = firstSelectionNode.splitText(anchor.offset)[0];\n      const x = anchor.offset === 0 ? 0 : 1;\n      const index = split.getIndexWithinParent() + x;\n      const codeNode = firstSelectionNode.getParentOrThrow();\n      const nodesToInsert = [(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createLineBreakNode)(), ...insertNodes];\n      codeNode.splice(index, 0, nodesToInsert);\n      const last = insertNodes[insertNodes.length - 1];\n      if (last) {\n        last.select();\n      } else if (anchor.offset === 0) {\n        split.selectPrevious();\n      } else {\n        split.getNextSibling().selectNext(0, 0);\n      }\n    }\n    if ($isCodeNode(firstSelectionNode)) {\n      const {\n        offset\n      } = selection.anchor;\n      firstSelectionNode.splice(offset, 0, [(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createLineBreakNode)()]);\n      firstSelectionNode.select(offset + 1, offset + 1);\n    }\n    return null;\n  }\n  canIndent() {\n    return false;\n  }\n  collapseAtStart() {\n    const paragraph = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = language || undefined;\n    writable.__isSyntaxHighlightSupported = isLanguageSupportedByPrism(language);\n    return writable;\n  }\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n  getIsSyntaxHighlightSupported() {\n    return this.getLatest().__isSyntaxHighlightSupported;\n  }\n}\nfunction $createCodeNode(language) {\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$applyNodeReplacement)(new CodeNode(language));\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\nfunction $convertPreElement(domNode) {\n  const language = domNode.getAttribute(LANGUAGE_DATA_ATTRIBUTE);\n  return {\n    node: $createCodeNode(language)\n  };\n}\nfunction $convertDivElement(domNode) {\n  // domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  const isCode = isCodeElement(div);\n  if (!isCode && !isCodeChildElement(div)) {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: isCode ? $createCodeNode() : null\n  };\n}\nfunction $convertTableElement() {\n  return {\n    node: $createCodeNode()\n  };\n}\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\nfunction isCodeChildElement(node) {\n  let parent = node.parentElement;\n  while (parent !== null) {\n    if (isCodeElement(parent)) {\n      return true;\n    }\n    parent = parent.parentElement;\n  }\n  return false;\n}\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n  c: 'C',\n  clike: 'C-like',\n  cpp: 'C++',\n  css: 'CSS',\n  html: 'HTML',\n  java: 'Java',\n  js: 'JavaScript',\n  markdown: 'Markdown',\n  objc: 'Objective-C',\n  plain: 'Plain Text',\n  powershell: 'PowerShell',\n  py: 'Python',\n  rust: 'Rust',\n  sql: 'SQL',\n  swift: 'Swift',\n  typescript: 'TypeScript',\n  xml: 'XML'\n};\nconst CODE_LANGUAGE_MAP = {\n  cpp: 'cpp',\n  java: 'java',\n  javascript: 'js',\n  md: 'markdown',\n  plaintext: 'plain',\n  python: 'py',\n  text: 'plain',\n  ts: 'typescript'\n};\nfunction normalizeCodeLang(lang) {\n  return CODE_LANGUAGE_MAP[lang] || lang;\n}\nfunction getLanguageFriendlyName(lang) {\n  const _lang = normalizeCodeLang(lang);\n  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n}\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nconst getCodeLanguages = () => Object.keys(Prism$1.languages).filter(\n// Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof Prism$1.languages[language] !== 'function').sort();\n\n/** @noInheritDoc */\nclass CodeHighlightNode extends _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.TextNode {\n  /** @internal */\n\n  constructor(text = '', highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n  static getType() {\n    return 'code-highlight';\n  }\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n  getHighlightType() {\n    const self = this.getLatest();\n    return self.__highlightType;\n  }\n  setHighlightType(highlightType) {\n    const self = this.getWritable();\n    self.__highlightType = highlightType || undefined;\n    return self;\n  }\n  canHaveFormat() {\n    return false;\n  }\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.addClassNamesToElement)(element, className);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.removeClassNamesFromElement)(dom, prevClassName);\n      }\n      if (nextClassName) {\n        (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.addClassNamesToElement)(dom, nextClassName);\n      }\n    }\n    return update;\n  }\n  static importJSON(serializedNode) {\n    return $createCodeHighlightNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHighlightType(serializedNode.highlightType);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      highlightType: this.getHighlightType()\n    };\n  }\n\n  // Prevent formatting (bold, underline, etc)\n  setFormat(format) {\n    return this;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createCodeNode();\n  }\n}\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\nfunction $createCodeHighlightNode(text = '', highlightType) {\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$applyNodeReplacement)(new CodeHighlightNode(text, highlightType));\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\nfunction $getLastMatchingCodeNode(anchor, direction) {\n  let matchingNode = anchor;\n  for (let caret = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSiblingCaret)(anchor, direction); caret && ($isCodeHighlightNode(caret.origin) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(caret.origin)); caret = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.$getAdjacentCaret)(caret)) {\n    matchingNode = caret.origin;\n  }\n  return matchingNode;\n}\nfunction $getFirstCodeNodeOfLine(anchor) {\n  return $getLastMatchingCodeNode(anchor, 'previous');\n}\nfunction $getLastCodeNodeOfLine(anchor) {\n  return $getLastMatchingCodeNode(anchor, 'next');\n}\n\nconst PrismTokenizer = {\n  defaultLanguage: DEFAULT_CODE_LANGUAGE,\n  tokenize(code, language) {\n    return Prism$1.tokenize(code, Prism$1.languages[language || ''] || Prism$1.languages[this.defaultLanguage]);\n  }\n};\nfunction $getStartOfCodeInLine(anchor, offset) {\n  let last = null;\n  let lastNonBlank = null;\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (nodeOffset === 0) {\n      node = node.getPreviousSibling();\n      if (node === null) {\n        break;\n      }\n      if (!($isCodeHighlightNode(node) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(node) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node))) {\n        formatDevErrorMessage(`Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode`);\n      }\n      if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node)) {\n        last = {\n          node,\n          offset: 1\n        };\n        break;\n      }\n      nodeOffset = Math.max(0, node.getTextContentSize() - 1);\n      nodeTextContent = node.getTextContent();\n    } else {\n      nodeOffset--;\n    }\n    const character = nodeTextContent[nodeOffset];\n    if ($isCodeHighlightNode(node) && character !== ' ') {\n      lastNonBlank = {\n        node,\n        offset: nodeOffset\n      };\n    }\n  }\n  // lastNonBlank !== null: anchor in the middle of code; move to line beginning\n  if (lastNonBlank !== null) {\n    return lastNonBlank;\n  }\n  // Spaces, tabs or nothing ahead of anchor\n  let codeCharacterAtAnchorOffset = null;\n  if (offset < anchor.getTextContentSize()) {\n    if ($isCodeHighlightNode(anchor)) {\n      codeCharacterAtAnchorOffset = anchor.getTextContent()[offset];\n    }\n  } else {\n    const nextSibling = anchor.getNextSibling();\n    if ($isCodeHighlightNode(nextSibling)) {\n      codeCharacterAtAnchorOffset = nextSibling.getTextContent()[0];\n    }\n  }\n  if (codeCharacterAtAnchorOffset !== null && codeCharacterAtAnchorOffset !== ' ') {\n    // Borderline whitespace and code, move to line beginning\n    return last;\n  } else {\n    const nextNonBlank = findNextNonBlankInLine(anchor, offset);\n    if (nextNonBlank !== null) {\n      return nextNonBlank;\n    } else {\n      return last;\n    }\n  }\n}\nfunction findNextNonBlankInLine(anchor, offset) {\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  let nodeTextContentSize = anchor.getTextContentSize();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (!$isCodeHighlightNode(node) || nodeOffset === nodeTextContentSize) {\n      node = node.getNextSibling();\n      if (node === null || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node)) {\n        return null;\n      }\n      if ($isCodeHighlightNode(node)) {\n        nodeOffset = 0;\n        nodeTextContent = node.getTextContent();\n        nodeTextContentSize = node.getTextContentSize();\n      }\n    }\n    if ($isCodeHighlightNode(node)) {\n      if (nodeTextContent[nodeOffset] !== ' ') {\n        return {\n          node,\n          offset: nodeOffset\n        };\n      }\n      nodeOffset++;\n    }\n  }\n}\nfunction $getEndOfCodeInLine(anchor) {\n  const lastNode = $getLastCodeNodeOfLine(anchor);\n  if (!!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(lastNode)) {\n    formatDevErrorMessage(`Unexpected lineBreakNode in getEndOfCodeInLine`);\n  }\n  return lastNode;\n}\nfunction $textNodeTransform(node, editor, tokenizer) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor, tokenizer);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTextNode)(node.__text));\n  }\n}\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n  if (codeElement === null) {\n    return;\n  }\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  // @ts-ignore: internal field\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  }\n  // @ts-ignore:: internal field\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n  for (let i = 0; i < childrenLength; i++) {\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n  codeElement.setAttribute('data-gutter', gutter);\n}\n\n// Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra cache (`nodesCurrentlyHighlighting`) since both CodeNode and CodeHighlightNode\n// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\nconst nodesCurrentlyHighlighting = new Set();\nfunction codeNodeTransform(node, editor, tokenizer) {\n  const nodeKey = node.getKey();\n  if (nodesCurrentlyHighlighting.has(nodeKey)) {\n    return;\n  }\n  nodesCurrentlyHighlighting.add(nodeKey);\n\n  // When new code block inserted it might not have language selected\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(tokenizer.defaultLanguage);\n  }\n\n  // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual CodeHighlightNode to be transformed again as it's already\n  // in its final state\n  editor.update(() => {\n    $updateAndRetainSelection(nodeKey, () => {\n      const currentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getNodeByKey)(nodeKey);\n      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n        return false;\n      }\n      const DIFF_LANGUAGE_REGEX = /^diff-([\\w-]+)/i;\n      const currentLanguage = currentNode.getLanguage() || tokenizer.defaultLanguage;\n      const diffLanguageMatch = DIFF_LANGUAGE_REGEX.exec(currentLanguage);\n      const code = currentNode.getTextContent();\n      let tokens = tokenizer.tokenize(code, diffLanguageMatch ? 'diff' : currentLanguage);\n      if (diffLanguageMatch) {\n        tokens = tokenizeDiffHighlight(tokens, diffLanguageMatch[1]);\n      }\n      const highlightNodes = $getHighlightNodes(tokens);\n      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      nodesCurrentlyHighlighting.delete(nodeKey);\n    },\n    skipTransforms: true\n  });\n}\nfunction $getHighlightNodes(tokens, type) {\n  const nodes = [];\n  for (const token of tokens) {\n    if (typeof token === 'string') {\n      const partials = token.split(/(\\n|\\t)/);\n      const partialsLength = partials.length;\n      for (let i = 0; i < partialsLength; i++) {\n        const part = partials[i];\n        if (part === '\\n' || part === '\\r\\n') {\n          nodes.push((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createLineBreakNode)());\n        } else if (part === '\\t') {\n          nodes.push((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)());\n        } else if (part.length > 0) {\n          nodes.push($createCodeHighlightNode(part, type));\n        }\n      }\n    } else {\n      const {\n        content,\n        alias\n      } = token;\n      if (typeof content === 'string') {\n        nodes.push(...$getHighlightNodes([content], token.type === 'prefix' && typeof alias === 'string' ? alias : token.type));\n      } else if (Array.isArray(content)) {\n        nodes.push(...$getHighlightNodes(content, token.type === 'unchanged' ? undefined : token.type));\n      }\n    }\n  }\n  return nodes;\n}\n\n// Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\nfunction $updateAndRetainSelection(nodeKey, updateFn) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getNodeByKey)(nodeKey);\n  if (!$isCodeNode(node) || !node.isAttached()) {\n    return;\n  }\n  const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n  // If it's not range selection (or null selection) there's no need to change it,\n  // but we can still run highlighting logic\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection)) {\n    updateFn();\n    return;\n  }\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0;\n\n  // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + _node.getTextContentSize();\n    }, 0);\n  }\n  const hasChanges = updateFn();\n  if (!hasChanges) {\n    return;\n  }\n\n  // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  }\n\n  // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n  node.getChildren().some(_node => {\n    const isText = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTextNode)(_node);\n    if (isText || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(_node)) {\n      const textContentSize = _node.getTextContentSize();\n      if (isText && textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n        return true;\n      }\n      textOffset -= textContentSize;\n    }\n    return false;\n  });\n}\n\n// Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n    leadingMatch++;\n  }\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code highlight nodes, tabs and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  return $isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB) && nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(nodeA) && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(nodeB) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(nodeA) && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(nodeB);\n}\n\n/**\n * Returns a boolean.\n * Check that the selection span is within a single CodeNode.\n * This is used to guard against executing handlers that can only be\n * applied in a single CodeNode context\n */\nfunction $isSelectionInCode(selection) {\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection)) {\n    return false;\n  }\n  const anchorNode = selection.anchor.getNode();\n  const maybeAnchorCodeNode = $isCodeNode(anchorNode) ? anchorNode : anchorNode.getParent();\n  const focusNode = selection.focus.getNode();\n  const maybeFocusCodeNode = $isCodeNode(focusNode) ? focusNode : focusNode.getParent();\n  return $isCodeNode(maybeAnchorCodeNode) && maybeAnchorCodeNode.is(maybeFocusCodeNode);\n}\n\n/**\n * Returns an Array of code lines\n * Take the sequence of LineBreakNode | TabNode | CodeHighlightNode forming\n * the selection and split it by LineBreakNode.\n * If the selection ends at the start of the last line, it is considered empty.\n * Empty lines are discarded.\n */\nfunction $getCodeLines(selection) {\n  const nodes = selection.getNodes();\n  const lines = [];\n  if (nodes.length === 1 && $isCodeNode(nodes[0])) {\n    return lines;\n  }\n  let lastLine = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!($isCodeHighlightNode(node) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(node) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node))) {\n      formatDevErrorMessage(`Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode`);\n    }\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node)) {\n      if (lastLine.length > 0) {\n        lines.push(lastLine);\n        lastLine = [];\n      }\n    } else {\n      lastLine.push(node);\n    }\n  }\n  if (lastLine.length > 0) {\n    const selectionEnd = selection.isBackward() ? selection.anchor : selection.focus;\n\n    // Discard the last line if the selection ends exactly at the\n    // start of the line (no real selection)\n    const lastPoint = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createPoint)(lastLine[0].getKey(), 0, 'text');\n    if (!selectionEnd.is(lastPoint)) {\n      lines.push(lastLine);\n    }\n  }\n  return lines;\n}\nfunction $handleTab(shiftKey) {\n  const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection) || !$isSelectionInCode(selection)) {\n    return null;\n  }\n  const indentOrOutdent = !shiftKey ? _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND : _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.OUTDENT_CONTENT_COMMAND;\n  const tabOrOutdent = !shiftKey ? _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INSERT_TAB_COMMAND : _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.OUTDENT_CONTENT_COMMAND;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n\n  // 1. early decision when there is no real selection\n  if (anchor.is(focus)) {\n    return tabOrOutdent;\n  }\n\n  // 2. If only empty lines or multiple non-empty lines are selected: indent/outdent\n  const codeLines = $getCodeLines(selection);\n  if (codeLines.length !== 1) {\n    return indentOrOutdent;\n  }\n  const codeLine = codeLines[0];\n  const codeLineLength = codeLine.length;\n  if (!(codeLineLength !== 0)) {\n    formatDevErrorMessage(`$getCodeLines only extracts non-empty lines`);\n  } // Take into account the direction of the selection\n  let selectionFirst;\n  let selectionLast;\n  if (selection.isBackward()) {\n    selectionFirst = focus;\n    selectionLast = anchor;\n  } else {\n    selectionFirst = anchor;\n    selectionLast = focus;\n  }\n\n  // find boundary elements of the line\n  // since codeLine only contains TabNode | CodeHighlightNode\n  // the result of these functions should is of Type TabNode | CodeHighlightNode\n  const firstOfLine = $getFirstCodeNodeOfLine(codeLine[0]);\n  const lastOfLine = $getLastCodeNodeOfLine(codeLine[0]);\n  const anchorOfLine = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createPoint)(firstOfLine.getKey(), 0, 'text');\n  const focusOfLine = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createPoint)(lastOfLine.getKey(), lastOfLine.getTextContentSize(), 'text');\n\n  // 3. multiline because selection started strictly before the line\n  if (selectionFirst.isBefore(anchorOfLine)) {\n    return indentOrOutdent;\n  }\n\n  // 4. multiline because the selection stops strictly after the line\n  if (focusOfLine.isBefore(selectionLast)) {\n    return indentOrOutdent;\n  }\n\n  // The selection if within the line.\n  // 4. If it does not touch both borders, it needs a tab\n  if (anchorOfLine.isBefore(selectionFirst) || selectionLast.isBefore(focusOfLine)) {\n    return tabOrOutdent;\n  }\n\n  // 5. Selection is matching a full line on non-empty code\n  return indentOrOutdent;\n}\nfunction $handleMultilineIndent(type) {\n  const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection) || !$isSelectionInCode(selection)) {\n    return false;\n  }\n  const codeLines = $getCodeLines(selection);\n  const codeLinesLength = codeLines.length;\n\n  // Special Indent case\n  // Selection is collapsed at the beginning of a line\n  if (codeLinesLength === 0 && selection.isCollapsed()) {\n    if (type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND) {\n      selection.insertNodes([(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)()]);\n    }\n    return true;\n  }\n\n  // Special Indent case\n  // Selection is matching only one LineBreak\n  if (codeLinesLength === 0 && type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND && selection.getTextContent() === '\\n') {\n    const tabNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)();\n    const lineBreakNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createLineBreakNode)();\n    const direction = selection.isBackward() ? 'previous' : 'next';\n    selection.insertNodes([tabNode, lineBreakNode]);\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$setSelectionFromCaretRange)((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getCaretRangeInDirection)((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getCaretRange)((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getTextPointCaret)(tabNode, 'next', 0), (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$normalizeCaret)((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSiblingCaret)(lineBreakNode, 'next'))), direction));\n    return true;\n  }\n\n  // Indent Non Empty Lines\n  for (let i = 0; i < codeLinesLength; i++) {\n    const line = codeLines[i];\n    // a line here is never empty\n    if (line.length > 0) {\n      let firstOfLine = line[0];\n\n      // make sure to consider the first node on the first line\n      // because the line might not be fully selected\n      if (i === 0) {\n        firstOfLine = $getFirstCodeNodeOfLine(firstOfLine);\n      }\n      if (type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND) {\n        const tabNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)();\n        firstOfLine.insertBefore(tabNode);\n        // First real code line may need selection adjustment\n        // when firstOfLine is at the selection boundary\n        if (i === 0) {\n          const anchorKey = selection.isBackward() ? 'focus' : 'anchor';\n          const anchorLine = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createPoint)(firstOfLine.getKey(), 0, 'text');\n          if (selection[anchorKey].is(anchorLine)) {\n            selection[anchorKey].set(tabNode.getKey(), 0, 'text');\n          }\n        }\n      } else if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(firstOfLine)) {\n        firstOfLine.remove();\n      }\n    }\n  }\n  return true;\n}\nfunction $handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection)) {\n    return false;\n  }\n\n  // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_UP_COMMAND;\n\n  // Ensure the selection is within the codeblock\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(anchorNode)) || !($isCodeHighlightNode(focusNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(focusNode))) {\n    return false;\n  }\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // siblings that can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  let start;\n  let end;\n  if (anchorNode.isBefore(focusNode)) {\n    start = $getFirstCodeNodeOfLine(anchorNode);\n    end = $getLastCodeNodeOfLine(focusNode);\n  } else {\n    start = $getFirstCodeNodeOfLine(focusNode);\n    end = $getLastCodeNodeOfLine(anchorNode);\n  }\n  if (start == null || end == null) {\n    return false;\n  }\n  const range = start.getNodesBetween(end);\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n    if (!$isCodeHighlightNode(node) && !(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(node) && !(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node)) {\n      return false;\n    }\n  }\n\n  // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(linebreak)) {\n    return true;\n  }\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n  if (sibling == null) {\n    return true;\n  }\n  const maybeInsertionPoint = $isCodeHighlightNode(sibling) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(sibling) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(sibling) ? arrowIsUp ? $getFirstCodeNodeOfLine(sibling) : $getLastCodeNodeOfLine(sibling) : null;\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n  if (type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\nfunction $handleMoveTo(type, event) {\n  const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection)) {\n    return false;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const isMoveToStart = type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.MOVE_TO_START;\n\n  // Ensure the selection is within the codeblock\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(anchorNode)) || !($isCodeHighlightNode(focusNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(focusNode))) {\n    return false;\n  }\n  if (isMoveToStart) {\n    const start = $getStartOfCodeInLine(focusNode, focus.offset);\n    if (start !== null) {\n      const {\n        node,\n        offset\n      } = start;\n      if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node)) {\n        node.selectNext(0, 0);\n      } else {\n        selection.setTextNodeRange(node, offset, node, offset);\n      }\n    } else {\n      focusNode.getParentOrThrow().selectStart();\n    }\n  } else {\n    const node = $getEndOfCodeInLine(focusNode);\n    node.select();\n  }\n  event.preventDefault();\n  event.stopPropagation();\n  return true;\n}\nfunction registerCodeHighlighting(editor, tokenizer) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n  if (tokenizer == null) {\n    tokenizer = PrismTokenizer;\n  }\n  const registrations = [];\n\n  // Only register the mutation listener if not in headless mode\n  if (editor._headless !== true) {\n    registrations.push(editor.registerMutationListener(CodeNode, mutations => {\n      editor.update(() => {\n        for (const [key, type] of mutations) {\n          if (type !== 'destroyed') {\n            const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getNodeByKey)(key);\n            if (node !== null) {\n              updateCodeGutter(node, editor);\n            }\n          }\n        }\n      });\n    }, {\n      skipInitialization: false\n    }));\n  }\n\n  // Add the rest of the registrations\n  registrations.push(editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.TextNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_TAB_COMMAND, event => {\n    const command = $handleTab(event.shiftKey);\n    if (command === null) {\n      return false;\n    }\n    event.preventDefault();\n    editor.dispatchCommand(command, undefined);\n    return true;\n  }, _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INSERT_TAB_COMMAND, () => {\n    const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$insertNodes)([(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)()]);\n    return true;\n  }, _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND), _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.OUTDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.OUTDENT_CONTENT_COMMAND), _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_UP_COMMAND, event => {\n    const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n    if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    // If at the start of a code block, prevent selection from moving out\n    if (selection.isCollapsed() && anchor.offset === 0 && anchorNode.getPreviousSibling() === null && $isCodeNode(anchorNode.getParentOrThrow())) {\n      event.preventDefault();\n      return true;\n    }\n    return $handleShiftLines(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_UP_COMMAND, event);\n  }, _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n    if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    // If at the end of a code block, prevent selection from moving out\n    if (selection.isCollapsed() && anchor.offset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null && $isCodeNode(anchorNode.getParentOrThrow())) {\n      event.preventDefault();\n      return true;\n    }\n    return $handleShiftLines(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_DOWN_COMMAND, event);\n  }, _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.MOVE_TO_START, event => $handleMoveTo(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.MOVE_TO_START, event), _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.MOVE_TO_END, event => $handleMoveTo(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.MOVE_TO_END, event), _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW));\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.mergeRegister)(...registrations);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/** @deprecated renamed to {@link $getFirstCodeNodeOfLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getFirstCodeNodeOfLine = $getFirstCodeNodeOfLine;\n/** @deprecated renamed to {@link $getLastCodeNodeOfLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getLastCodeNodeOfLine = $getLastCodeNodeOfLine;\n/** @deprecated renamed to {@link $getEndOfCodeInLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getEndOfCodeInLine = $getEndOfCodeInLine;\n/** @deprecated renamed to {@link $getStartOfCodeInLine} by @lexical/eslint-plugin rules-of-lexical */\nconst getStartOfCodeInLine = $getStartOfCodeInLine;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrY29kZUAwLjMzLjEvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2NvZGUvTGV4aWNhbENvZGUuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzSTtBQUMyYjtBQUNoakI7QUFDMEI7QUFDSztBQUNKO0FBQ0U7QUFDUDtBQUNFO0FBQ087QUFDUDtBQUNPO0FBQ0o7QUFDRjtBQUNDO0FBQ0s7QUFDTjtBQUNEOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbURBQW1EO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsd0RBQVc7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUVBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUVBQW9CO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVEsNERBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJEQUFVO0FBQ3RCLDJCQUEyQiwrREFBYztBQUN6QztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxRUFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDRDQUE0QyxxRUFBb0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxRUFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNFQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MscURBQVE7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0RUFBMkI7QUFDbkM7QUFDQTtBQUNBLFFBQVEsdUVBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0VBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpRUFBZ0IscUJBQXFCLGdEQUFnRCwyREFBVSxpQkFBaUIsUUFBUSxrRUFBaUI7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMkRBQVUsVUFBVSxpRUFBZ0I7QUFDOUU7QUFDQTtBQUNBLFVBQVUsaUVBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlFQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsaUJBQWlCLGdFQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEMsUUFBUSxpRUFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhEQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBLHFCQUFxQixxRUFBb0I7QUFDekMsVUFBVTtBQUNWLHFCQUFxQiwrREFBYztBQUNuQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhEQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4REFBYTtBQUNqQztBQUNBO0FBQ0EsT0FBTyxrRUFBaUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxpRUFBZ0I7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNERBQVc7QUFDOUIsa0JBQWtCLGlFQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJKQUEySiwyREFBVSxXQUFXLDJEQUFVLFdBQVcsaUVBQWdCLFdBQVcsaUVBQWdCO0FBQ2hQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxrRUFBaUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBLHdDQUF3QywyREFBVSxVQUFVLGlFQUFnQjtBQUM1RTtBQUNBO0FBQ0EsUUFBUSxpRUFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLDZEQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhEQUFhO0FBQ2pDLE9BQU8sa0VBQWlCO0FBQ3hCO0FBQ0E7QUFDQSxzQ0FBc0MsbUVBQXNCLEdBQUcsb0VBQXVCO0FBQ3RGLG1DQUFtQywrREFBa0IsR0FBRyxvRUFBdUI7QUFDL0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2REFBWTtBQUNuQyxzQkFBc0IsNkRBQVk7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOERBQWE7QUFDakMsT0FBTyxrRUFBaUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1FQUFzQjtBQUN2Qyw2QkFBNkIsK0RBQWM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsbUVBQXNCO0FBQzlELG9CQUFvQiwrREFBYztBQUNsQywwQkFBMEIscUVBQW9CO0FBQzlDO0FBQ0E7QUFDQSxJQUFJLDRFQUEyQixDQUFDLDBFQUF5QixDQUFDLCtEQUFjLENBQUMsbUVBQWtCLHNCQUFzQixnRUFBZSxDQUFDLGlFQUFnQjtBQUNqSjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1FQUFzQjtBQUN6Qyx3QkFBd0IsK0RBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2REFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUywyREFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhEQUFhO0FBQ2pDLE9BQU8sa0VBQWlCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpRUFBb0I7O0FBRWpEO0FBQ0EsOEVBQThFLDJEQUFVLHNEQUFzRCwyREFBVTtBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQSx3Q0FBd0MsMkRBQVUsV0FBVyxpRUFBZ0I7QUFDN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBLE9BQU8saUVBQWdCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCwyREFBVSxhQUFhLGlFQUFnQjtBQUN0RztBQUNBO0FBQ0E7QUFDQSxlQUFlLGlFQUFvQjtBQUNuQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4REFBYTtBQUNqQyxPQUFPLGtFQUFpQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxpQ0FBaUMsMERBQWE7O0FBRTlDO0FBQ0EsOEVBQThFLDJEQUFVLHNEQUFzRCwyREFBVTtBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFVBQVUsaUVBQWdCO0FBQzFCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhEQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsOElBQThJLHFEQUFRLHFMQUFxTCw0REFBZTtBQUMxVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSxpRUFBb0IsMEJBQTBCLCtEQUFrQjtBQUNyRSxzQkFBc0IsOERBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2REFBWSxFQUFFLCtEQUFjO0FBQ2hDO0FBQ0EsR0FBRyxFQUFFLGlFQUFvQiwwQkFBMEIsbUVBQXNCLG9DQUFvQyxtRUFBc0IsR0FBRyxpRUFBb0IsMEJBQTBCLG9FQUF1QixvQ0FBb0Msb0VBQXVCLEdBQUcsaUVBQW9CLDBCQUEwQixpRUFBb0I7QUFDM1Usc0JBQXNCLDhEQUFhO0FBQ25DLFNBQVMsa0VBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpRUFBb0I7QUFDakQsR0FBRyxFQUFFLGlFQUFvQiwwQkFBMEIsbUVBQXNCO0FBQ3pFLHNCQUFzQiw4REFBYTtBQUNuQyxTQUFTLGtFQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUVBQXNCO0FBQ25ELEdBQUcsRUFBRSxpRUFBb0IsMEJBQTBCLDBEQUFhLHlCQUF5QiwwREFBYSxVQUFVLGlFQUFvQiwwQkFBMEIsd0RBQVcseUJBQXlCLHdEQUFXLFVBQVUsaUVBQW9CO0FBQzNPLFNBQVMsOERBQWE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7O0FBRXNmIiwic291cmNlcyI6WyIvVXNlcnMvYW5raXRocmVkZHkvRGVza3RvcC9oYWNrYXRob25zL2thZ2dsZWdlbW1hL2xlcmVwYWlyYm90aW5mZXJlbmNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9AbGV4aWNhbCtjb2RlQDAuMzMuMS9ub2RlX21vZHVsZXMvQGxleGljYWwvY29kZS9MZXhpY2FsQ29kZS5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCwgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCwgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50LCAkZ2V0QWRqYWNlbnRDYXJldCwgbWVyZ2VSZWdpc3RlciB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7IEVsZW1lbnROb2RlLCAkY3JlYXRlUGFyYWdyYXBoTm9kZSwgJGlzVGV4dE5vZGUsICRpc1RhYk5vZGUsICRjcmVhdGVUYWJOb2RlLCAkY3JlYXRlTGluZUJyZWFrTm9kZSwgJGFwcGx5Tm9kZVJlcGxhY2VtZW50LCBUZXh0Tm9kZSwgJGdldFNpYmxpbmdDYXJldCwgJGlzTGluZUJyZWFrTm9kZSwgJGNyZWF0ZVRleHROb2RlLCAkZ2V0Tm9kZUJ5S2V5LCAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGNyZWF0ZVBvaW50LCBJTkRFTlRfQ09OVEVOVF9DT01NQU5ELCBPVVRERU5UX0NPTlRFTlRfQ09NTUFORCwgSU5TRVJUX1RBQl9DT01NQU5ELCAkc2V0U2VsZWN0aW9uRnJvbUNhcmV0UmFuZ2UsICRnZXRDYXJldFJhbmdlSW5EaXJlY3Rpb24sICRnZXRDYXJldFJhbmdlLCAkZ2V0VGV4dFBvaW50Q2FyZXQsICRub3JtYWxpemVDYXJldCwgS0VZX0FSUk9XX1VQX0NPTU1BTkQsIE1PVkVfVE9fU1RBUlQsIEtFWV9UQUJfQ09NTUFORCwgQ09NTUFORF9QUklPUklUWV9MT1csICRpbnNlcnROb2RlcywgS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgTU9WRV9UT19FTkQgfSBmcm9tICdsZXhpY2FsJztcbmltcG9ydCAncHJpc21qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jbGlrZS5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1qYXZhc2NyaXB0LmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLW1hcmt1cC5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1tYXJrZG93bi5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jLmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWNzcy5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1vYmplY3RpdmVjLmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXNxbC5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1wb3dlcnNoZWxsLmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXB5dGhvbi5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1ydXN0LmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXN3aWZ0LmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXR5cGVzY3JpcHQuanMnO1xuaW1wb3J0ICdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tamF2YS5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jcHAuanMnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8vIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIGBpbnZhcmlhbnRgIGNhbGxzLlxuXG5mdW5jdGlvbiBmb3JtYXREZXZFcnJvck1lc3NhZ2UobWVzc2FnZSkge1xuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLy8gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkgd2lsbCByZWZpbmUgdHlwZXMgYmFzZWQgb24gXCJjb25kaXRpb25cIiwgYW5kXG4vLyBpZiBcImNvbmRpdGlvblwiIGlzIGZhbHNlIHdpbGwgdGhyb3cgYW4gZXJyb3IuIFRoaXMgZnVuY3Rpb24gaXMgc3BlY2lhbC1jYXNlZFxuLy8gaW4gZmxvdyBpdHNlbGYsIHNvIHdlIGNhbid0IG5hbWUgaXQgYW55dGhpbmcgZWxzZS5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kLCBtZXNzYWdlLCAuLi5hcmdzKSB7XG4gIGlmIChjb25kKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignSW50ZXJuYWwgTGV4aWNhbCBlcnJvcjogaW52YXJpYW50KCkgaXMgbWVhbnQgdG8gYmUgcmVwbGFjZWQgYXQgY29tcGlsZSAnICsgJ3RpbWUuIFRoZXJlIGlzIG5vIHJ1bnRpbWUgdmVyc2lvbi4gRXJyb3I6ICcgKyBtZXNzYWdlKTtcbn1cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuXG5cdFByaXNtLmxhbmd1YWdlcy5kaWZmID0ge1xuXHRcdCdjb29yZCc6IFtcblx0XHRcdC8vIE1hdGNoIGFsbCBraW5kcyBvZiBjb29yZCBsaW5lcyAocHJlZml4ZWQgYnkgXCIrKytcIiwgXCItLS1cIiBvciBcIioqKlwiKS5cblx0XHRcdC9eKD86XFwqezN9fC17M318XFwrezN9KS4qJC9tLFxuXHRcdFx0Ly8gTWF0Y2ggXCJAQCAuLi4gQEBcIiBjb29yZCBsaW5lcyBpbiB1bmlmaWVkIGRpZmYuXG5cdFx0XHQvXkBALipAQCQvbSxcblx0XHRcdC8vIE1hdGNoIGNvb3JkIGxpbmVzIGluIG5vcm1hbCBkaWZmIChzdGFydHMgd2l0aCBhIG51bWJlcikuXG5cdFx0XHQvXlxcZC4qJC9tXG5cdFx0XVxuXG5cdFx0Ly8gZGVsZXRlZCwgaW5zZXJ0ZWQsIHVuY2hhbmdlZCwgZGlmZlxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBIG1hcCBmcm9tIHRoZSBuYW1lIG9mIGEgYmxvY2sgdG8gaXRzIGxpbmUgcHJlZml4LlxuXHQgKlxuXHQgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn1cblx0ICovXG5cdHZhciBQUkVGSVhFUyA9IHtcblx0XHQnZGVsZXRlZC1zaWduJzogJy0nLFxuXHRcdCdkZWxldGVkLWFycm93JzogJzwnLFxuXHRcdCdpbnNlcnRlZC1zaWduJzogJysnLFxuXHRcdCdpbnNlcnRlZC1hcnJvdyc6ICc+Jyxcblx0XHQndW5jaGFuZ2VkJzogJyAnLFxuXHRcdCdkaWZmJzogJyEnLFxuXHR9O1xuXG5cdC8vIGFkZCBhIHRva2VuIGZvciBlYWNoIHByZWZpeFxuXHRPYmplY3Qua2V5cyhQUkVGSVhFUykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHRcdHZhciBwcmVmaXggPSBQUkVGSVhFU1tuYW1lXTtcblxuXHRcdHZhciBhbGlhcyA9IFtdO1xuXHRcdGlmICghL15cXHcrJC8udGVzdChuYW1lKSkgeyAvLyBcImRlbGV0ZWQtc2lnblwiIC0+IFwiZGVsZXRlZFwiXG5cdFx0XHRhbGlhcy5wdXNoKC9cXHcrLy5leGVjKG5hbWUpWzBdKTtcblx0XHR9XG5cdFx0aWYgKG5hbWUgPT09ICdkaWZmJykge1xuXHRcdFx0YWxpYXMucHVzaCgnYm9sZCcpO1xuXHRcdH1cblxuXHRcdFByaXNtLmxhbmd1YWdlcy5kaWZmW25hbWVdID0ge1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKCdeKD86WycgKyBwcmVmaXggKyAnXS4qKD86XFxyXFxuP3xcXG58KD8hW1xcXFxzXFxcXFNdKSkpKycsICdtJyksXG5cdFx0XHRhbGlhczogYWxpYXMsXG5cdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0J2xpbmUnOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogLyguKSg/PVtcXHNcXFNdKS4qKD86XFxyXFxuP3xcXG4pPy8sXG5cdFx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQncHJlZml4Jzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC9bXFxzXFxTXS8sXG5cdFx0XHRcdFx0YWxpYXM6IC9cXHcrLy5leGVjKG5hbWUpWzBdXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdH0pO1xuXG5cdC8vIG1ha2UgcHJlZml4ZXMgYXZhaWxhYmxlIHRvIERpZmYgcGx1Z2luXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcmlzbS5sYW5ndWFnZXMuZGlmZiwgJ1BSRUZJWEVTJywge1xuXHRcdHZhbHVlOiBQUkVGSVhFU1xuXHR9KTtcblxufShQcmlzbSkpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IFByaXNtJDEgPSBnbG9iYWxUaGlzLlByaXNtIHx8IHdpbmRvdy5QcmlzbTtcblxuLy8gVGhlIGZvbGxvd2luZyBjb2RlIGlzIGV4dHJhY3RlZC9hZGFwdGVkIGZyb20gcHJpc21qcyB2MlxuLy8gSXQgd2lsbCBwcm9iYWJseSBiZSBwb3NzaWJsZSB0byB1c2UgaXQgZGlyZWN0bHkgZnJvbSBwcmlzbSB2MlxuLy8gaW4gdGhlIGZ1dHVyZSB3aGVuIHByaXNtanMgdjIgaXMgcHVibGlzaGVkIGFuZCBMZXhpY2FsIHVwZ3JhZGVzXG4vLyB0aGUgcHJpc21zanMgZGVwZW5kZW5jeVxuXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudCh0b2tlbikge1xuICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0b2tlbjtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRva2VuKSkge1xuICAgIHJldHVybiB0b2tlbi5tYXAoZ2V0VGV4dENvbnRlbnQpLmpvaW4oJycpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRUZXh0Q29udGVudCh0b2tlbi5jb250ZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gdG9rZW5pemVEaWZmSGlnaGxpZ2h0KHRva2VucywgbGFuZ3VhZ2UpIHtcbiAgY29uc3QgZGlmZkxhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gIGNvbnN0IGRpZmZHcmFtbWFyID0gUHJpc20kMS5sYW5ndWFnZXNbZGlmZkxhbmd1YWdlXTtcbiAgY29uc3QgZW52ID0ge1xuICAgIHRva2Vuc1xuICB9O1xuICBjb25zdCBQUkVGSVhFUyA9IFByaXNtJDEubGFuZ3VhZ2VzLmRpZmYuUFJFRklYRVM7XG4gIGZvciAoY29uc3QgdG9rZW4gb2YgZW52LnRva2Vucykge1xuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnIHx8ICEodG9rZW4udHlwZSBpbiBQUkVGSVhFUykgfHwgIUFycmF5LmlzQXJyYXkodG9rZW4uY29udGVudCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdG9rZW4udHlwZTtcbiAgICBsZXQgaW5zZXJ0ZWRQcmVmaXhlcyA9IDA7XG4gICAgY29uc3QgZ2V0UHJlZml4VG9rZW4gPSAoKSA9PiB7XG4gICAgICBpbnNlcnRlZFByZWZpeGVzKys7XG4gICAgICByZXR1cm4gbmV3IFByaXNtJDEuVG9rZW4oJ3ByZWZpeCcsIFBSRUZJWEVTW3R5cGVdLCB0eXBlLnJlcGxhY2UoL14oXFx3KykuKi8sICckMScpKTtcbiAgICB9O1xuICAgIGNvbnN0IHdpdGhvdXRQcmVmaXhlcyA9IHRva2VuLmNvbnRlbnQuZmlsdGVyKHQgPT4gdHlwZW9mIHQgPT09ICdzdHJpbmcnIHx8IHQudHlwZSAhPT0gJ3ByZWZpeCcpO1xuICAgIGNvbnN0IHByZWZpeENvdW50ID0gdG9rZW4uY29udGVudC5sZW5ndGggLSB3aXRob3V0UHJlZml4ZXMubGVuZ3RoO1xuICAgIGNvbnN0IGRpZmZUb2tlbnMgPSBQcmlzbSQxLnRva2VuaXplKGdldFRleHRDb250ZW50KHdpdGhvdXRQcmVmaXhlcyksIGRpZmZHcmFtbWFyKTtcblxuICAgIC8vIHJlLWluc2VydCBwcmVmaXhlc1xuICAgIC8vIGFsd2F5cyBhZGQgYSBwcmVmaXggYXQgdGhlIHN0YXJ0XG4gICAgZGlmZlRva2Vucy51bnNoaWZ0KGdldFByZWZpeFRva2VuKCkpO1xuICAgIGNvbnN0IExJTkVfQlJFQUsgPSAvXFxyXFxufFxcbi9nO1xuICAgIGNvbnN0IGluc2VydEFmdGVyTGluZUJyZWFrU3RyaW5nID0gdGV4dCA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIExJTkVfQlJFQUsubGFzdEluZGV4ID0gMDtcbiAgICAgIGxldCBsYXN0ID0gMDtcbiAgICAgIGxldCBtO1xuICAgICAgd2hpbGUgKGluc2VydGVkUHJlZml4ZXMgPCBwcmVmaXhDb3VudCAmJiAobSA9IExJTkVfQlJFQUsuZXhlYyh0ZXh0KSkpIHtcbiAgICAgICAgY29uc3QgZW5kID0gbS5pbmRleCArIG1bMF0ubGVuZ3RoO1xuICAgICAgICByZXN1bHQucHVzaCh0ZXh0LnNsaWNlKGxhc3QsIGVuZCkpO1xuICAgICAgICBsYXN0ID0gZW5kO1xuICAgICAgICByZXN1bHQucHVzaChnZXRQcmVmaXhUb2tlbigpKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAobGFzdCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRleHQuc2xpY2UobGFzdCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydEFmdGVyTGluZUJyZWFrID0gdG9rcyA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva3MubGVuZ3RoICYmIGluc2VydGVkUHJlZml4ZXMgPCBwcmVmaXhDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRvayA9IHRva3NbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdG9rID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IGluc2VydGVkID0gaW5zZXJ0QWZ0ZXJMaW5lQnJlYWtTdHJpbmcodG9rKTtcbiAgICAgICAgICBpZiAoaW5zZXJ0ZWQpIHtcbiAgICAgICAgICAgIHRva3Muc3BsaWNlKGksIDEsIC4uLmluc2VydGVkKTtcbiAgICAgICAgICAgIGkgKz0gaW5zZXJ0ZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRvay5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IGluc2VydGVkID0gaW5zZXJ0QWZ0ZXJMaW5lQnJlYWtTdHJpbmcodG9rLmNvbnRlbnQpO1xuICAgICAgICAgIGlmIChpbnNlcnRlZCkge1xuICAgICAgICAgICAgdG9rLmNvbnRlbnQgPSBpbnNlcnRlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0b2suY29udGVudCkpIHtcbiAgICAgICAgICBpbnNlcnRBZnRlckxpbmVCcmVhayh0b2suY29udGVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJMaW5lQnJlYWsoW3Rvay5jb250ZW50XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGluc2VydEFmdGVyTGluZUJyZWFrKGRpZmZUb2tlbnMpO1xuICAgIGlmIChpbnNlcnRlZFByZWZpeGVzIDwgcHJlZml4Q291bnQpIHtcbiAgICAgIC8vIHdlIGFyZSBtaXNzaW5nIHRoZSBsYXN0IHByZWZpeFxuICAgICAgZGlmZlRva2Vucy5wdXNoKGdldFByZWZpeFRva2VuKCkpO1xuICAgIH1cbiAgICB0b2tlbi5jb250ZW50ID0gZGlmZlRva2VucztcbiAgfVxuICByZXR1cm4gZW52LnRva2Vucztcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBpc0xhbmd1YWdlU3VwcG9ydGVkQnlQcmlzbSA9IGxhbmd1YWdlID0+IHtcbiAgY29uc3QgRElGRl9MQU5HVUFHRV9SRUdFWCA9IC9eZGlmZi0oW1xcdy1dKykvaTtcbiAgdHJ5IHtcbiAgICBpZiAoIWxhbmd1YWdlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGxhbmdNYXRjaCA9IERJRkZfTEFOR1VBR0VfUkVHRVguZXhlYyhsYW5ndWFnZSk7XG4gICAgaWYgKGxhbmdNYXRjaCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICBQcmlzbSQxLmxhbmd1YWdlcy5oYXNPd25Qcm9wZXJ0eSgnZGlmZicpICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgUHJpc20kMS5sYW5ndWFnZXMuaGFzT3duUHJvcGVydHkobGFuZ01hdGNoWzFdKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgcmV0dXJuIFByaXNtJDEubGFuZ3VhZ2VzLmhhc093blByb3BlcnR5KGxhbmd1YWdlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5mdW5jdGlvbiBoYXNDaGlsZERPTU5vZGVUYWcobm9kZSwgdGFnTmFtZSkge1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2Rlcykge1xuICAgIGlmIChpc0hUTUxFbGVtZW50KGNoaWxkKSAmJiBjaGlsZC50YWdOYW1lID09PSB0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaGFzQ2hpbGRET01Ob2RlVGFnKGNoaWxkLCB0YWdOYW1lKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBMQU5HVUFHRV9EQVRBX0FUVFJJQlVURSA9ICdkYXRhLWxhbmd1YWdlJztcbmNvbnN0IEhJR0hMSUdIVF9MQU5HVUFHRV9EQVRBX0FUVFJJQlVURSA9ICdkYXRhLWhpZ2hsaWdodC1sYW5ndWFnZSc7XG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBDb2RlTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2NvZGUnO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBDb2RlTm9kZShub2RlLl9fbGFuZ3VhZ2UsIG5vZGUuX19rZXkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGxhbmd1YWdlLCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX19sYW5ndWFnZSA9IGxhbmd1YWdlIHx8IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9faXNTeW50YXhIaWdobGlnaHRTdXBwb3J0ZWQgPSBpc0xhbmd1YWdlU3VwcG9ydGVkQnlQcmlzbShsYW5ndWFnZSk7XG4gIH1cblxuICAvLyBWaWV3XG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29kZScpO1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLmNvZGUpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgJ2ZhbHNlJyk7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSB0aGlzLmdldExhbmd1YWdlKCk7XG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShMQU5HVUFHRV9EQVRBX0FUVFJJQlVURSwgbGFuZ3VhZ2UpO1xuICAgICAgaWYgKHRoaXMuZ2V0SXNTeW50YXhIaWdobGlnaHRTdXBwb3J0ZWQoKSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShISUdITElHSFRfTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUsIGxhbmd1YWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZykge1xuICAgIGNvbnN0IGxhbmd1YWdlID0gdGhpcy5fX2xhbmd1YWdlO1xuICAgIGNvbnN0IHByZXZMYW5ndWFnZSA9IHByZXZOb2RlLl9fbGFuZ3VhZ2U7XG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICBpZiAobGFuZ3VhZ2UgIT09IHByZXZMYW5ndWFnZSkge1xuICAgICAgICBkb20uc2V0QXR0cmlidXRlKExBTkdVQUdFX0RBVEFfQVRUUklCVVRFLCBsYW5ndWFnZSk7XG4gICAgICAgIGlmICh0aGlzLl9faXNTeW50YXhIaWdobGlnaHRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKEhJR0hMSUdIVF9MQU5HVUFHRV9EQVRBX0FUVFJJQlVURSwgbGFuZ3VhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcmV2TGFuZ3VhZ2UpIHtcbiAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUpO1xuICAgICAgaWYgKHByZXZOb2RlLl9faXNTeW50YXhIaWdobGlnaHRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShISUdITElHSFRfTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwcmUnKTtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGVkaXRvci5fY29uZmlnLnRoZW1lLmNvZGUpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgJ2ZhbHNlJyk7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSB0aGlzLmdldExhbmd1YWdlKCk7XG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShMQU5HVUFHRV9EQVRBX0FUVFJJQlVURSwgbGFuZ3VhZ2UpO1xuICAgICAgaWYgKHRoaXMuZ2V0SXNTeW50YXhIaWdobGlnaHRTdXBwb3J0ZWQoKSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShISUdITElHSFRfTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUsIGxhbmd1YWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFR5cGljYWxseSA8cHJlPiBpcyB1c2VkIGZvciBjb2RlIGJsb2NrcywgYW5kIDxjb2RlPiBmb3IgaW5saW5lIGNvZGUgc3R5bGVzXG4gICAgICAvLyBidXQgaWYgaXQncyBhIG11bHRpIGxpbmUgPGNvZGU+IHdlJ2xsIGNyZWF0ZSBhIGJsb2NrLiBQYXNzIHRocm91Z2ggdG9cbiAgICAgIC8vIGlubGluZSBmb3JtYXQgaGFuZGxlZCBieSBUZXh0Tm9kZSBvdGhlcndpc2UuXG4gICAgICBjb2RlOiBub2RlID0+IHtcbiAgICAgICAgY29uc3QgaXNNdWx0aUxpbmUgPSBub2RlLnRleHRDb250ZW50ICE9IG51bGwgJiYgKC9cXHI/XFxuLy50ZXN0KG5vZGUudGV4dENvbnRlbnQpIHx8IGhhc0NoaWxkRE9NTm9kZVRhZyhub2RlLCAnQlInKSk7XG4gICAgICAgIHJldHVybiBpc011bHRpTGluZSA/IHtcbiAgICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFByZUVsZW1lbnQsXG4gICAgICAgICAgcHJpb3JpdHk6IDFcbiAgICAgICAgfSA6IG51bGw7XG4gICAgICB9LFxuICAgICAgZGl2OiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydERpdkVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAxXG4gICAgICB9KSxcbiAgICAgIHByZTogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRQcmVFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICB0YWJsZTogbm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IHRhYmxlID0gbm9kZTtcbiAgICAgICAgLy8gZG9tTm9kZSBpcyBhIDx0YWJsZT4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICAgICAgICBpZiAoaXNHaXRIdWJDb2RlVGFibGUodGFibGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0VGFibGVFbGVtZW50LFxuICAgICAgICAgICAgcHJpb3JpdHk6IDNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHRkOiBub2RlID0+IHtcbiAgICAgICAgLy8gZWxlbWVudCBpcyBhIDx0ZD4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICAgICAgICBjb25zdCB0ZCA9IG5vZGU7XG4gICAgICAgIGNvbnN0IHRhYmxlID0gdGQuY2xvc2VzdCgndGFibGUnKTtcbiAgICAgICAgaWYgKGlzR2l0SHViQ29kZUNlbGwodGQpIHx8IHRhYmxlICYmIGlzR2l0SHViQ29kZVRhYmxlKHRhYmxlKSkge1xuICAgICAgICAgIC8vIFJldHVybiBhIG5vLW9wIGlmIGl0J3MgYSB0YWJsZSBjZWxsIGluIGEgY29kZSB0YWJsZSwgYnV0IG5vdCBhIGNvZGUgbGluZS5cbiAgICAgICAgICAvLyBPdGhlcndpc2UgaXQnbGwgZmFsbCBiYWNrIHRvIHRoZSBUXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRDb2RlTm9vcCxcbiAgICAgICAgICAgIHByaW9yaXR5OiAzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICB0cjogbm9kZSA9PiB7XG4gICAgICAgIC8vIGVsZW1lbnQgaXMgYSA8dHI+IHNpbmNlIHdlIG1hdGNoZWQgaXQgYnkgbm9kZU5hbWVcbiAgICAgICAgY29uc3QgdHIgPSBub2RlO1xuICAgICAgICBjb25zdCB0YWJsZSA9IHRyLmNsb3Nlc3QoJ3RhYmxlJyk7XG4gICAgICAgIGlmICh0YWJsZSAmJiBpc0dpdEh1YkNvZGVUYWJsZSh0YWJsZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udmVyc2lvbjogY29udmVydENvZGVOb29wLFxuICAgICAgICAgICAgcHJpb3JpdHk6IDNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUNvZGVOb2RlKCkudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRMYW5ndWFnZShzZXJpYWxpemVkTm9kZS5sYW5ndWFnZSk7XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgbGFuZ3VhZ2U6IHRoaXMuZ2V0TGFuZ3VhZ2UoKVxuICAgIH07XG4gIH1cblxuICAvLyBNdXRhdGlvblxuICBpbnNlcnROZXdBZnRlcihzZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgaWYgKGNoaWxkcmVuTGVuZ3RoID49IDIgJiYgY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAxXS5nZXRUZXh0Q29udGVudCgpID09PSAnXFxuJyAmJiBjaGlsZHJlbltjaGlsZHJlbkxlbmd0aCAtIDJdLmdldFRleHRDb250ZW50KCkgPT09ICdcXG4nICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIHNlbGVjdGlvbi5hbmNob3Iua2V5ID09PSB0aGlzLl9fa2V5ICYmIHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ID09PSBjaGlsZHJlbkxlbmd0aCkge1xuICAgICAgY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAxXS5yZW1vdmUoKTtcbiAgICAgIGNoaWxkcmVuW2NoaWxkcmVuTGVuZ3RoIC0gMl0ucmVtb3ZlKCk7XG4gICAgICBjb25zdCBuZXdFbGVtZW50ID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgIHRoaXMuaW5zZXJ0QWZ0ZXIobmV3RWxlbWVudCwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGlzIHdpdGhpbiB0aGUgY29kZWJsb2NrLCBmaW5kIGFsbCBsZWFkaW5nIHRhYnMgYW5kXG4gICAgLy8gc3BhY2VzIG9mIHRoZSBjdXJyZW50IGxpbmUuIENyZWF0ZSBhIG5ldyBsaW5lIHRoYXQgaGFzIGFsbCB0aG9zZVxuICAgIC8vIHRhYnMgYW5kIHNwYWNlcywgc3VjaCB0aGF0IGxlYWRpbmcgaW5kZW50YXRpb24gaXMgcHJlc2VydmVkLlxuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gYW5jaG9yLmlzQmVmb3JlKGZvY3VzKSA/IGFuY2hvciA6IGZvY3VzO1xuICAgIGNvbnN0IGZpcnN0U2VsZWN0aW9uTm9kZSA9IGZpcnN0UG9pbnQuZ2V0Tm9kZSgpO1xuICAgIGlmICgkaXNUZXh0Tm9kZShmaXJzdFNlbGVjdGlvbk5vZGUpKSB7XG4gICAgICBsZXQgbm9kZSA9ICRnZXRGaXJzdENvZGVOb2RlT2ZMaW5lKGZpcnN0U2VsZWN0aW9uTm9kZSk7XG4gICAgICBjb25zdCBpbnNlcnROb2RlcyA9IFtdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKCRpc1RhYk5vZGUobm9kZSkpIHtcbiAgICAgICAgICBpbnNlcnROb2Rlcy5wdXNoKCRjcmVhdGVUYWJOb2RlKCkpO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkpIHtcbiAgICAgICAgICBsZXQgc3BhY2VzID0gMDtcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICAgIGNvbnN0IHRleHRTaXplID0gbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgICAgICB3aGlsZSAoc3BhY2VzIDwgdGV4dFNpemUgJiYgdGV4dFtzcGFjZXNdID09PSAnICcpIHtcbiAgICAgICAgICAgIHNwYWNlcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3BhY2VzICE9PSAwKSB7XG4gICAgICAgICAgICBpbnNlcnROb2Rlcy5wdXNoKCRjcmVhdGVDb2RlSGlnaGxpZ2h0Tm9kZSgnICcucmVwZWF0KHNwYWNlcykpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNwYWNlcyAhPT0gdGV4dFNpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzcGxpdCA9IGZpcnN0U2VsZWN0aW9uTm9kZS5zcGxpdFRleHQoYW5jaG9yLm9mZnNldClbMF07XG4gICAgICBjb25zdCB4ID0gYW5jaG9yLm9mZnNldCA9PT0gMCA/IDAgOiAxO1xuICAgICAgY29uc3QgaW5kZXggPSBzcGxpdC5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgeDtcbiAgICAgIGNvbnN0IGNvZGVOb2RlID0gZmlyc3RTZWxlY3Rpb25Ob2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGNvbnN0IG5vZGVzVG9JbnNlcnQgPSBbJGNyZWF0ZUxpbmVCcmVha05vZGUoKSwgLi4uaW5zZXJ0Tm9kZXNdO1xuICAgICAgY29kZU5vZGUuc3BsaWNlKGluZGV4LCAwLCBub2Rlc1RvSW5zZXJ0KTtcbiAgICAgIGNvbnN0IGxhc3QgPSBpbnNlcnROb2Rlc1tpbnNlcnROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgIGxhc3Quc2VsZWN0KCk7XG4gICAgICB9IGVsc2UgaWYgKGFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAgICAgc3BsaXQuc2VsZWN0UHJldmlvdXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwbGl0LmdldE5leHRTaWJsaW5nKCkuc2VsZWN0TmV4dCgwLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRpc0NvZGVOb2RlKGZpcnN0U2VsZWN0aW9uTm9kZSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGZpcnN0U2VsZWN0aW9uTm9kZS5zcGxpY2Uob2Zmc2V0LCAwLCBbJGNyZWF0ZUxpbmVCcmVha05vZGUoKV0pO1xuICAgICAgZmlyc3RTZWxlY3Rpb25Ob2RlLnNlbGVjdChvZmZzZXQgKyAxLCBvZmZzZXQgKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb2xsYXBzZUF0U3RhcnQoKSB7XG4gICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHBhcmFncmFwaC5hcHBlbmQoY2hpbGQpKTtcbiAgICB0aGlzLnJlcGxhY2UocGFyYWdyYXBoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzZXRMYW5ndWFnZShsYW5ndWFnZSkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fbGFuZ3VhZ2UgPSBsYW5ndWFnZSB8fCB1bmRlZmluZWQ7XG4gICAgd3JpdGFibGUuX19pc1N5bnRheEhpZ2hsaWdodFN1cHBvcnRlZCA9IGlzTGFuZ3VhZ2VTdXBwb3J0ZWRCeVByaXNtKGxhbmd1YWdlKTtcbiAgICByZXR1cm4gd3JpdGFibGU7XG4gIH1cbiAgZ2V0TGFuZ3VhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19sYW5ndWFnZTtcbiAgfVxuICBnZXRJc1N5bnRheEhpZ2hsaWdodFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2lzU3ludGF4SGlnaGxpZ2h0U3VwcG9ydGVkO1xuICB9XG59XG5mdW5jdGlvbiAkY3JlYXRlQ29kZU5vZGUobGFuZ3VhZ2UpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgQ29kZU5vZGUobGFuZ3VhZ2UpKTtcbn1cbmZ1bmN0aW9uICRpc0NvZGVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBDb2RlTm9kZTtcbn1cbmZ1bmN0aW9uICRjb252ZXJ0UHJlRWxlbWVudChkb21Ob2RlKSB7XG4gIGNvbnN0IGxhbmd1YWdlID0gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUpO1xuICByZXR1cm4ge1xuICAgIG5vZGU6ICRjcmVhdGVDb2RlTm9kZShsYW5ndWFnZSlcbiAgfTtcbn1cbmZ1bmN0aW9uICRjb252ZXJ0RGl2RWxlbWVudChkb21Ob2RlKSB7XG4gIC8vIGRvbU5vZGUgaXMgYSA8ZGl2PiBzaW5jZSB3ZSBtYXRjaGVkIGl0IGJ5IG5vZGVOYW1lXG4gIGNvbnN0IGRpdiA9IGRvbU5vZGU7XG4gIGNvbnN0IGlzQ29kZSA9IGlzQ29kZUVsZW1lbnQoZGl2KTtcbiAgaWYgKCFpc0NvZGUgJiYgIWlzQ29kZUNoaWxkRWxlbWVudChkaXYpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IG51bGxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbm9kZTogaXNDb2RlID8gJGNyZWF0ZUNvZGVOb2RlKCkgOiBudWxsXG4gIH07XG59XG5mdW5jdGlvbiAkY29udmVydFRhYmxlRWxlbWVudCgpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlQ29kZU5vZGUoKVxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydENvZGVOb29wKCkge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQ29kZUVsZW1lbnQoZGl2KSB7XG4gIHJldHVybiBkaXYuc3R5bGUuZm9udEZhbWlseS5tYXRjaCgnbW9ub3NwYWNlJykgIT09IG51bGw7XG59XG5mdW5jdGlvbiBpc0NvZGVDaGlsZEVsZW1lbnQobm9kZSkge1xuICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKGlzQ29kZUVsZW1lbnQocGFyZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzR2l0SHViQ29kZUNlbGwoY2VsbCkge1xuICByZXR1cm4gY2VsbC5jbGFzc0xpc3QuY29udGFpbnMoJ2pzLWZpbGUtbGluZScpO1xufVxuZnVuY3Rpb24gaXNHaXRIdWJDb2RlVGFibGUodGFibGUpIHtcbiAgcmV0dXJuIHRhYmxlLmNsYXNzTGlzdC5jb250YWlucygnanMtZmlsZS1saW5lLWNvbnRhaW5lcicpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IERFRkFVTFRfQ09ERV9MQU5HVUFHRSA9ICdqYXZhc2NyaXB0JztcbmNvbnN0IENPREVfTEFOR1VBR0VfRlJJRU5ETFlfTkFNRV9NQVAgPSB7XG4gIGM6ICdDJyxcbiAgY2xpa2U6ICdDLWxpa2UnLFxuICBjcHA6ICdDKysnLFxuICBjc3M6ICdDU1MnLFxuICBodG1sOiAnSFRNTCcsXG4gIGphdmE6ICdKYXZhJyxcbiAganM6ICdKYXZhU2NyaXB0JyxcbiAgbWFya2Rvd246ICdNYXJrZG93bicsXG4gIG9iamM6ICdPYmplY3RpdmUtQycsXG4gIHBsYWluOiAnUGxhaW4gVGV4dCcsXG4gIHBvd2Vyc2hlbGw6ICdQb3dlclNoZWxsJyxcbiAgcHk6ICdQeXRob24nLFxuICBydXN0OiAnUnVzdCcsXG4gIHNxbDogJ1NRTCcsXG4gIHN3aWZ0OiAnU3dpZnQnLFxuICB0eXBlc2NyaXB0OiAnVHlwZVNjcmlwdCcsXG4gIHhtbDogJ1hNTCdcbn07XG5jb25zdCBDT0RFX0xBTkdVQUdFX01BUCA9IHtcbiAgY3BwOiAnY3BwJyxcbiAgamF2YTogJ2phdmEnLFxuICBqYXZhc2NyaXB0OiAnanMnLFxuICBtZDogJ21hcmtkb3duJyxcbiAgcGxhaW50ZXh0OiAncGxhaW4nLFxuICBweXRob246ICdweScsXG4gIHRleHQ6ICdwbGFpbicsXG4gIHRzOiAndHlwZXNjcmlwdCdcbn07XG5mdW5jdGlvbiBub3JtYWxpemVDb2RlTGFuZyhsYW5nKSB7XG4gIHJldHVybiBDT0RFX0xBTkdVQUdFX01BUFtsYW5nXSB8fCBsYW5nO1xufVxuZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VGcmllbmRseU5hbWUobGFuZykge1xuICBjb25zdCBfbGFuZyA9IG5vcm1hbGl6ZUNvZGVMYW5nKGxhbmcpO1xuICByZXR1cm4gQ09ERV9MQU5HVUFHRV9GUklFTkRMWV9OQU1FX01BUFtfbGFuZ10gfHwgX2xhbmc7XG59XG5jb25zdCBnZXREZWZhdWx0Q29kZUxhbmd1YWdlID0gKCkgPT4gREVGQVVMVF9DT0RFX0xBTkdVQUdFO1xuY29uc3QgZ2V0Q29kZUxhbmd1YWdlcyA9ICgpID0+IE9iamVjdC5rZXlzKFByaXNtJDEubGFuZ3VhZ2VzKS5maWx0ZXIoXG4vLyBQcmlzbSBoYXMgc2V2ZXJhbCBsYW5ndWFnZSBoZWxwZXJzIG1peGVkIGludG8gbGFuZ3VhZ2VzIG9iamVjdFxuLy8gc28gZmlsdGVyaW5nIHRoZW0gb3V0IGhlcmUgdG8gZ2V0IGxhbmdzIGxpc3Rcbmxhbmd1YWdlID0+IHR5cGVvZiBQcmlzbSQxLmxhbmd1YWdlc1tsYW5ndWFnZV0gIT09ICdmdW5jdGlvbicpLnNvcnQoKTtcblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIENvZGVIaWdobGlnaHROb2RlIGV4dGVuZHMgVGV4dE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgY29uc3RydWN0b3IodGV4dCA9ICcnLCBoaWdobGlnaHRUeXBlLCBrZXkpIHtcbiAgICBzdXBlcih0ZXh0LCBrZXkpO1xuICAgIHRoaXMuX19oaWdobGlnaHRUeXBlID0gaGlnaGxpZ2h0VHlwZTtcbiAgfVxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2NvZGUtaGlnaGxpZ2h0JztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgQ29kZUhpZ2hsaWdodE5vZGUobm9kZS5fX3RleHQsIG5vZGUuX19oaWdobGlnaHRUeXBlIHx8IHVuZGVmaW5lZCwgbm9kZS5fX2tleSk7XG4gIH1cbiAgZ2V0SGlnaGxpZ2h0VHlwZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX2hpZ2hsaWdodFR5cGU7XG4gIH1cbiAgc2V0SGlnaGxpZ2h0VHlwZShoaWdobGlnaHRUeXBlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9faGlnaGxpZ2h0VHlwZSA9IGhpZ2hsaWdodFR5cGUgfHwgdW5kZWZpbmVkO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGNhbkhhdmVGb3JtYXQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gc3VwZXIuY3JlYXRlRE9NKGNvbmZpZyk7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gZ2V0SGlnaGxpZ2h0VGhlbWVDbGFzcyhjb25maWcudGhlbWUsIHRoaXMuX19oaWdobGlnaHRUeXBlKTtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZykge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHN1cGVyLnVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpO1xuICAgIGNvbnN0IHByZXZDbGFzc05hbWUgPSBnZXRIaWdobGlnaHRUaGVtZUNsYXNzKGNvbmZpZy50aGVtZSwgcHJldk5vZGUuX19oaWdobGlnaHRUeXBlKTtcbiAgICBjb25zdCBuZXh0Q2xhc3NOYW1lID0gZ2V0SGlnaGxpZ2h0VGhlbWVDbGFzcyhjb25maWcudGhlbWUsIHRoaXMuX19oaWdobGlnaHRUeXBlKTtcbiAgICBpZiAocHJldkNsYXNzTmFtZSAhPT0gbmV4dENsYXNzTmFtZSkge1xuICAgICAgaWYgKHByZXZDbGFzc05hbWUpIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGRvbSwgcHJldkNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAobmV4dENsYXNzTmFtZSkge1xuICAgICAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGRvbSwgbmV4dENsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGU7XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUNvZGVIaWdobGlnaHROb2RlKCkudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRIaWdobGlnaHRUeXBlKHNlcmlhbGl6ZWROb2RlLmhpZ2hsaWdodFR5cGUpO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGhpZ2hsaWdodFR5cGU6IHRoaXMuZ2V0SGlnaGxpZ2h0VHlwZSgpXG4gICAgfTtcbiAgfVxuXG4gIC8vIFByZXZlbnQgZm9ybWF0dGluZyAoYm9sZCwgdW5kZXJsaW5lLCBldGMpXG4gIHNldEZvcm1hdChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpc1BhcmVudFJlcXVpcmVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNyZWF0ZVBhcmVudEVsZW1lbnROb2RlKCkge1xuICAgIHJldHVybiAkY3JlYXRlQ29kZU5vZGUoKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SGlnaGxpZ2h0VGhlbWVDbGFzcyh0aGVtZSwgaGlnaGxpZ2h0VHlwZSkge1xuICByZXR1cm4gaGlnaGxpZ2h0VHlwZSAmJiB0aGVtZSAmJiB0aGVtZS5jb2RlSGlnaGxpZ2h0ICYmIHRoZW1lLmNvZGVIaWdobGlnaHRbaGlnaGxpZ2h0VHlwZV07XG59XG5mdW5jdGlvbiAkY3JlYXRlQ29kZUhpZ2hsaWdodE5vZGUodGV4dCA9ICcnLCBoaWdobGlnaHRUeXBlKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IENvZGVIaWdobGlnaHROb2RlKHRleHQsIGhpZ2hsaWdodFR5cGUpKTtcbn1cbmZ1bmN0aW9uICRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBDb2RlSGlnaGxpZ2h0Tm9kZTtcbn1cbmZ1bmN0aW9uICRnZXRMYXN0TWF0Y2hpbmdDb2RlTm9kZShhbmNob3IsIGRpcmVjdGlvbikge1xuICBsZXQgbWF0Y2hpbmdOb2RlID0gYW5jaG9yO1xuICBmb3IgKGxldCBjYXJldCA9ICRnZXRTaWJsaW5nQ2FyZXQoYW5jaG9yLCBkaXJlY3Rpb24pOyBjYXJldCAmJiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUoY2FyZXQub3JpZ2luKSB8fCAkaXNUYWJOb2RlKGNhcmV0Lm9yaWdpbikpOyBjYXJldCA9ICRnZXRBZGphY2VudENhcmV0KGNhcmV0KSkge1xuICAgIG1hdGNoaW5nTm9kZSA9IGNhcmV0Lm9yaWdpbjtcbiAgfVxuICByZXR1cm4gbWF0Y2hpbmdOb2RlO1xufVxuZnVuY3Rpb24gJGdldEZpcnN0Q29kZU5vZGVPZkxpbmUoYW5jaG9yKSB7XG4gIHJldHVybiAkZ2V0TGFzdE1hdGNoaW5nQ29kZU5vZGUoYW5jaG9yLCAncHJldmlvdXMnKTtcbn1cbmZ1bmN0aW9uICRnZXRMYXN0Q29kZU5vZGVPZkxpbmUoYW5jaG9yKSB7XG4gIHJldHVybiAkZ2V0TGFzdE1hdGNoaW5nQ29kZU5vZGUoYW5jaG9yLCAnbmV4dCcpO1xufVxuXG5jb25zdCBQcmlzbVRva2VuaXplciA9IHtcbiAgZGVmYXVsdExhbmd1YWdlOiBERUZBVUxUX0NPREVfTEFOR1VBR0UsXG4gIHRva2VuaXplKGNvZGUsIGxhbmd1YWdlKSB7XG4gICAgcmV0dXJuIFByaXNtJDEudG9rZW5pemUoY29kZSwgUHJpc20kMS5sYW5ndWFnZXNbbGFuZ3VhZ2UgfHwgJyddIHx8IFByaXNtJDEubGFuZ3VhZ2VzW3RoaXMuZGVmYXVsdExhbmd1YWdlXSk7XG4gIH1cbn07XG5mdW5jdGlvbiAkZ2V0U3RhcnRPZkNvZGVJbkxpbmUoYW5jaG9yLCBvZmZzZXQpIHtcbiAgbGV0IGxhc3QgPSBudWxsO1xuICBsZXQgbGFzdE5vbkJsYW5rID0gbnVsbDtcbiAgbGV0IG5vZGUgPSBhbmNob3I7XG4gIGxldCBub2RlT2Zmc2V0ID0gb2Zmc2V0O1xuICBsZXQgbm9kZVRleHRDb250ZW50ID0gYW5jaG9yLmdldFRleHRDb250ZW50KCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZU9mZnNldCA9PT0gMCkge1xuICAgICAgbm9kZSA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICghKCRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpIHx8ICRpc1RhYk5vZGUobm9kZSkgfHwgJGlzTGluZUJyZWFrTm9kZShub2RlKSkpIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBhIHZhbGlkIENvZGUgTm9kZTogQ29kZUhpZ2hsaWdodE5vZGUsIFRhYk5vZGUsIExpbmVCcmVha05vZGVgKTtcbiAgICAgIH1cbiAgICAgIGlmICgkaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICAgIGxhc3QgPSB7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IDFcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlT2Zmc2V0ID0gTWF0aC5tYXgoMCwgbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSAtIDEpO1xuICAgICAgbm9kZVRleHRDb250ZW50ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlT2Zmc2V0LS07XG4gICAgfVxuICAgIGNvbnN0IGNoYXJhY3RlciA9IG5vZGVUZXh0Q29udGVudFtub2RlT2Zmc2V0XTtcbiAgICBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkgJiYgY2hhcmFjdGVyICE9PSAnICcpIHtcbiAgICAgIGxhc3ROb25CbGFuayA9IHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgb2Zmc2V0OiBub2RlT2Zmc2V0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvLyBsYXN0Tm9uQmxhbmsgIT09IG51bGw6IGFuY2hvciBpbiB0aGUgbWlkZGxlIG9mIGNvZGU7IG1vdmUgdG8gbGluZSBiZWdpbm5pbmdcbiAgaWYgKGxhc3ROb25CbGFuayAhPT0gbnVsbCkge1xuICAgIHJldHVybiBsYXN0Tm9uQmxhbms7XG4gIH1cbiAgLy8gU3BhY2VzLCB0YWJzIG9yIG5vdGhpbmcgYWhlYWQgb2YgYW5jaG9yXG4gIGxldCBjb2RlQ2hhcmFjdGVyQXRBbmNob3JPZmZzZXQgPSBudWxsO1xuICBpZiAob2Zmc2V0IDwgYW5jaG9yLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKGFuY2hvcikpIHtcbiAgICAgIGNvZGVDaGFyYWN0ZXJBdEFuY2hvck9mZnNldCA9IGFuY2hvci5nZXRUZXh0Q29udGVudCgpW29mZnNldF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gYW5jaG9yLmdldE5leHRTaWJsaW5nKCk7XG4gICAgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgY29kZUNoYXJhY3RlckF0QW5jaG9yT2Zmc2V0ID0gbmV4dFNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKVswXTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvZGVDaGFyYWN0ZXJBdEFuY2hvck9mZnNldCAhPT0gbnVsbCAmJiBjb2RlQ2hhcmFjdGVyQXRBbmNob3JPZmZzZXQgIT09ICcgJykge1xuICAgIC8vIEJvcmRlcmxpbmUgd2hpdGVzcGFjZSBhbmQgY29kZSwgbW92ZSB0byBsaW5lIGJlZ2lubmluZ1xuICAgIHJldHVybiBsYXN0O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5leHROb25CbGFuayA9IGZpbmROZXh0Tm9uQmxhbmtJbkxpbmUoYW5jaG9yLCBvZmZzZXQpO1xuICAgIGlmIChuZXh0Tm9uQmxhbmsgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXh0Tm9uQmxhbms7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsYXN0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmluZE5leHROb25CbGFua0luTGluZShhbmNob3IsIG9mZnNldCkge1xuICBsZXQgbm9kZSA9IGFuY2hvcjtcbiAgbGV0IG5vZGVPZmZzZXQgPSBvZmZzZXQ7XG4gIGxldCBub2RlVGV4dENvbnRlbnQgPSBhbmNob3IuZ2V0VGV4dENvbnRlbnQoKTtcbiAgbGV0IG5vZGVUZXh0Q29udGVudFNpemUgPSBhbmNob3IuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoISRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpIHx8IG5vZGVPZmZzZXQgPT09IG5vZGVUZXh0Q29udGVudFNpemUpIHtcbiAgICAgIG5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBpZiAobm9kZSA9PT0gbnVsbCB8fCAkaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpKSB7XG4gICAgICAgIG5vZGVPZmZzZXQgPSAwO1xuICAgICAgICBub2RlVGV4dENvbnRlbnQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgIG5vZGVUZXh0Q29udGVudFNpemUgPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkpIHtcbiAgICAgIGlmIChub2RlVGV4dENvbnRlbnRbbm9kZU9mZnNldF0gIT09ICcgJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBub2RlT2Zmc2V0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBub2RlT2Zmc2V0Kys7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkZ2V0RW5kT2ZDb2RlSW5MaW5lKGFuY2hvcikge1xuICBjb25zdCBsYXN0Tm9kZSA9ICRnZXRMYXN0Q29kZU5vZGVPZkxpbmUoYW5jaG9yKTtcbiAgaWYgKCEhJGlzTGluZUJyZWFrTm9kZShsYXN0Tm9kZSkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFVuZXhwZWN0ZWQgbGluZUJyZWFrTm9kZSBpbiBnZXRFbmRPZkNvZGVJbkxpbmVgKTtcbiAgfVxuICByZXR1cm4gbGFzdE5vZGU7XG59XG5mdW5jdGlvbiAkdGV4dE5vZGVUcmFuc2Zvcm0obm9kZSwgZWRpdG9yLCB0b2tlbml6ZXIpIHtcbiAgLy8gU2luY2UgQ29kZU5vZGUgaGFzIGZsYXQgY2hpbGRyZW4gc3RydWN0dXJlIHdlIG9ubHkgbmVlZCB0byBjaGVja1xuICAvLyBpZiBub2RlJ3MgcGFyZW50IGlzIGEgY29kZSBub2RlIGFuZCBydW4gaGlnaGxpZ2h0aW5nIGlmIHNvXG4gIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICBpZiAoJGlzQ29kZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICBjb2RlTm9kZVRyYW5zZm9ybShwYXJlbnROb2RlLCBlZGl0b3IsIHRva2VuaXplcik7XG4gIH0gZWxzZSBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkpIHtcbiAgICAvLyBXaGVuIGNvZGUgYmxvY2sgY29udmVydGVkIGludG8gcGFyYWdyYXBoIG9yIG90aGVyIGVsZW1lbnRcbiAgICAvLyBjb2RlIGhpZ2hsaWdodCBub2RlcyBjb252ZXJ0ZWQgYmFjayB0byBub3JtYWwgdGV4dFxuICAgIG5vZGUucmVwbGFjZSgkY3JlYXRlVGV4dE5vZGUobm9kZS5fX3RleHQpKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQ29kZUd1dHRlcihub2RlLCBlZGl0b3IpIHtcbiAgY29uc3QgY29kZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KG5vZGUuZ2V0S2V5KCkpO1xuICBpZiAoY29kZUVsZW1lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAvLyBAdHMtaWdub3JlOiBpbnRlcm5hbCBmaWVsZFxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IGNvZGVFbGVtZW50Ll9fY2FjaGVkQ2hpbGRyZW5MZW5ndGgpIHtcbiAgICAvLyBBdm9pZCB1cGRhdGluZyB0aGUgYXR0cmlidXRlIGlmIHRoZSBjaGlsZHJlbiBsZW5ndGggaGFzbid0IGNoYW5nZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEB0cy1pZ25vcmU6OiBpbnRlcm5hbCBmaWVsZFxuICBjb2RlRWxlbWVudC5fX2NhY2hlZENoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW5MZW5ndGg7XG4gIGxldCBndXR0ZXIgPSAnMSc7XG4gIGxldCBjb3VudCA9IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgIGlmICgkaXNMaW5lQnJlYWtOb2RlKGNoaWxkcmVuW2ldKSkge1xuICAgICAgZ3V0dGVyICs9ICdcXG4nICsgKytjb3VudDtcbiAgICB9XG4gIH1cbiAgY29kZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWd1dHRlcicsIGd1dHRlcik7XG59XG5cbi8vIFVzaW5nIGBza2lwVHJhbnNmb3Jtc2AgdG8gcHJldmVudCBleHRyYSB0cmFuc2Zvcm1zIHNpbmNlIHJlZm9ybWF0dGluZyB0aGUgY29kZVxuLy8gd2lsbCBub3QgYWZmZWN0IGNvZGUgYmxvY2sgY29udGVudCBpdHNlbGYuXG4vL1xuLy8gVXNpbmcgZXh0cmEgY2FjaGUgKGBub2Rlc0N1cnJlbnRseUhpZ2hsaWdodGluZ2ApIHNpbmNlIGJvdGggQ29kZU5vZGUgYW5kIENvZGVIaWdobGlnaHROb2RlXG4vLyB0cmFuc2Zvcm1zIG1pZ2h0IGJlIGNhbGxlZCBhdCB0aGUgc2FtZSB0aW1lIChlLmcuIG5ldyBDb2RlSGlnaGxpZ2h0IG5vZGUgaW5zZXJ0ZWQpIGFuZFxuLy8gaW4gYm90aCBjYXNlcyB3ZSdsbCByZXJ1biB3aG9sZSByZWZvcm1hdHRpbmcgb3ZlciBDb2RlTm9kZSwgd2hpY2ggaXMgcmVkdW5kYW50LlxuLy8gRXNwZWNpYWxseSB3aGVuIHBhc3RpbmcgY29kZSBpbnRvIENvZGVCbG9jay5cblxuY29uc3Qgbm9kZXNDdXJyZW50bHlIaWdobGlnaHRpbmcgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBjb2RlTm9kZVRyYW5zZm9ybShub2RlLCBlZGl0b3IsIHRva2VuaXplcikge1xuICBjb25zdCBub2RlS2V5ID0gbm9kZS5nZXRLZXkoKTtcbiAgaWYgKG5vZGVzQ3VycmVudGx5SGlnaGxpZ2h0aW5nLmhhcyhub2RlS2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBub2Rlc0N1cnJlbnRseUhpZ2hsaWdodGluZy5hZGQobm9kZUtleSk7XG5cbiAgLy8gV2hlbiBuZXcgY29kZSBibG9jayBpbnNlcnRlZCBpdCBtaWdodCBub3QgaGF2ZSBsYW5ndWFnZSBzZWxlY3RlZFxuICBpZiAobm9kZS5nZXRMYW5ndWFnZSgpID09PSB1bmRlZmluZWQpIHtcbiAgICBub2RlLnNldExhbmd1YWdlKHRva2VuaXplci5kZWZhdWx0TGFuZ3VhZ2UpO1xuICB9XG5cbiAgLy8gVXNpbmcgbmVzdGVkIHVwZGF0ZSBjYWxsIHRvIHBhc3MgYHNraXBUcmFuc2Zvcm1zYCBzaW5jZSB3ZSBkb24ndCB3YW50XG4gIC8vIGVhY2ggaW5kaXZpZHVhbCBDb2RlSGlnaGxpZ2h0Tm9kZSB0byBiZSB0cmFuc2Zvcm1lZCBhZ2FpbiBhcyBpdCdzIGFscmVhZHlcbiAgLy8gaW4gaXRzIGZpbmFsIHN0YXRlXG4gIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICR1cGRhdGVBbmRSZXRhaW5TZWxlY3Rpb24obm9kZUtleSwgKCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudE5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KG5vZGVLZXkpO1xuICAgICAgaWYgKCEkaXNDb2RlTm9kZShjdXJyZW50Tm9kZSkgfHwgIWN1cnJlbnROb2RlLmlzQXR0YWNoZWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBESUZGX0xBTkdVQUdFX1JFR0VYID0gL15kaWZmLShbXFx3LV0rKS9pO1xuICAgICAgY29uc3QgY3VycmVudExhbmd1YWdlID0gY3VycmVudE5vZGUuZ2V0TGFuZ3VhZ2UoKSB8fCB0b2tlbml6ZXIuZGVmYXVsdExhbmd1YWdlO1xuICAgICAgY29uc3QgZGlmZkxhbmd1YWdlTWF0Y2ggPSBESUZGX0xBTkdVQUdFX1JFR0VYLmV4ZWMoY3VycmVudExhbmd1YWdlKTtcbiAgICAgIGNvbnN0IGNvZGUgPSBjdXJyZW50Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgbGV0IHRva2VucyA9IHRva2VuaXplci50b2tlbml6ZShjb2RlLCBkaWZmTGFuZ3VhZ2VNYXRjaCA/ICdkaWZmJyA6IGN1cnJlbnRMYW5ndWFnZSk7XG4gICAgICBpZiAoZGlmZkxhbmd1YWdlTWF0Y2gpIHtcbiAgICAgICAgdG9rZW5zID0gdG9rZW5pemVEaWZmSGlnaGxpZ2h0KHRva2VucywgZGlmZkxhbmd1YWdlTWF0Y2hbMV0pO1xuICAgICAgfVxuICAgICAgY29uc3QgaGlnaGxpZ2h0Tm9kZXMgPSAkZ2V0SGlnaGxpZ2h0Tm9kZXModG9rZW5zKTtcbiAgICAgIGNvbnN0IGRpZmZSYW5nZSA9IGdldERpZmZSYW5nZShjdXJyZW50Tm9kZS5nZXRDaGlsZHJlbigpLCBoaWdobGlnaHROb2Rlcyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgICAgICBub2Rlc0ZvclJlcGxhY2VtZW50XG4gICAgICB9ID0gZGlmZlJhbmdlO1xuICAgICAgaWYgKGZyb20gIT09IHRvIHx8IG5vZGVzRm9yUmVwbGFjZW1lbnQubGVuZ3RoKSB7XG4gICAgICAgIG5vZGUuc3BsaWNlKGZyb20sIHRvIC0gZnJvbSwgbm9kZXNGb3JSZXBsYWNlbWVudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICB9LCB7XG4gICAgb25VcGRhdGU6ICgpID0+IHtcbiAgICAgIG5vZGVzQ3VycmVudGx5SGlnaGxpZ2h0aW5nLmRlbGV0ZShub2RlS2V5KTtcbiAgICB9LFxuICAgIHNraXBUcmFuc2Zvcm1zOiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gJGdldEhpZ2hsaWdodE5vZGVzKHRva2VucywgdHlwZSkge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBwYXJ0aWFscyA9IHRva2VuLnNwbGl0KC8oXFxufFxcdCkvKTtcbiAgICAgIGNvbnN0IHBhcnRpYWxzTGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0aWFsc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0aWFsc1tpXTtcbiAgICAgICAgaWYgKHBhcnQgPT09ICdcXG4nIHx8IHBhcnQgPT09ICdcXHJcXG4nKSB7XG4gICAgICAgICAgbm9kZXMucHVzaCgkY3JlYXRlTGluZUJyZWFrTm9kZSgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnXFx0Jykge1xuICAgICAgICAgIG5vZGVzLnB1c2goJGNyZWF0ZVRhYk5vZGUoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbm9kZXMucHVzaCgkY3JlYXRlQ29kZUhpZ2hsaWdodE5vZGUocGFydCwgdHlwZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgYWxpYXNcbiAgICAgIH0gPSB0b2tlbjtcbiAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbm9kZXMucHVzaCguLi4kZ2V0SGlnaGxpZ2h0Tm9kZXMoW2NvbnRlbnRdLCB0b2tlbi50eXBlID09PSAncHJlZml4JyAmJiB0eXBlb2YgYWxpYXMgPT09ICdzdHJpbmcnID8gYWxpYXMgOiB0b2tlbi50eXBlKSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkpIHtcbiAgICAgICAgbm9kZXMucHVzaCguLi4kZ2V0SGlnaGxpZ2h0Tm9kZXMoY29udGVudCwgdG9rZW4udHlwZSA9PT0gJ3VuY2hhbmdlZCcgPyB1bmRlZmluZWQgOiB0b2tlbi50eXBlKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBub2Rlcztcbn1cblxuLy8gV3JhcHBpbmcgdXBkYXRlIGZ1bmN0aW9uIGludG8gc2VsZWN0aW9uIHJldGFpbmVyLCB0aGF0IHRyaWVzIHRvIGtlZXAgY3Vyc29yIGF0IHRoZSBzYW1lXG4vLyBwb3NpdGlvbiBhcyBiZWZvcmUuXG5mdW5jdGlvbiAkdXBkYXRlQW5kUmV0YWluU2VsZWN0aW9uKG5vZGVLZXksIHVwZGF0ZUZuKSB7XG4gIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KG5vZGVLZXkpO1xuICBpZiAoISRpc0NvZGVOb2RlKG5vZGUpIHx8ICFub2RlLmlzQXR0YWNoZWQoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIC8vIElmIGl0J3Mgbm90IHJhbmdlIHNlbGVjdGlvbiAob3IgbnVsbCBzZWxlY3Rpb24pIHRoZXJlJ3Mgbm8gbmVlZCB0byBjaGFuZ2UgaXQsXG4gIC8vIGJ1dCB3ZSBjYW4gc3RpbGwgcnVuIGhpZ2hsaWdodGluZyBsb2dpY1xuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICB1cGRhdGVGbigpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBpc05ld0xpbmVBbmNob3IgPSBhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmICRpc0xpbmVCcmVha05vZGUobm9kZS5nZXRDaGlsZEF0SW5kZXgoYW5jaG9yLm9mZnNldCAtIDEpKTtcbiAgbGV0IHRleHRPZmZzZXQgPSAwO1xuXG4gIC8vIENhbGN1bGF0aW5nIHByZXZpb3VzIHRleHQgb2Zmc2V0IChhbGwgdGV4dCBub2RlIHByaW9yIHRvIGFuY2hvciArIGFuY2hvciBvd24gdGV4dCBvZmZzZXQpXG4gIGlmICghaXNOZXdMaW5lQW5jaG9yKSB7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgdGV4dE9mZnNldCA9IGFuY2hvck9mZnNldCArIGFuY2hvck5vZGUuZ2V0UHJldmlvdXNTaWJsaW5ncygpLnJlZHVjZSgob2Zmc2V0LCBfbm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIG9mZnNldCArIF9ub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgIH0sIDApO1xuICB9XG4gIGNvbnN0IGhhc0NoYW5nZXMgPSB1cGRhdGVGbigpO1xuICBpZiAoIWhhc0NoYW5nZXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBOb24tdGV4dCBhbmNob3JzIG9ubHkgaGFwcGVuIGZvciBsaW5lIGJyZWFrcywgb3RoZXJ3aXNlXG4gIC8vIHNlbGVjdGlvbiB3aWxsIGJlIHdpdGhpbiB0ZXh0IG5vZGUgKGNvZGUgaGlnaGxpZ2h0IG5vZGUpXG4gIGlmIChpc05ld0xpbmVBbmNob3IpIHtcbiAgICBhbmNob3IuZ2V0Tm9kZSgpLnNlbGVjdChhbmNob3JPZmZzZXQsIGFuY2hvck9mZnNldCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgaXQgd2FzIG5vbi1lbGVtZW50IGFuY2hvciB0aGVuIHdlIHdhbGsgdGhyb3VnaCBjaGlsZCBub2Rlc1xuICAvLyBhbmQgbG9va2luZyBmb3IgYSBwb3NpdGlvbiBvZiBvcmlnaW5hbCB0ZXh0IG9mZnNldFxuICBub2RlLmdldENoaWxkcmVuKCkuc29tZShfbm9kZSA9PiB7XG4gICAgY29uc3QgaXNUZXh0ID0gJGlzVGV4dE5vZGUoX25vZGUpO1xuICAgIGlmIChpc1RleHQgfHwgJGlzTGluZUJyZWFrTm9kZShfbm9kZSkpIHtcbiAgICAgIGNvbnN0IHRleHRDb250ZW50U2l6ZSA9IF9ub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgaWYgKGlzVGV4dCAmJiB0ZXh0Q29udGVudFNpemUgPj0gdGV4dE9mZnNldCkge1xuICAgICAgICBfbm9kZS5zZWxlY3QodGV4dE9mZnNldCwgdGV4dE9mZnNldCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdGV4dE9mZnNldCAtPSB0ZXh0Q29udGVudFNpemU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59XG5cbi8vIEZpbmRzIG1pbmltYWwgZGlmZiByYW5nZSBiZXR3ZWVuIHR3byBub2RlcyBsaXN0cy4gSXQgcmV0dXJucyBmcm9tL3RvIHJhbmdlIGJvdW5kYXJpZXMgb2YgcHJldk5vZGVzXG4vLyB0aGF0IG5lZWRzIHRvIGJlIHJlcGxhY2VkIHdpdGggYG5vZGVzYCAoc3Vic2V0IG9mIG5leHROb2RlcykgdG8gbWFrZSBwcmV2Tm9kZXMgZXF1YWwgdG8gbmV4dE5vZGVzLlxuZnVuY3Rpb24gZ2V0RGlmZlJhbmdlKHByZXZOb2RlcywgbmV4dE5vZGVzKSB7XG4gIGxldCBsZWFkaW5nTWF0Y2ggPSAwO1xuICB3aGlsZSAobGVhZGluZ01hdGNoIDwgcHJldk5vZGVzLmxlbmd0aCkge1xuICAgIGlmICghaXNFcXVhbChwcmV2Tm9kZXNbbGVhZGluZ01hdGNoXSwgbmV4dE5vZGVzW2xlYWRpbmdNYXRjaF0pKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGVhZGluZ01hdGNoKys7XG4gIH1cbiAgY29uc3QgcHJldk5vZGVzTGVuZ3RoID0gcHJldk5vZGVzLmxlbmd0aDtcbiAgY29uc3QgbmV4dE5vZGVzTGVuZ3RoID0gbmV4dE5vZGVzLmxlbmd0aDtcbiAgY29uc3QgbWF4VHJhaWxpbmdNYXRjaCA9IE1hdGgubWluKHByZXZOb2Rlc0xlbmd0aCwgbmV4dE5vZGVzTGVuZ3RoKSAtIGxlYWRpbmdNYXRjaDtcbiAgbGV0IHRyYWlsaW5nTWF0Y2ggPSAwO1xuICB3aGlsZSAodHJhaWxpbmdNYXRjaCA8IG1heFRyYWlsaW5nTWF0Y2gpIHtcbiAgICB0cmFpbGluZ01hdGNoKys7XG4gICAgaWYgKCFpc0VxdWFsKHByZXZOb2Rlc1twcmV2Tm9kZXNMZW5ndGggLSB0cmFpbGluZ01hdGNoXSwgbmV4dE5vZGVzW25leHROb2Rlc0xlbmd0aCAtIHRyYWlsaW5nTWF0Y2hdKSkge1xuICAgICAgdHJhaWxpbmdNYXRjaC0tO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZyb20gPSBsZWFkaW5nTWF0Y2g7XG4gIGNvbnN0IHRvID0gcHJldk5vZGVzTGVuZ3RoIC0gdHJhaWxpbmdNYXRjaDtcbiAgY29uc3Qgbm9kZXNGb3JSZXBsYWNlbWVudCA9IG5leHROb2Rlcy5zbGljZShsZWFkaW5nTWF0Y2gsIG5leHROb2Rlc0xlbmd0aCAtIHRyYWlsaW5nTWF0Y2gpO1xuICByZXR1cm4ge1xuICAgIGZyb20sXG4gICAgbm9kZXNGb3JSZXBsYWNlbWVudCxcbiAgICB0b1xuICB9O1xufVxuZnVuY3Rpb24gaXNFcXVhbChub2RlQSwgbm9kZUIpIHtcbiAgLy8gT25seSBjaGVja2luZyBmb3IgY29kZSBoaWdobGlnaHQgbm9kZXMsIHRhYnMgYW5kIGxpbmVicmVha3MuIElmIGl0J3MgcmVndWxhciB0ZXh0IG5vZGVcbiAgLy8gcmV0dXJuaW5nIGZhbHNlIHNvIHRoYXQgaXQncyB0cmFuc2Zvcm1lZCBpbnRvIGNvZGUgaGlnaGxpZ2h0IG5vZGVcbiAgcmV0dXJuICRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGVBKSAmJiAkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlQikgJiYgbm9kZUEuX190ZXh0ID09PSBub2RlQi5fX3RleHQgJiYgbm9kZUEuX19oaWdobGlnaHRUeXBlID09PSBub2RlQi5fX2hpZ2hsaWdodFR5cGUgfHwgJGlzVGFiTm9kZShub2RlQSkgJiYgJGlzVGFiTm9kZShub2RlQikgfHwgJGlzTGluZUJyZWFrTm9kZShub2RlQSkgJiYgJGlzTGluZUJyZWFrTm9kZShub2RlQik7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGJvb2xlYW4uXG4gKiBDaGVjayB0aGF0IHRoZSBzZWxlY3Rpb24gc3BhbiBpcyB3aXRoaW4gYSBzaW5nbGUgQ29kZU5vZGUuXG4gKiBUaGlzIGlzIHVzZWQgdG8gZ3VhcmQgYWdhaW5zdCBleGVjdXRpbmcgaGFuZGxlcnMgdGhhdCBjYW4gb25seSBiZVxuICogYXBwbGllZCBpbiBhIHNpbmdsZSBDb2RlTm9kZSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uICRpc1NlbGVjdGlvbkluQ29kZShzZWxlY3Rpb24pIHtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgbWF5YmVBbmNob3JDb2RlTm9kZSA9ICRpc0NvZGVOb2RlKGFuY2hvck5vZGUpID8gYW5jaG9yTm9kZSA6IGFuY2hvck5vZGUuZ2V0UGFyZW50KCk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gIGNvbnN0IG1heWJlRm9jdXNDb2RlTm9kZSA9ICRpc0NvZGVOb2RlKGZvY3VzTm9kZSkgPyBmb2N1c05vZGUgOiBmb2N1c05vZGUuZ2V0UGFyZW50KCk7XG4gIHJldHVybiAkaXNDb2RlTm9kZShtYXliZUFuY2hvckNvZGVOb2RlKSAmJiBtYXliZUFuY2hvckNvZGVOb2RlLmlzKG1heWJlRm9jdXNDb2RlTm9kZSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBBcnJheSBvZiBjb2RlIGxpbmVzXG4gKiBUYWtlIHRoZSBzZXF1ZW5jZSBvZiBMaW5lQnJlYWtOb2RlIHwgVGFiTm9kZSB8IENvZGVIaWdobGlnaHROb2RlIGZvcm1pbmdcbiAqIHRoZSBzZWxlY3Rpb24gYW5kIHNwbGl0IGl0IGJ5IExpbmVCcmVha05vZGUuXG4gKiBJZiB0aGUgc2VsZWN0aW9uIGVuZHMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsYXN0IGxpbmUsIGl0IGlzIGNvbnNpZGVyZWQgZW1wdHkuXG4gKiBFbXB0eSBsaW5lcyBhcmUgZGlzY2FyZGVkLlxuICovXG5mdW5jdGlvbiAkZ2V0Q29kZUxpbmVzKHNlbGVjdGlvbikge1xuICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBsaW5lcyA9IFtdO1xuICBpZiAobm9kZXMubGVuZ3RoID09PSAxICYmICRpc0NvZGVOb2RlKG5vZGVzWzBdKSkge1xuICAgIHJldHVybiBsaW5lcztcbiAgfVxuICBsZXQgbGFzdExpbmUgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAoISgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSB8fCAkaXNUYWJOb2RlKG5vZGUpIHx8ICRpc0xpbmVCcmVha05vZGUobm9kZSkpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIHNlbGVjdGlvbiB0byBiZSBpbnNpZGUgQ29kZUJsb2NrIGFuZCBjb25zaXN0aW5nIG9mIENvZGVIaWdobGlnaHROb2RlLCBUYWJOb2RlIGFuZCBMaW5lQnJlYWtOb2RlYCk7XG4gICAgfVxuICAgIGlmICgkaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICBpZiAobGFzdExpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICBsaW5lcy5wdXNoKGxhc3RMaW5lKTtcbiAgICAgICAgbGFzdExpbmUgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdExpbmUucHVzaChub2RlKTtcbiAgICB9XG4gIH1cbiAgaWYgKGxhc3RMaW5lLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBzZWxlY3Rpb25FbmQgPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpID8gc2VsZWN0aW9uLmFuY2hvciA6IHNlbGVjdGlvbi5mb2N1cztcblxuICAgIC8vIERpc2NhcmQgdGhlIGxhc3QgbGluZSBpZiB0aGUgc2VsZWN0aW9uIGVuZHMgZXhhY3RseSBhdCB0aGVcbiAgICAvLyBzdGFydCBvZiB0aGUgbGluZSAobm8gcmVhbCBzZWxlY3Rpb24pXG4gICAgY29uc3QgbGFzdFBvaW50ID0gJGNyZWF0ZVBvaW50KGxhc3RMaW5lWzBdLmdldEtleSgpLCAwLCAndGV4dCcpO1xuICAgIGlmICghc2VsZWN0aW9uRW5kLmlzKGxhc3RQb2ludCkpIHtcbiAgICAgIGxpbmVzLnB1c2gobGFzdExpbmUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGluZXM7XG59XG5mdW5jdGlvbiAkaGFuZGxlVGFiKHNoaWZ0S2V5KSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICEkaXNTZWxlY3Rpb25JbkNvZGUoc2VsZWN0aW9uKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGluZGVudE9yT3V0ZGVudCA9ICFzaGlmdEtleSA/IElOREVOVF9DT05URU5UX0NPTU1BTkQgOiBPVVRERU5UX0NPTlRFTlRfQ09NTUFORDtcbiAgY29uc3QgdGFiT3JPdXRkZW50ID0gIXNoaWZ0S2V5ID8gSU5TRVJUX1RBQl9DT01NQU5EIDogT1VUREVOVF9DT05URU5UX0NPTU1BTkQ7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuXG4gIC8vIDEuIGVhcmx5IGRlY2lzaW9uIHdoZW4gdGhlcmUgaXMgbm8gcmVhbCBzZWxlY3Rpb25cbiAgaWYgKGFuY2hvci5pcyhmb2N1cykpIHtcbiAgICByZXR1cm4gdGFiT3JPdXRkZW50O1xuICB9XG5cbiAgLy8gMi4gSWYgb25seSBlbXB0eSBsaW5lcyBvciBtdWx0aXBsZSBub24tZW1wdHkgbGluZXMgYXJlIHNlbGVjdGVkOiBpbmRlbnQvb3V0ZGVudFxuICBjb25zdCBjb2RlTGluZXMgPSAkZ2V0Q29kZUxpbmVzKHNlbGVjdGlvbik7XG4gIGlmIChjb2RlTGluZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgcmV0dXJuIGluZGVudE9yT3V0ZGVudDtcbiAgfVxuICBjb25zdCBjb2RlTGluZSA9IGNvZGVMaW5lc1swXTtcbiAgY29uc3QgY29kZUxpbmVMZW5ndGggPSBjb2RlTGluZS5sZW5ndGg7XG4gIGlmICghKGNvZGVMaW5lTGVuZ3RoICE9PSAwKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGdldENvZGVMaW5lcyBvbmx5IGV4dHJhY3RzIG5vbi1lbXB0eSBsaW5lc2ApO1xuICB9IC8vIFRha2UgaW50byBhY2NvdW50IHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNlbGVjdGlvblxuICBsZXQgc2VsZWN0aW9uRmlyc3Q7XG4gIGxldCBzZWxlY3Rpb25MYXN0O1xuICBpZiAoc2VsZWN0aW9uLmlzQmFja3dhcmQoKSkge1xuICAgIHNlbGVjdGlvbkZpcnN0ID0gZm9jdXM7XG4gICAgc2VsZWN0aW9uTGFzdCA9IGFuY2hvcjtcbiAgfSBlbHNlIHtcbiAgICBzZWxlY3Rpb25GaXJzdCA9IGFuY2hvcjtcbiAgICBzZWxlY3Rpb25MYXN0ID0gZm9jdXM7XG4gIH1cblxuICAvLyBmaW5kIGJvdW5kYXJ5IGVsZW1lbnRzIG9mIHRoZSBsaW5lXG4gIC8vIHNpbmNlIGNvZGVMaW5lIG9ubHkgY29udGFpbnMgVGFiTm9kZSB8IENvZGVIaWdobGlnaHROb2RlXG4gIC8vIHRoZSByZXN1bHQgb2YgdGhlc2UgZnVuY3Rpb25zIHNob3VsZCBpcyBvZiBUeXBlIFRhYk5vZGUgfCBDb2RlSGlnaGxpZ2h0Tm9kZVxuICBjb25zdCBmaXJzdE9mTGluZSA9ICRnZXRGaXJzdENvZGVOb2RlT2ZMaW5lKGNvZGVMaW5lWzBdKTtcbiAgY29uc3QgbGFzdE9mTGluZSA9ICRnZXRMYXN0Q29kZU5vZGVPZkxpbmUoY29kZUxpbmVbMF0pO1xuICBjb25zdCBhbmNob3JPZkxpbmUgPSAkY3JlYXRlUG9pbnQoZmlyc3RPZkxpbmUuZ2V0S2V5KCksIDAsICd0ZXh0Jyk7XG4gIGNvbnN0IGZvY3VzT2ZMaW5lID0gJGNyZWF0ZVBvaW50KGxhc3RPZkxpbmUuZ2V0S2V5KCksIGxhc3RPZkxpbmUuZ2V0VGV4dENvbnRlbnRTaXplKCksICd0ZXh0Jyk7XG5cbiAgLy8gMy4gbXVsdGlsaW5lIGJlY2F1c2Ugc2VsZWN0aW9uIHN0YXJ0ZWQgc3RyaWN0bHkgYmVmb3JlIHRoZSBsaW5lXG4gIGlmIChzZWxlY3Rpb25GaXJzdC5pc0JlZm9yZShhbmNob3JPZkxpbmUpKSB7XG4gICAgcmV0dXJuIGluZGVudE9yT3V0ZGVudDtcbiAgfVxuXG4gIC8vIDQuIG11bHRpbGluZSBiZWNhdXNlIHRoZSBzZWxlY3Rpb24gc3RvcHMgc3RyaWN0bHkgYWZ0ZXIgdGhlIGxpbmVcbiAgaWYgKGZvY3VzT2ZMaW5lLmlzQmVmb3JlKHNlbGVjdGlvbkxhc3QpKSB7XG4gICAgcmV0dXJuIGluZGVudE9yT3V0ZGVudDtcbiAgfVxuXG4gIC8vIFRoZSBzZWxlY3Rpb24gaWYgd2l0aGluIHRoZSBsaW5lLlxuICAvLyA0LiBJZiBpdCBkb2VzIG5vdCB0b3VjaCBib3RoIGJvcmRlcnMsIGl0IG5lZWRzIGEgdGFiXG4gIGlmIChhbmNob3JPZkxpbmUuaXNCZWZvcmUoc2VsZWN0aW9uRmlyc3QpIHx8IHNlbGVjdGlvbkxhc3QuaXNCZWZvcmUoZm9jdXNPZkxpbmUpKSB7XG4gICAgcmV0dXJuIHRhYk9yT3V0ZGVudDtcbiAgfVxuXG4gIC8vIDUuIFNlbGVjdGlvbiBpcyBtYXRjaGluZyBhIGZ1bGwgbGluZSBvbiBub24tZW1wdHkgY29kZVxuICByZXR1cm4gaW5kZW50T3JPdXRkZW50O1xufVxuZnVuY3Rpb24gJGhhbmRsZU11bHRpbGluZUluZGVudCh0eXBlKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICEkaXNTZWxlY3Rpb25JbkNvZGUoc2VsZWN0aW9uKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBjb2RlTGluZXMgPSAkZ2V0Q29kZUxpbmVzKHNlbGVjdGlvbik7XG4gIGNvbnN0IGNvZGVMaW5lc0xlbmd0aCA9IGNvZGVMaW5lcy5sZW5ndGg7XG5cbiAgLy8gU3BlY2lhbCBJbmRlbnQgY2FzZVxuICAvLyBTZWxlY3Rpb24gaXMgY29sbGFwc2VkIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBsaW5lXG4gIGlmIChjb2RlTGluZXNMZW5ndGggPT09IDAgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICBpZiAodHlwZSA9PT0gSU5ERU5UX0NPTlRFTlRfQ09NTUFORCkge1xuICAgICAgc2VsZWN0aW9uLmluc2VydE5vZGVzKFskY3JlYXRlVGFiTm9kZSgpXSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gU3BlY2lhbCBJbmRlbnQgY2FzZVxuICAvLyBTZWxlY3Rpb24gaXMgbWF0Y2hpbmcgb25seSBvbmUgTGluZUJyZWFrXG4gIGlmIChjb2RlTGluZXNMZW5ndGggPT09IDAgJiYgdHlwZSA9PT0gSU5ERU5UX0NPTlRFTlRfQ09NTUFORCAmJiBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKSA9PT0gJ1xcbicpIHtcbiAgICBjb25zdCB0YWJOb2RlID0gJGNyZWF0ZVRhYk5vZGUoKTtcbiAgICBjb25zdCBsaW5lQnJlYWtOb2RlID0gJGNyZWF0ZUxpbmVCcmVha05vZGUoKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpID8gJ3ByZXZpb3VzJyA6ICduZXh0JztcbiAgICBzZWxlY3Rpb24uaW5zZXJ0Tm9kZXMoW3RhYk5vZGUsIGxpbmVCcmVha05vZGVdKTtcbiAgICAkc2V0U2VsZWN0aW9uRnJvbUNhcmV0UmFuZ2UoJGdldENhcmV0UmFuZ2VJbkRpcmVjdGlvbigkZ2V0Q2FyZXRSYW5nZSgkZ2V0VGV4dFBvaW50Q2FyZXQodGFiTm9kZSwgJ25leHQnLCAwKSwgJG5vcm1hbGl6ZUNhcmV0KCRnZXRTaWJsaW5nQ2FyZXQobGluZUJyZWFrTm9kZSwgJ25leHQnKSkpLCBkaXJlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEluZGVudCBOb24gRW1wdHkgTGluZXNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlTGluZXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBjb2RlTGluZXNbaV07XG4gICAgLy8gYSBsaW5lIGhlcmUgaXMgbmV2ZXIgZW1wdHlcbiAgICBpZiAobGluZS5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgZmlyc3RPZkxpbmUgPSBsaW5lWzBdO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgdG8gY29uc2lkZXIgdGhlIGZpcnN0IG5vZGUgb24gdGhlIGZpcnN0IGxpbmVcbiAgICAgIC8vIGJlY2F1c2UgdGhlIGxpbmUgbWlnaHQgbm90IGJlIGZ1bGx5IHNlbGVjdGVkXG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBmaXJzdE9mTGluZSA9ICRnZXRGaXJzdENvZGVOb2RlT2ZMaW5lKGZpcnN0T2ZMaW5lKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBJTkRFTlRfQ09OVEVOVF9DT01NQU5EKSB7XG4gICAgICAgIGNvbnN0IHRhYk5vZGUgPSAkY3JlYXRlVGFiTm9kZSgpO1xuICAgICAgICBmaXJzdE9mTGluZS5pbnNlcnRCZWZvcmUodGFiTm9kZSk7XG4gICAgICAgIC8vIEZpcnN0IHJlYWwgY29kZSBsaW5lIG1heSBuZWVkIHNlbGVjdGlvbiBhZGp1c3RtZW50XG4gICAgICAgIC8vIHdoZW4gZmlyc3RPZkxpbmUgaXMgYXQgdGhlIHNlbGVjdGlvbiBib3VuZGFyeVxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGNvbnN0IGFuY2hvcktleSA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCkgPyAnZm9jdXMnIDogJ2FuY2hvcic7XG4gICAgICAgICAgY29uc3QgYW5jaG9yTGluZSA9ICRjcmVhdGVQb2ludChmaXJzdE9mTGluZS5nZXRLZXkoKSwgMCwgJ3RleHQnKTtcbiAgICAgICAgICBpZiAoc2VsZWN0aW9uW2FuY2hvcktleV0uaXMoYW5jaG9yTGluZSkpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvblthbmNob3JLZXldLnNldCh0YWJOb2RlLmdldEtleSgpLCAwLCAndGV4dCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgkaXNUYWJOb2RlKGZpcnN0T2ZMaW5lKSkge1xuICAgICAgICBmaXJzdE9mTGluZS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiAkaGFuZGxlU2hpZnRMaW5lcyh0eXBlLCBldmVudCkge1xuICAvLyBXZSBvbmx5IGNhcmUgYWJvdXQgdGhlIGFsdCthcnJvdyBrZXlzXG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gSSdtIG5vdCBxdWl0ZSBzdXJlIHdoeSwgYnV0IGl0IHNlZW1zIGxpa2UgY2FsbGluZyBhbmNob3IuZ2V0Tm9kZSgpIGNvbGxhcHNlcyB0aGUgc2VsZWN0aW9uIGhlcmVcbiAgLy8gU28gZmlyc3QsIGdldCB0aGUgYW5jaG9yIGFuZCB0aGUgZm9jdXMsIHRoZW4gZ2V0IHRoZWlyIG5vZGVzXG4gIGNvbnN0IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA9IHNlbGVjdGlvbjtcbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgZm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gIGNvbnN0IGFycm93SXNVcCA9IHR5cGUgPT09IEtFWV9BUlJPV19VUF9DT01NQU5EO1xuXG4gIC8vIEVuc3VyZSB0aGUgc2VsZWN0aW9uIGlzIHdpdGhpbiB0aGUgY29kZWJsb2NrXG4gIGlmICghJGlzU2VsZWN0aW9uSW5Db2RlKHNlbGVjdGlvbikgfHwgISgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShhbmNob3JOb2RlKSB8fCAkaXNUYWJOb2RlKGFuY2hvck5vZGUpKSB8fCAhKCRpc0NvZGVIaWdobGlnaHROb2RlKGZvY3VzTm9kZSkgfHwgJGlzVGFiTm9kZShmb2N1c05vZGUpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWV2ZW50LmFsdEtleSkge1xuICAgIC8vIEhhbmRsZSBtb3Zpbmcgc2VsZWN0aW9uIG91dCBvZiB0aGUgY29kZSBibG9jaywgZ2l2ZW4gdGhlcmUgYXJlIG5vXG4gICAgLy8gc2libGluZ3MgdGhhdCBjYW4gbmF0aXZlbHkgdGFrZSB0aGUgc2VsZWN0aW9uLlxuICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgY29uc3QgY29kZU5vZGUgPSBhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGlmIChhcnJvd0lzVXAgJiYgYW5jaG9yT2Zmc2V0ID09PSAwICYmIGFuY2hvck5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29kZU5vZGVTaWJsaW5nID0gY29kZU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgIGlmIChjb2RlTm9kZVNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICBjb2RlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWFycm93SXNVcCAmJiBhbmNob3JPZmZzZXQgPT09IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgJiYgYW5jaG9yTm9kZS5nZXROZXh0U2libGluZygpID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvZGVOb2RlU2libGluZyA9IGNvZGVOb2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgIGlmIChjb2RlTm9kZVNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICBjb2RlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IHN0YXJ0O1xuICBsZXQgZW5kO1xuICBpZiAoYW5jaG9yTm9kZS5pc0JlZm9yZShmb2N1c05vZGUpKSB7XG4gICAgc3RhcnQgPSAkZ2V0Rmlyc3RDb2RlTm9kZU9mTGluZShhbmNob3JOb2RlKTtcbiAgICBlbmQgPSAkZ2V0TGFzdENvZGVOb2RlT2ZMaW5lKGZvY3VzTm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSAkZ2V0Rmlyc3RDb2RlTm9kZU9mTGluZShmb2N1c05vZGUpO1xuICAgIGVuZCA9ICRnZXRMYXN0Q29kZU5vZGVPZkxpbmUoYW5jaG9yTm9kZSk7XG4gIH1cbiAgaWYgKHN0YXJ0ID09IG51bGwgfHwgZW5kID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcmFuZ2UgPSBzdGFydC5nZXROb2Rlc0JldHdlZW4oZW5kKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSByYW5nZVtpXTtcbiAgICBpZiAoISRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpICYmICEkaXNUYWJOb2RlKG5vZGUpICYmICEkaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gQWZ0ZXIgdGhpcyBwb2ludCwgd2Uga25vdyB0aGUgc2VsZWN0aW9uIGlzIHdpdGhpbiB0aGUgY29kZWJsb2NrLiBXZSBtYXkgbm90IGJlIGFibGUgdG9cbiAgLy8gYWN0dWFsbHkgbW92ZSB0aGUgbGluZXMgYXJvdW5kLCBidXQgd2Ugd2FudCB0byByZXR1cm4gdHJ1ZSBlaXRoZXIgd2F5IHRvIHByZXZlbnRcbiAgLy8gdGhlIGV2ZW50J3MgZGVmYXVsdCBiZWhhdmlvclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gcmVxdWlyZWQgdG8gc3RvcCBjdXJzb3IgbW92ZW1lbnQgdW5kZXIgRmlyZWZveFxuXG4gIGNvbnN0IGxpbmVicmVhayA9IGFycm93SXNVcCA/IHN0YXJ0LmdldFByZXZpb3VzU2libGluZygpIDogZW5kLmdldE5leHRTaWJsaW5nKCk7XG4gIGlmICghJGlzTGluZUJyZWFrTm9kZShsaW5lYnJlYWspKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qgc2libGluZyA9IGFycm93SXNVcCA/IGxpbmVicmVhay5nZXRQcmV2aW91c1NpYmxpbmcoKSA6IGxpbmVicmVhay5nZXROZXh0U2libGluZygpO1xuICBpZiAoc2libGluZyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgbWF5YmVJbnNlcnRpb25Qb2ludCA9ICRpc0NvZGVIaWdobGlnaHROb2RlKHNpYmxpbmcpIHx8ICRpc1RhYk5vZGUoc2libGluZykgfHwgJGlzTGluZUJyZWFrTm9kZShzaWJsaW5nKSA/IGFycm93SXNVcCA/ICRnZXRGaXJzdENvZGVOb2RlT2ZMaW5lKHNpYmxpbmcpIDogJGdldExhc3RDb2RlTm9kZU9mTGluZShzaWJsaW5nKSA6IG51bGw7XG4gIGxldCBpbnNlcnRpb25Qb2ludCA9IG1heWJlSW5zZXJ0aW9uUG9pbnQgIT0gbnVsbCA/IG1heWJlSW5zZXJ0aW9uUG9pbnQgOiBzaWJsaW5nO1xuICBsaW5lYnJlYWsucmVtb3ZlKCk7XG4gIHJhbmdlLmZvckVhY2gobm9kZSA9PiBub2RlLnJlbW92ZSgpKTtcbiAgaWYgKHR5cGUgPT09IEtFWV9BUlJPV19VUF9DT01NQU5EKSB7XG4gICAgcmFuZ2UuZm9yRWFjaChub2RlID0+IGluc2VydGlvblBvaW50Lmluc2VydEJlZm9yZShub2RlKSk7XG4gICAgaW5zZXJ0aW9uUG9pbnQuaW5zZXJ0QmVmb3JlKGxpbmVicmVhayk7XG4gIH0gZWxzZSB7XG4gICAgaW5zZXJ0aW9uUG9pbnQuaW5zZXJ0QWZ0ZXIobGluZWJyZWFrKTtcbiAgICBpbnNlcnRpb25Qb2ludCA9IGxpbmVicmVhaztcbiAgICByYW5nZS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgaW5zZXJ0aW9uUG9pbnQuaW5zZXJ0QWZ0ZXIobm9kZSk7XG4gICAgICBpbnNlcnRpb25Qb2ludCA9IG5vZGU7XG4gICAgfSk7XG4gIH1cbiAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2UoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiAkaGFuZGxlTW92ZVRvKHR5cGUsIGV2ZW50KSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA9IHNlbGVjdGlvbjtcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgY29uc3QgaXNNb3ZlVG9TdGFydCA9IHR5cGUgPT09IE1PVkVfVE9fU1RBUlQ7XG5cbiAgLy8gRW5zdXJlIHRoZSBzZWxlY3Rpb24gaXMgd2l0aGluIHRoZSBjb2RlYmxvY2tcbiAgaWYgKCEkaXNTZWxlY3Rpb25JbkNvZGUoc2VsZWN0aW9uKSB8fCAhKCRpc0NvZGVIaWdobGlnaHROb2RlKGFuY2hvck5vZGUpIHx8ICRpc1RhYk5vZGUoYW5jaG9yTm9kZSkpIHx8ICEoJGlzQ29kZUhpZ2hsaWdodE5vZGUoZm9jdXNOb2RlKSB8fCAkaXNUYWJOb2RlKGZvY3VzTm9kZSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc01vdmVUb1N0YXJ0KSB7XG4gICAgY29uc3Qgc3RhcnQgPSAkZ2V0U3RhcnRPZkNvZGVJbkxpbmUoZm9jdXNOb2RlLCBmb2N1cy5vZmZzZXQpO1xuICAgIGlmIChzdGFydCAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBub2RlLFxuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSBzdGFydDtcbiAgICAgIGlmICgkaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICAgIG5vZGUuc2VsZWN0TmV4dCgwLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGlvbi5zZXRUZXh0Tm9kZVJhbmdlKG5vZGUsIG9mZnNldCwgbm9kZSwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9jdXNOb2RlLmdldFBhcmVudE9yVGhyb3coKS5zZWxlY3RTdGFydCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBub2RlID0gJGdldEVuZE9mQ29kZUluTGluZShmb2N1c05vZGUpO1xuICAgIG5vZGUuc2VsZWN0KCk7XG4gIH1cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJDb2RlSGlnaGxpZ2h0aW5nKGVkaXRvciwgdG9rZW5pemVyKSB7XG4gIGlmICghZWRpdG9yLmhhc05vZGVzKFtDb2RlTm9kZSwgQ29kZUhpZ2hsaWdodE5vZGVdKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29kZUhpZ2hsaWdodFBsdWdpbjogQ29kZU5vZGUgb3IgQ29kZUhpZ2hsaWdodE5vZGUgbm90IHJlZ2lzdGVyZWQgb24gZWRpdG9yJyk7XG4gIH1cbiAgaWYgKHRva2VuaXplciA9PSBudWxsKSB7XG4gICAgdG9rZW5pemVyID0gUHJpc21Ub2tlbml6ZXI7XG4gIH1cbiAgY29uc3QgcmVnaXN0cmF0aW9ucyA9IFtdO1xuXG4gIC8vIE9ubHkgcmVnaXN0ZXIgdGhlIG11dGF0aW9uIGxpc3RlbmVyIGlmIG5vdCBpbiBoZWFkbGVzcyBtb2RlXG4gIGlmIChlZGl0b3IuX2hlYWRsZXNzICE9PSB0cnVlKSB7XG4gICAgcmVnaXN0cmF0aW9ucy5wdXNoKGVkaXRvci5yZWdpc3Rlck11dGF0aW9uTGlzdGVuZXIoQ29kZU5vZGUsIG11dGF0aW9ucyA9PiB7XG4gICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB0eXBlXSBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICBpZiAodHlwZSAhPT0gJ2Rlc3Ryb3llZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KGtleSk7XG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB1cGRhdGVDb2RlR3V0dGVyKG5vZGUsIGVkaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBza2lwSW5pdGlhbGl6YXRpb246IGZhbHNlXG4gICAgfSkpO1xuICB9XG5cbiAgLy8gQWRkIHRoZSByZXN0IG9mIHRoZSByZWdpc3RyYXRpb25zXG4gIHJlZ2lzdHJhdGlvbnMucHVzaChlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKENvZGVOb2RlLCBub2RlID0+IGNvZGVOb2RlVHJhbnNmb3JtKG5vZGUsIGVkaXRvciwgdG9rZW5pemVyKSksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oVGV4dE5vZGUsIG5vZGUgPT4gJHRleHROb2RlVHJhbnNmb3JtKG5vZGUsIGVkaXRvciwgdG9rZW5pemVyKSksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oQ29kZUhpZ2hsaWdodE5vZGUsIG5vZGUgPT4gJHRleHROb2RlVHJhbnNmb3JtKG5vZGUsIGVkaXRvciwgdG9rZW5pemVyKSksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX1RBQl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3QgY29tbWFuZCA9ICRoYW5kbGVUYWIoZXZlbnQuc2hpZnRLZXkpO1xuICAgIGlmIChjb21tYW5kID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChjb21tYW5kLCB1bmRlZmluZWQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX1RBQl9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzU2VsZWN0aW9uSW5Db2RlKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgJGluc2VydE5vZGVzKFskY3JlYXRlVGFiTm9kZSgpXSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTkRFTlRfQ09OVEVOVF9DT01NQU5ELCBwYXlsb2FkID0+ICRoYW5kbGVNdWx0aWxpbmVJbmRlbnQoSU5ERU5UX0NPTlRFTlRfQ09NTUFORCksIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChPVVRERU5UX0NPTlRFTlRfQ09NTUFORCwgcGF5bG9hZCA9PiAkaGFuZGxlTXVsdGlsaW5lSW5kZW50KE9VVERFTlRfQ09OVEVOVF9DT01NQU5EKSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19VUF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGlmICghJGlzU2VsZWN0aW9uSW5Db2RlKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSWYgYXQgdGhlIHN0YXJ0IG9mIGEgY29kZSBibG9jaywgcHJldmVudCBzZWxlY3Rpb24gZnJvbSBtb3Zpbmcgb3V0XG4gICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIGFuY2hvci5vZmZzZXQgPT09IDAgJiYgYW5jaG9yTm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA9PT0gbnVsbCAmJiAkaXNDb2RlTm9kZShhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICRoYW5kbGVTaGlmdExpbmVzKEtFWV9BUlJPV19VUF9DT01NQU5ELCBldmVudCk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfQVJST1dfRE9XTl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGlmICghJGlzU2VsZWN0aW9uSW5Db2RlKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSWYgYXQgdGhlIGVuZCBvZiBhIGNvZGUgYmxvY2ssIHByZXZlbnQgc2VsZWN0aW9uIGZyb20gbW92aW5nIG91dFxuICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBhbmNob3Iub2Zmc2V0ID09PSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpICYmIGFuY2hvck5vZGUuZ2V0TmV4dFNpYmxpbmcoKSA9PT0gbnVsbCAmJiAkaXNDb2RlTm9kZShhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICRoYW5kbGVTaGlmdExpbmVzKEtFWV9BUlJPV19ET1dOX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKE1PVkVfVE9fU1RBUlQsIGV2ZW50ID0+ICRoYW5kbGVNb3ZlVG8oTU9WRV9UT19TVEFSVCwgZXZlbnQpLCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoTU9WRV9UT19FTkQsIGV2ZW50ID0+ICRoYW5kbGVNb3ZlVG8oTU9WRV9UT19FTkQsIGV2ZW50KSwgQ09NTUFORF9QUklPUklUWV9MT1cpKTtcbiAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoLi4ucmVnaXN0cmF0aW9ucyk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vKiogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byB7QGxpbmsgJGdldEZpcnN0Q29kZU5vZGVPZkxpbmV9IGJ5IEBsZXhpY2FsL2VzbGludC1wbHVnaW4gcnVsZXMtb2YtbGV4aWNhbCAqL1xuY29uc3QgZ2V0Rmlyc3RDb2RlTm9kZU9mTGluZSA9ICRnZXRGaXJzdENvZGVOb2RlT2ZMaW5lO1xuLyoqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8ge0BsaW5rICRnZXRMYXN0Q29kZU5vZGVPZkxpbmV9IGJ5IEBsZXhpY2FsL2VzbGludC1wbHVnaW4gcnVsZXMtb2YtbGV4aWNhbCAqL1xuY29uc3QgZ2V0TGFzdENvZGVOb2RlT2ZMaW5lID0gJGdldExhc3RDb2RlTm9kZU9mTGluZTtcbi8qKiBAZGVwcmVjYXRlZCByZW5hbWVkIHRvIHtAbGluayAkZ2V0RW5kT2ZDb2RlSW5MaW5lfSBieSBAbGV4aWNhbC9lc2xpbnQtcGx1Z2luIHJ1bGVzLW9mLWxleGljYWwgKi9cbmNvbnN0IGdldEVuZE9mQ29kZUluTGluZSA9ICRnZXRFbmRPZkNvZGVJbkxpbmU7XG4vKiogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byB7QGxpbmsgJGdldFN0YXJ0T2ZDb2RlSW5MaW5lfSBieSBAbGV4aWNhbC9lc2xpbnQtcGx1Z2luIHJ1bGVzLW9mLWxleGljYWwgKi9cbmNvbnN0IGdldFN0YXJ0T2ZDb2RlSW5MaW5lID0gJGdldFN0YXJ0T2ZDb2RlSW5MaW5lO1xuXG5leHBvcnQgeyAkY3JlYXRlQ29kZUhpZ2hsaWdodE5vZGUsICRjcmVhdGVDb2RlTm9kZSwgJGdldEVuZE9mQ29kZUluTGluZSwgJGdldEZpcnN0Q29kZU5vZGVPZkxpbmUsICRnZXRMYXN0Q29kZU5vZGVPZkxpbmUsICRnZXRTdGFydE9mQ29kZUluTGluZSwgJGlzQ29kZUhpZ2hsaWdodE5vZGUsICRpc0NvZGVOb2RlLCBDT0RFX0xBTkdVQUdFX0ZSSUVORExZX05BTUVfTUFQLCBDT0RFX0xBTkdVQUdFX01BUCwgQ29kZUhpZ2hsaWdodE5vZGUsIENvZGVOb2RlLCBERUZBVUxUX0NPREVfTEFOR1VBR0UsIFByaXNtVG9rZW5pemVyLCBnZXRDb2RlTGFuZ3VhZ2VzLCBnZXREZWZhdWx0Q29kZUxhbmd1YWdlLCBnZXRFbmRPZkNvZGVJbkxpbmUsIGdldEZpcnN0Q29kZU5vZGVPZkxpbmUsIGdldExhbmd1YWdlRnJpZW5kbHlOYW1lLCBnZXRMYXN0Q29kZU5vZGVPZkxpbmUsIGdldFN0YXJ0T2ZDb2RlSW5MaW5lLCBub3JtYWxpemVDb2RlTGFuZywgcmVnaXN0ZXJDb2RlSGlnaGxpZ2h0aW5nIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lexical+code@0.33.1/node_modules/@lexical/code/LexicalCode.dev.mjs\n");

/***/ })

};
;