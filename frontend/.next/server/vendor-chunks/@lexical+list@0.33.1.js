"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+list@0.33.1";
exports.ids = ["vendor-chunks/@lexical+list@0.33.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@lexical+list@0.33.1/node_modules/@lexical/list/LexicalList.dev.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+list@0.33.1/node_modules/@lexical/list/LexicalList.dev.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createListItemNode: () => (/* binding */ $createListItemNode),\n/* harmony export */   $createListNode: () => (/* binding */ $createListNode),\n/* harmony export */   $getListDepth: () => (/* binding */ $getListDepth),\n/* harmony export */   $handleListInsertParagraph: () => (/* binding */ $handleListInsertParagraph),\n/* harmony export */   $insertList: () => (/* binding */ $insertList),\n/* harmony export */   $isListItemNode: () => (/* binding */ $isListItemNode),\n/* harmony export */   $isListNode: () => (/* binding */ $isListNode),\n/* harmony export */   $removeList: () => (/* binding */ $removeList),\n/* harmony export */   INSERT_CHECK_LIST_COMMAND: () => (/* binding */ INSERT_CHECK_LIST_COMMAND),\n/* harmony export */   INSERT_ORDERED_LIST_COMMAND: () => (/* binding */ INSERT_ORDERED_LIST_COMMAND),\n/* harmony export */   INSERT_UNORDERED_LIST_COMMAND: () => (/* binding */ INSERT_UNORDERED_LIST_COMMAND),\n/* harmony export */   ListItemNode: () => (/* binding */ ListItemNode),\n/* harmony export */   ListNode: () => (/* binding */ ListNode),\n/* harmony export */   REMOVE_LIST_COMMAND: () => (/* binding */ REMOVE_LIST_COMMAND),\n/* harmony export */   UPDATE_LIST_START_COMMAND: () => (/* binding */ UPDATE_LIST_START_COMMAND),\n/* harmony export */   insertList: () => (/* binding */ insertList),\n/* harmony export */   registerCheckList: () => (/* binding */ registerCheckList),\n/* harmony export */   registerList: () => (/* binding */ registerList),\n/* harmony export */   registerListStrictIndentTransform: () => (/* binding */ registerListStrictIndentTransform),\n/* harmony export */   removeList: () => (/* binding */ removeList)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/.pnpm/@lexical+utils@0.33.1/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/.pnpm/lexical@0.33.1/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/.pnpm/@lexical+selection@0.33.1/node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(parent) || $isListNode(parent))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction $insertList(listType) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (selection !== null) {\n    let nodes = selection.getNodes();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const anchorAndFocus = selection.getStartEndPoints();\n      if (!(anchorAndFocus !== null)) {\n        formatDevErrorMessage(`insertList: anchor should be defined`);\n      }\n      const [anchor] = anchorAndFocus;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(anchorNode)) {\n        const firstChild = anchorNode.getFirstChild();\n        if (firstChild) {\n          nodes = firstChild.selectStart().getNodes();\n        } else {\n          const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n          anchorNode.append(paragraph);\n          nodes = paragraph.select().getNodes();\n        }\n      } else if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n        return;\n      }\n    }\n    const handled = new Set();\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n        $createListOrMerge(node, listType);\n        continue;\n      }\n      let parent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node) ? node.getParent() : $isListItemNode(node) && node.isEmpty() ? node : null;\n      while (parent != null) {\n        const parentKey = parent.getKey();\n        if ($isListNode(parent)) {\n          if (!handled.has(parentKey)) {\n            const newListNode = $createListNode(listType);\n            append(newListNode, parent.getChildren());\n            parent.replace(newListNode);\n            handled.add(parentKey);\n          }\n          break;\n        } else {\n          const nextParent = parent.getParent();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(nextParent) && !handled.has(parentKey)) {\n            handled.add(parentKey);\n            $createListOrMerge(parent, listType);\n            break;\n          }\n          parent = nextParent;\n        }\n      }\n    }\n  }\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  append(listItem, node.getChildren());\n  let targetList;\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    // if the same type of list is on both sides, merge them.\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    targetList = previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    targetList = nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    targetList = list;\n  }\n  // listItem needs to be attached to root prior to setting indent\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  node.remove();\n  return targetList;\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n */\nfunction $removeList() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    const listNodes = new Set();\n    const nodes = selection.getNodes();\n    const anchorNode = selection.anchor.getNode();\n    if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n      listNodes.add($getTopListNode(anchorNode));\n    } else {\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node)) {\n          const listItemNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$getNearestNodeOfType)(node, ListItemNode);\n          if (listItemNode != null) {\n            listNodes.add($getTopListNode(listItemNode));\n          }\n        }\n      }\n    }\n    for (const listNode of listNodes) {\n      let insertionPoint = listNode;\n      const listItems = $getAllListItems(listNode);\n      for (const listItemNode of listItems) {\n        const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)().setTextStyle(selection.style).setTextFormat(selection.format);\n        append(paragraph, listItemNode.getChildren());\n        insertionPoint.insertAfter(paragraph);\n        insertionPoint = paragraph;\n\n        // When the anchor and focus fall on the textNode\n        // we don't have to change the selection because the textNode will be appended to\n        // the newly generated paragraph.\n        // When selection is in empty nested list item, selection is actually on the listItemNode.\n        // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n        // we should manually set the selection's focus and anchor to the newly generated paragraph.\n        if (listItemNode.__key === selection.anchor.key) {\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.anchor, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(paragraph, 'next')));\n        }\n        if (listItemNode.__key === selection.focus.key) {\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.focus, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(paragraph, 'next')));\n        }\n        listItemNode.remove();\n      }\n      listNode.remove();\n    }\n  }\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode().setTextFormat(listItemNode.getTextFormat()).setTextStyle(listItemNode.getTextStyle());\n      const newList = $createListNode(parent.getListType()).setTextFormat(parent.getTextFormat()).setTextStyle(parent.getTextStyle());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted successfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(grandparent)) {\n    replacementNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.setTextStyle(selection.style).setTextFormat(selection.format).select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isListItemNode(replacementNode)) {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    } else {\n      replacementNode.insertAfter(newList);\n    }\n    newList.append(...nextSiblings);\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\nfunction applyMarkerStyles(dom, node, prevNode) {\n  const styles = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.getStyleObjectFromCSS)(node.__textStyle);\n  for (const k in styles) {\n    dom.style.setProperty(`--listitem-marker-${k}`, styles[k]);\n  }\n  if (prevNode) {\n    for (const k in (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.getStyleObjectFromCSS)(prevNode.__textStyle)) {\n      if (!(k in styles)) {\n        dom.style.removeProperty(`--listitem-marker-${k}`);\n      }\n    }\n  }\n}\n\n/** @noInheritDoc */\nclass ListItemNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  $config() {\n    return this.config('listitem', {\n      $transform: node => {\n        if (node.__checked == null) {\n          return;\n        }\n        const parent = node.getParent();\n        if ($isListNode(parent)) {\n          if (parent.getListType() !== 'check' && node.getChecked() != null) {\n            node.setChecked(undefined);\n          }\n        }\n      },\n      extends: lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode,\n      importDOM: (0,lexical__WEBPACK_IMPORTED_MODULE_0__.buildImportMap)({\n        li: () => ({\n          conversion: $convertListItemElement,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(value = 1, checked = undefined, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__value = prevNode.__value;\n    this.__checked = prevNode.__checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    this.updateListItemDOM(null, element, config);\n    return element;\n  }\n  updateListItemDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    const prevStyle = prevNode ? prevNode.__style : '';\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      if (nextStyle === '') {\n        dom.removeAttribute('style');\n      } else {\n        dom.style.cssText = nextStyle;\n      }\n    }\n    applyMarkerStyles(dom, this, prevNode);\n  }\n  updateDOM(prevNode, dom, config) {\n    // @ts-expect-error - this is always HTMLListItemElement\n    const element = dom;\n    this.updateListItemDOM(prevNode, element, config);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setValue(serializedNode.value).setChecked(serializedNode.checked);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    const formatType = this.getFormatType();\n    if (formatType) {\n      element.style.textAlign = formatType;\n    }\n    const direction = this.getDirection();\n    if (direction) {\n      element.dir = direction;\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      value: this.getValue()\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(replaceWithNode)) {\n        formatDevErrorMessage(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        formatDevErrorMessage(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode().updateFromJSON(this.exportJSON()).setChecked(this.getChecked() ? false : undefined);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n    return self;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    let listType;\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n    return self;\n  }\n  toggleChecked() {\n    const self = this.getWritable();\n    return self.setChecked(!self.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null || !this.isAttached()) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number')) {\n      formatDevErrorMessage(`Invalid indent value.`);\n    }\n    indent = Math.floor(indent);\n    if (!(indent >= 0)) {\n      formatDevErrorMessage(`Indent value must be non-negative.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isListItemNode(node) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(node);\n  }\n  extractWithChild(child, selection) {\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  $config() {\n    return this.config('list', {\n      $transform: node => {\n        mergeNextSiblingListIfSameType(node);\n        updateChildrenListItemValue(node);\n      },\n      extends: lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode,\n      importDOM: (0,lexical__WEBPACK_IMPORTED_MODULE_0__.buildImportMap)({\n        ol: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        }),\n        ul: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(listType = 'number', start = 1, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__listType = prevNode.__listType;\n    this.__tag = prevNode.__tag;\n    this.__start = prevNode.__start;\n  }\n  getTag() {\n    return this.getLatest().__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n    return writable;\n  }\n  getListType() {\n    return this.getLatest().__listType;\n  }\n  getStart() {\n    return this.getLatest().__start;\n  }\n  setStart(start) {\n    const self = this.getWritable();\n    self.__start = start;\n    return self;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setListType(serializedNode.listType).setStart(serializedNode.start);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag()\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    let listItemNodesToInsert = nodesToInsert;\n    for (let i = 0; i < nodesToInsert.length; i++) {\n      const node = nodesToInsert[i];\n      if (!$isListItemNode(node)) {\n        if (listItemNodesToInsert === nodesToInsert) {\n          listItemNodesToInsert = [...nodesToInsert];\n        }\n        listItemNodesToInsert[i] = $createListItemNode().append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !($isListNode(node) || node.isInline()) ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(node.getTextContent()) : node);\n      }\n    }\n    return super.splice(start, deleteCount, listItemNodesToInsert);\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType = 'number', start = 1) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_CHECK_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_CHECK_LIST_COMMAND');\nfunction registerCheckList(editor) {\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(INSERT_CHECK_LIST_COMMAND, () => {\n    $insertList('check');\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_DOWN_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, false);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_UP_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, true);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ESCAPE_COMMAND, () => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null) {\n      const rootElement = editor.getRootElement();\n      if (rootElement != null) {\n        rootElement.focus();\n      }\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_SPACE_COMMAND, event => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null && editor.isEditable()) {\n      editor.update(() => {\n        const listItemNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(activeItem);\n        if ($isListItemNode(listItemNode)) {\n          event.preventDefault();\n          listItemNode.toggleChecked();\n        }\n      });\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_LEFT_COMMAND, event => {\n    return editor.getEditorState().read(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n        const {\n          anchor\n        } = selection;\n        const isElement = anchor.type === 'element';\n        if (isElement || anchor.offset === 0) {\n          const anchorNode = anchor.getNode();\n          const elementNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n          if ($isListItemNode(elementNode)) {\n            const parent = elementNode.getParent();\n            if ($isListNode(parent) && parent.getListType() === 'check' && (isElement || elementNode.getFirstDescendant() === anchorNode)) {\n              const domNode = editor.getElementByKey(elementNode.__key);\n              if (domNode != null && document.activeElement !== domNode) {\n                domNode.focus();\n                event.preventDefault();\n                return true;\n              }\n            }\n          }\n        }\n      }\n      return false;\n    });\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerRootListener((rootElement, prevElement) => {\n    if (rootElement !== null) {\n      rootElement.addEventListener('click', handleClick);\n      rootElement.addEventListener('pointerdown', handlePointerDown);\n    }\n    if (prevElement !== null) {\n      prevElement.removeEventListener('click', handleClick);\n      prevElement.removeEventListener('pointerdown', handlePointerDown);\n    }\n  }));\n}\nfunction handleCheckItemEvent(event, callback) {\n  const target = event.target;\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(target)) {\n    return;\n  }\n\n  // Ignore clicks on LI that have nested lists\n  const firstChild = target.firstChild;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(firstChild) && (firstChild.tagName === 'UL' || firstChild.tagName === 'OL')) {\n    return;\n  }\n  const parentNode = target.parentNode;\n\n  // @ts-ignore internal field\n  if (!parentNode || parentNode.__lexicalListType !== 'check') {\n    return;\n  }\n  const rect = target.getBoundingClientRect();\n  const zoom = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.calculateZoomLevel)(target);\n  const clientX = event.clientX / zoom;\n\n  // Use getComputedStyle if available, otherwise fallback to 0px width\n  const beforeStyles = window.getComputedStyle ? window.getComputedStyle(target, '::before') : {\n    width: '0px'\n  };\n  const beforeWidthInPixels = parseFloat(beforeStyles.width);\n\n  // Make click area slightly larger for touch devices to improve accessibility\n  const isTouchEvent = event.pointerType === 'touch';\n  const clickAreaPadding = isTouchEvent ? 32 : 0; // Add 32px padding for touch events\n\n  if (target.dir === 'rtl' ? clientX < rect.right + clickAreaPadding && clientX > rect.right - beforeWidthInPixels - clickAreaPadding : clientX > rect.left - clickAreaPadding && clientX < rect.left + beforeWidthInPixels + clickAreaPadding) {\n    callback();\n  }\n}\nfunction handleClick(event) {\n  handleCheckItemEvent(event, () => {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(event.target)) {\n      const domNode = event.target;\n      const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getNearestEditorFromDOMNode)(domNode);\n      if (editor != null && editor.isEditable()) {\n        editor.update(() => {\n          const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domNode);\n          if ($isListItemNode(node)) {\n            domNode.focus();\n            node.toggleChecked();\n          }\n        });\n      }\n    }\n  });\n}\nfunction handlePointerDown(event) {\n  handleCheckItemEvent(event, () => {\n    // Prevents caret moving when clicking on check mark\n    event.preventDefault();\n  });\n}\nfunction getActiveCheckListItem() {\n  const activeElement = document.activeElement;\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(activeElement) && activeElement.tagName === 'LI' && activeElement.parentNode != null &&\n  // @ts-ignore internal field\n  activeElement.parentNode.__lexicalListType === 'check' ? activeElement : null;\n}\nfunction findCheckListItemSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  let parent = node;\n\n  // Going up in a tree to get non-null sibling\n  while (sibling == null && $isListItemNode(parent)) {\n    // Get li -> parent ul/ol -> parent li\n    parent = parent.getParentOrThrow().getParent();\n    if (parent != null) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n\n  // Going down in a tree to get first non-nested list item\n  while ($isListItemNode(sibling)) {\n    const firstChild = backward ? sibling.getLastChild() : sibling.getFirstChild();\n    if (!$isListNode(firstChild)) {\n      return sibling;\n    }\n    sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild();\n  }\n  return null;\n}\nfunction handleArrowUpOrDown(event, editor, backward) {\n  const activeItem = getActiveCheckListItem();\n  if (activeItem != null) {\n    editor.update(() => {\n      const listItem = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(activeItem);\n      if (!$isListItemNode(listItem)) {\n        return;\n      }\n      const nextListItem = findCheckListItemSibling(listItem, backward);\n      if (nextListItem != null) {\n        nextListItem.selectStart();\n        const dom = editor.getElementByKey(nextListItem.__key);\n        if (dom != null) {\n          event.preventDefault();\n          setTimeout(() => {\n            dom.focus();\n          }, 0);\n        }\n      }\n    });\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst UPDATE_LIST_START_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('UPDATE_LIST_START_COMMAND');\nconst INSERT_UNORDERED_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_ORDERED_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('REMOVE_LIST_COMMAND');\nfunction registerList(editor) {\n  const removeListener = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {\n    $insertList('number');\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(UPDATE_LIST_START_COMMAND, payload => {\n    const {\n      listNodeKey,\n      newStart\n    } = payload;\n    const listNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(listNodeKey);\n    if (!$isListNode(listNode)) {\n      return false;\n    }\n    if (listNode.getListType() === 'number') {\n      listNode.setStart(newStart);\n      updateChildrenListItemValue(listNode);\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {\n    $insertList('bullet');\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(REMOVE_LIST_COMMAND, () => {\n    $removeList();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, () => $handleListInsertParagraph(), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerNodeTransform(ListItemNode, node => {\n    const firstChild = node.getFirstChild();\n    if (firstChild) {\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstChild)) {\n        const style = firstChild.getStyle();\n        const format = firstChild.getFormat();\n        if (node.getTextStyle() !== style) {\n          node.setTextStyle(style);\n        }\n        if (node.getTextFormat() !== format) {\n          node.setTextFormat(format);\n        }\n      }\n    } else {\n      // If it's empty, check the selection\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && (selection.style !== node.getTextStyle() || selection.format !== node.getTextFormat()) && selection.isCollapsed() && node.is(selection.anchor.getNode())) {\n        node.setTextStyle(selection.style).setTextFormat(selection.format);\n      }\n    }\n  }), editor.registerNodeTransform(lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode, node => {\n    const listItemParentNode = node.getParent();\n    if ($isListItemNode(listItemParentNode) && node.is(listItemParentNode.getFirstChild())) {\n      const style = node.getStyle();\n      const format = node.getFormat();\n      if (style !== listItemParentNode.getTextStyle() || format !== listItemParentNode.getTextFormat()) {\n        listItemParentNode.setTextStyle(style).setTextFormat(format);\n      }\n    }\n  }));\n  return removeListener;\n}\nfunction registerListStrictIndentTransform(editor) {\n  const $formatListIndentStrict = listItemNode => {\n    const listNode = listItemNode.getParent();\n    if ($isListNode(listItemNode.getFirstChild()) || !$isListNode(listNode)) {\n      return;\n    }\n    const startingListItemNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(listItemNode, node => $isListItemNode(node) && $isListNode(node.getParent()) && $isListItemNode(node.getPreviousSibling()));\n    if (startingListItemNode === null && listItemNode.getIndent() > 0) {\n      listItemNode.setIndent(0);\n    } else if ($isListItemNode(startingListItemNode)) {\n      const prevListItemNode = startingListItemNode.getPreviousSibling();\n      if ($isListItemNode(prevListItemNode)) {\n        const endListItemNode = $findChildrenEndListItemNode(prevListItemNode);\n        const endListNode = endListItemNode.getParent();\n        if ($isListNode(endListNode)) {\n          const prevDepth = $getListDepth(endListNode);\n          const depth = $getListDepth(listNode);\n          if (prevDepth + 1 < depth) {\n            listItemNode.setIndent(prevDepth);\n          }\n        }\n      }\n    }\n  };\n  const $processListWithStrictIndent = listNode => {\n    const queue = [listNode];\n    while (queue.length > 0) {\n      const node = queue.shift();\n      if (!$isListNode(node)) {\n        continue;\n      }\n      for (const child of node.getChildren()) {\n        if ($isListItemNode(child)) {\n          $formatListIndentStrict(child);\n          const firstChild = child.getFirstChild();\n          if ($isListNode(firstChild)) {\n            queue.push(firstChild);\n          }\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(ListNode, $processListWithStrictIndent);\n}\nfunction $findChildrenEndListItemNode(listItemNode) {\n  let current = listItemNode;\n  let firstChild = current.getFirstChild();\n  while ($isListNode(firstChild)) {\n    const lastChild = firstChild.getLastChild();\n    if ($isListItemNode(lastChild)) {\n      current = lastChild;\n      firstChild = current.getFirstChild();\n    } else {\n      break;\n    }\n  }\n  return current;\n}\n\n/**\n * @deprecated use {@link $insertList} from an update or command listener.\n *\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => $insertList(listType));\n}\n\n/**\n * @deprecated use {@link $removeList} from an update or command listener.\n *\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => $removeList());\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrbGlzdEAwLjMzLjEvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2xpc3QvTGV4aWNhbExpc3QuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtTDtBQUN1VztBQUMvZDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5REFBZ0I7QUFDcEQ7QUFDQTtBQUNBLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwyRUFBMkI7QUFDL0I7QUFDQTtBQUNBLElBQUksc0VBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7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VSwwREFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRyxnQ0FBZ0MsNkNBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1FQUFtQjtBQUNwRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThZIiwic291cmNlcyI6WyIvVXNlcnMvYW5raXRocmVkZHkvRGVza3RvcC9oYWNrYXRob25zL2thZ2dsZWdlbW1hL2xlcmVwYWlyYm90aW5mZXJlbmNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9AbGV4aWNhbCtsaXN0QDAuMzMuMS9ub2RlX21vZHVsZXMvQGxleGljYWwvbGlzdC9MZXhpY2FsTGlzdC5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGdldE5lYXJlc3ROb2RlT2ZUeXBlLCByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQsIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIG1lcmdlUmVnaXN0ZXIsICRmaW5kTWF0Y2hpbmdQYXJlbnQsIGNhbGN1bGF0ZVpvb21MZXZlbCB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7ICRnZXRTZWxlY3Rpb24sICRpc1JhbmdlU2VsZWN0aW9uLCAkaXNSb290T3JTaGFkb3dSb290LCAkY3JlYXRlUGFyYWdyYXBoTm9kZSwgJGlzRWxlbWVudE5vZGUsICRpc0xlYWZOb2RlLCAkc2V0UG9pbnRGcm9tQ2FyZXQsICRub3JtYWxpemVDYXJldCwgJGdldENoaWxkQ2FyZXQsIEVsZW1lbnROb2RlLCBidWlsZEltcG9ydE1hcCwgJGlzUGFyYWdyYXBoTm9kZSwgJGFwcGx5Tm9kZVJlcGxhY2VtZW50LCAkY3JlYXRlVGV4dE5vZGUsIGNyZWF0ZUNvbW1hbmQsIENPTU1BTkRfUFJJT1JJVFlfTE9XLCBLRVlfQVJST1dfRE9XTl9DT01NQU5ELCBLRVlfQVJST1dfVVBfQ09NTUFORCwgS0VZX0VTQ0FQRV9DT01NQU5ELCBLRVlfU1BBQ0VfQ09NTUFORCwgJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUsIEtFWV9BUlJPV19MRUZUX0NPTU1BTkQsIGdldE5lYXJlc3RFZGl0b3JGcm9tRE9NTm9kZSwgJGdldE5vZGVCeUtleSwgSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCAkaXNUZXh0Tm9kZSwgVGV4dE5vZGUgfSBmcm9tICdsZXhpY2FsJztcbmltcG9ydCB7IGdldFN0eWxlT2JqZWN0RnJvbUNTUyB9IGZyb20gJ0BsZXhpY2FsL3NlbGVjdGlvbic7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLy8gRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgYGludmFyaWFudGAgY2FsbHMuXG5cbmZ1bmN0aW9uIGZvcm1hdERldkVycm9yTWVzc2FnZShtZXNzYWdlKSB7XG4gIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgdGhlIGRlcHRoIG9mIGxpc3ROb2RlIGZyb20gdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSBsaXN0Tm9kZSAtIFRoZSBMaXN0Tm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgVGhlIGRlcHRoIG9mIHRoZSBMaXN0Tm9kZS5cbiAqL1xuZnVuY3Rpb24gJGdldExpc3REZXB0aChsaXN0Tm9kZSkge1xuICBsZXQgZGVwdGggPSAxO1xuICBsZXQgcGFyZW50ID0gbGlzdE5vZGUuZ2V0UGFyZW50KCk7XG4gIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUocGFyZW50KSkge1xuICAgICAgY29uc3QgcGFyZW50TGlzdCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnRMaXN0KSkge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnRMaXN0LmdldFBhcmVudCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBBIExpc3RJdGVtTm9kZSBtdXN0IGhhdmUgYSBMaXN0Tm9kZSBmb3IgYSBwYXJlbnQuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXB0aDtcbiAgfVxuICByZXR1cm4gZGVwdGg7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG5lYXJlc3QgYW5jZXN0cmFsIExpc3ROb2RlIGFuZCByZXR1cm5zIGl0LCB0aHJvd3MgYW4gaW52YXJpYW50IGlmIGxpc3RJdGVtIGlzIG5vdCBhIExpc3RJdGVtTm9kZS5cbiAqIEBwYXJhbSBsaXN0SXRlbSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBUaGUgTGlzdE5vZGUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uICRnZXRUb3BMaXN0Tm9kZShsaXN0SXRlbSkge1xuICBsZXQgbGlzdCA9IGxpc3RJdGVtLmdldFBhcmVudCgpO1xuICBpZiAoISRpc0xpc3ROb2RlKGxpc3QpKSB7XG4gICAge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBBIExpc3RJdGVtTm9kZSBtdXN0IGhhdmUgYSBMaXN0Tm9kZSBmb3IgYSBwYXJlbnQuYCk7XG4gICAgfVxuICB9XG4gIGxldCBwYXJlbnQgPSBsaXN0O1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICBsaXN0ID0gcGFyZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBBIHJlY3Vyc2l2ZSBEZXB0aC1GaXJzdCBTZWFyY2ggKFBvc3RvcmRlciBUcmF2ZXJzYWwpIHRoYXQgZmluZHMgYWxsIG9mIGEgbm9kZSdzIGNoaWxkcmVuXG4gKiB0aGF0IGFyZSBvZiB0eXBlIExpc3RJdGVtTm9kZSBhbmQgcmV0dXJucyB0aGVtIGluIGFuIGFycmF5LlxuICogQHBhcmFtIG5vZGUgLSBUaGUgTGlzdE5vZGUgdG8gc3RhcnQgdGhlIHNlYXJjaC5cbiAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIG5vZGVzIG9mIHR5cGUgTGlzdEl0ZW1Ob2RlIGZvdW5kLlxuICovXG4vLyBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSAkZ2V0QWxsQ2hpbGRyZW5PZlR5cGVcbmZ1bmN0aW9uICRnZXRBbGxMaXN0SXRlbXMobm9kZSkge1xuICBsZXQgbGlzdEl0ZW1Ob2RlcyA9IFtdO1xuICBjb25zdCBsaXN0Q2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCkuZmlsdGVyKCRpc0xpc3RJdGVtTm9kZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGlzdEl0ZW1Ob2RlID0gbGlzdENoaWxkcmVuW2ldO1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBsaXN0SXRlbU5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgbGlzdEl0ZW1Ob2RlcyA9IGxpc3RJdGVtTm9kZXMuY29uY2F0KCRnZXRBbGxMaXN0SXRlbXMoZmlyc3RDaGlsZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0SXRlbU5vZGVzLnB1c2gobGlzdEl0ZW1Ob2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3RJdGVtTm9kZXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgcGFzc2VkIG5vZGUgaXMgYSBMaXN0SXRlbU5vZGUgYW5kIGhhcyBhIExpc3ROb2RlIGFzIGEgY2hpbGQuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGEgTGlzdEl0ZW1Ob2RlIGFuZCBoYXMgYSBMaXN0Tm9kZSBjaGlsZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc05lc3RlZExpc3ROb2RlKG5vZGUpIHtcbiAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShub2RlKSAmJiAkaXNMaXN0Tm9kZShub2RlLmdldEZpcnN0Q2hpbGQoKSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBkZWVwbHkgbmVzdGVkIExpc3ROb2RlIG9yIExpc3RJdGVtTm9kZSBhbmQgdHJhdmVyc2VzIHVwIHRoZSBicmFuY2ggdG8gZGVsZXRlIHRoZSBmaXJzdFxuICogYW5jZXN0cmFsIExpc3ROb2RlICh3aGljaCBjb3VsZCBiZSB0aGUgcm9vdCBMaXN0Tm9kZSkgb3IgTGlzdEl0ZW1Ob2RlIHdpdGggc2libGluZ3MsIGVzc2VudGlhbGx5XG4gKiBicmluZ2luZyB0aGUgZGVlcGx5IG5lc3RlZCBub2RlIHVwIHRoZSBicmFuY2ggb25jZS4gV291bGQgcmVtb3ZlIHN1Ymxpc3QgaWYgaXQgaGFzIHNpYmxpbmdzLlxuICogU2hvdWxkIG5vdCBicmVhayBMaXN0SXRlbSAtPiBMaXN0IC0+IExpc3RJdGVtIGNoYWluIGFzIGVtcHR5IExpc3QvSXRlbU5vZGVzIHNob3VsZCBiZSByZW1vdmVkIG9uIC5yZW1vdmUoKS5cbiAqIEBwYXJhbSBzdWJsaXN0IC0gVGhlIG5lc3RlZCBMaXN0Tm9kZSBvciBMaXN0SXRlbU5vZGUgdG8gYmUgYnJvdWdodCB1cCB0aGUgYnJhbmNoLlxuICovXG5mdW5jdGlvbiAkcmVtb3ZlSGlnaGVzdEVtcHR5TGlzdFBhcmVudChzdWJsaXN0KSB7XG4gIC8vIE5vZGVzIG1heSBiZSByZXBlYXRlZGx5IGluZGVudGVkLCB0byBjcmVhdGUgZGVlcGx5IG5lc3RlZCBsaXN0cyB0aGF0IGVhY2hcbiAgLy8gY29udGFpbiBqdXN0IG9uZSBidWxsZXQuXG4gIC8vIE91ciBnb2FsIGlzIHRvIHJlbW92ZSB0aGVzZSAoZW1wdHkpIGRlZXBseSBuZXN0ZWQgbGlzdHMuIFRoZSBlYXNpZXN0XG4gIC8vIHdheSB0byBkbyB0aGF0IGlzIGNyYXdsIGJhY2sgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIG5vZGUgdGhhdCBoYXMgc2libGluZ3NcbiAgLy8gKGUuZy4gaXMgYWN0dWFsbHkgcGFydCBvZiB0aGUgbGlzdCBjb250ZW50cykgYW5kIGRlbGV0ZSB0aGF0LCBvciBkZWxldGVcbiAgLy8gdGhlIHJvb3Qgb2YgdGhlIGxpc3QgKGlmIG5vIGxpc3Qgbm9kZXMgaGF2ZSBzaWJsaW5ncy4pXG4gIGxldCBlbXB0eUxpc3RQdHIgPSBzdWJsaXN0O1xuICB3aGlsZSAoZW1wdHlMaXN0UHRyLmdldE5leHRTaWJsaW5nKCkgPT0gbnVsbCAmJiBlbXB0eUxpc3RQdHIuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT0gbnVsbCkge1xuICAgIGNvbnN0IHBhcmVudCA9IGVtcHR5TGlzdFB0ci5nZXRQYXJlbnQoKTtcbiAgICBpZiAocGFyZW50ID09IG51bGwgfHwgISgkaXNMaXN0SXRlbU5vZGUocGFyZW50KSB8fCAkaXNMaXN0Tm9kZShwYXJlbnQpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGVtcHR5TGlzdFB0ciA9IHBhcmVudDtcbiAgfVxuICBlbXB0eUxpc3RQdHIucmVtb3ZlKCk7XG59XG5cbi8qKlxuICogV3JhcHMgYSBub2RlIGludG8gYSBMaXN0SXRlbU5vZGUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIHdyYXBwZWQgaW50byBhIExpc3RJdGVtTm9kZVxuICogQHJldHVybnMgVGhlIExpc3RJdGVtTm9kZSB3aGljaCB0aGUgcGFzc2VkIG5vZGUgaXMgd3JhcHBlZCBpbi5cbiAqL1xuZnVuY3Rpb24gJHdyYXBJbkxpc3RJdGVtKG5vZGUpIHtcbiAgY29uc3QgbGlzdEl0ZW1XcmFwcGVyID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICByZXR1cm4gbGlzdEl0ZW1XcmFwcGVyLmFwcGVuZChub2RlKTtcbn1cblxuZnVuY3Rpb24gJGlzU2VsZWN0aW5nRW1wdHlMaXN0SXRlbShhbmNob3JOb2RlLCBub2Rlcykge1xuICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKGFuY2hvck5vZGUpICYmIChub2Rlcy5sZW5ndGggPT09IDAgfHwgbm9kZXMubGVuZ3RoID09PSAxICYmIGFuY2hvck5vZGUuaXMobm9kZXNbMF0pICYmIGFuY2hvck5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApO1xufVxuXG4vKipcbiAqIEluc2VydHMgYSBuZXcgTGlzdE5vZGUuIElmIHRoZSBzZWxlY3Rpb24ncyBhbmNob3Igbm9kZSBpcyBhbiBlbXB0eSBMaXN0SXRlbU5vZGUgYW5kIGlzIGEgY2hpbGQgb2ZcbiAqIHRoZSByb290L3NoYWRvdyByb290LCBpdCB3aWxsIHJlcGxhY2UgdGhlIExpc3RJdGVtTm9kZSB3aXRoIGEgTGlzdE5vZGUgYW5kIHRoZSBvbGQgTGlzdEl0ZW1Ob2RlLlxuICogT3RoZXJ3aXNlIGl0IHdpbGwgcmVwbGFjZSBpdHMgcGFyZW50IHdpdGggYSBuZXcgTGlzdE5vZGUgYW5kIHJlLWluc2VydCB0aGUgTGlzdEl0ZW1Ob2RlIGFuZCBhbnkgcHJldmlvdXMgY2hpbGRyZW4uXG4gKiBJZiB0aGUgc2VsZWN0aW9uJ3MgYW5jaG9yIG5vZGUgaXMgbm90IGFuIGVtcHR5IExpc3RJdGVtTm9kZSwgaXQgd2lsbCBhZGQgYSBuZXcgTGlzdE5vZGUgb3IgbWVyZ2UgYW4gZXhpc3RpbmcgTGlzdE5vZGUsXG4gKiB1bmxlc3MgdGhlIHRoZSBub2RlIGlzIGEgbGVhZiBub2RlLCBpbiB3aGljaCBjYXNlIGl0IHdpbGwgYXR0ZW1wdCB0byBmaW5kIGEgTGlzdE5vZGUgdXAgdGhlIGJyYW5jaCBhbmQgcmVwbGFjZSBpdCB3aXRoXG4gKiBhIG5ldyBMaXN0Tm9kZSwgb3IgY3JlYXRlIGEgbmV3IExpc3ROb2RlIGF0IHRoZSBuZWFyZXN0IHJvb3Qvc2hhZG93IHJvb3QuXG4gKiBAcGFyYW0gbGlzdFR5cGUgLSBUaGUgdHlwZSBvZiBsaXN0LCBcIm51bWJlclwiIHwgXCJidWxsZXRcIiB8IFwiY2hlY2tcIi5cbiAqL1xuZnVuY3Rpb24gJGluc2VydExpc3QobGlzdFR5cGUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgbGV0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gICAgICBpZiAoIShhbmNob3JBbmRGb2N1cyAhPT0gbnVsbCkpIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBpbnNlcnRMaXN0OiBhbmNob3Igc2hvdWxkIGJlIGRlZmluZWRgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFthbmNob3JdID0gYW5jaG9yQW5kRm9jdXM7XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGFuY2hvck5vZGVQYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IGFuY2hvck5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICAgIG5vZGVzID0gZmlyc3RDaGlsZC5zZWxlY3RTdGFydCgpLmdldE5vZGVzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICAgICBhbmNob3JOb2RlLmFwcGVuZChwYXJhZ3JhcGgpO1xuICAgICAgICAgIG5vZGVzID0gcGFyYWdyYXBoLnNlbGVjdCgpLmdldE5vZGVzKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoJGlzU2VsZWN0aW5nRW1wdHlMaXN0SXRlbShhbmNob3JOb2RlLCBub2RlcykpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSk7XG4gICAgICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KGFuY2hvck5vZGVQYXJlbnQpKSB7XG4gICAgICAgICAgYW5jaG9yTm9kZS5yZXBsYWNlKGxpc3QpO1xuICAgICAgICAgIGNvbnN0IGxpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgICAgICAgbGlzdEl0ZW0uc2V0Rm9ybWF0KGFuY2hvck5vZGUuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICAgICAgICAgIGxpc3RJdGVtLnNldEluZGVudChhbmNob3JOb2RlLmdldEluZGVudCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGlzdC5hcHBlbmQobGlzdEl0ZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKCRpc0xpc3RJdGVtTm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGFuY2hvck5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgICAgIGFwcGVuZChsaXN0LCBwYXJlbnQuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICAgICAgcGFyZW50LnJlcGxhY2UobGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoYW5kbGVkID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmlzRW1wdHkoKSAmJiAhJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpICYmICFoYW5kbGVkLmhhcyhub2RlLmdldEtleSgpKSkge1xuICAgICAgICAkY3JlYXRlTGlzdE9yTWVyZ2Uobm9kZSwgbGlzdFR5cGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBwYXJlbnQgPSAkaXNMZWFmTm9kZShub2RlKSA/IG5vZGUuZ2V0UGFyZW50KCkgOiAkaXNMaXN0SXRlbU5vZGUobm9kZSkgJiYgbm9kZS5pc0VtcHR5KCkgPyBub2RlIDogbnVsbDtcbiAgICAgIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBwYXJlbnRLZXkgPSBwYXJlbnQuZ2V0S2V5KCk7XG4gICAgICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgICAgaWYgKCFoYW5kbGVkLmhhcyhwYXJlbnRLZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdMaXN0Tm9kZSA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSk7XG4gICAgICAgICAgICBhcHBlbmQobmV3TGlzdE5vZGUsIHBhcmVudC5nZXRDaGlsZHJlbigpKTtcbiAgICAgICAgICAgIHBhcmVudC5yZXBsYWNlKG5ld0xpc3ROb2RlKTtcbiAgICAgICAgICAgIGhhbmRsZWQuYWRkKHBhcmVudEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG5leHRQYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgICAgICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QobmV4dFBhcmVudCkgJiYgIWhhbmRsZWQuaGFzKHBhcmVudEtleSkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQuYWRkKHBhcmVudEtleSk7XG4gICAgICAgICAgICAkY3JlYXRlTGlzdE9yTWVyZ2UocGFyZW50LCBsaXN0VHlwZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50ID0gbmV4dFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXBwZW5kKG5vZGUsIG5vZGVzVG9BcHBlbmQpIHtcbiAgbm9kZS5zcGxpY2Uobm9kZS5nZXRDaGlsZHJlblNpemUoKSwgMCwgbm9kZXNUb0FwcGVuZCk7XG59XG5mdW5jdGlvbiAkY3JlYXRlTGlzdE9yTWVyZ2Uobm9kZSwgbGlzdFR5cGUpIHtcbiAgaWYgKCRpc0xpc3ROb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgY29uc3QgcHJldmlvdXNTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgY29uc3QgbmV4dFNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gIGNvbnN0IGxpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICBhcHBlbmQobGlzdEl0ZW0sIG5vZGUuZ2V0Q2hpbGRyZW4oKSk7XG4gIGxldCB0YXJnZXRMaXN0O1xuICBpZiAoJGlzTGlzdE5vZGUocHJldmlvdXNTaWJsaW5nKSAmJiBsaXN0VHlwZSA9PT0gcHJldmlvdXNTaWJsaW5nLmdldExpc3RUeXBlKCkpIHtcbiAgICBwcmV2aW91c1NpYmxpbmcuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICAvLyBpZiB0aGUgc2FtZSB0eXBlIG9mIGxpc3QgaXMgb24gYm90aCBzaWRlcywgbWVyZ2UgdGhlbS5cbiAgICBpZiAoJGlzTGlzdE5vZGUobmV4dFNpYmxpbmcpICYmIGxpc3RUeXBlID09PSBuZXh0U2libGluZy5nZXRMaXN0VHlwZSgpKSB7XG4gICAgICBhcHBlbmQocHJldmlvdXNTaWJsaW5nLCBuZXh0U2libGluZy5nZXRDaGlsZHJlbigpKTtcbiAgICAgIG5leHRTaWJsaW5nLnJlbW92ZSgpO1xuICAgIH1cbiAgICB0YXJnZXRMaXN0ID0gcHJldmlvdXNTaWJsaW5nO1xuICB9IGVsc2UgaWYgKCRpc0xpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBsaXN0VHlwZSA9PT0gbmV4dFNpYmxpbmcuZ2V0TGlzdFR5cGUoKSkge1xuICAgIG5leHRTaWJsaW5nLmdldEZpcnN0Q2hpbGRPclRocm93KCkuaW5zZXJ0QmVmb3JlKGxpc3RJdGVtKTtcbiAgICB0YXJnZXRMaXN0ID0gbmV4dFNpYmxpbmc7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSk7XG4gICAgbGlzdC5hcHBlbmQobGlzdEl0ZW0pO1xuICAgIG5vZGUucmVwbGFjZShsaXN0KTtcbiAgICB0YXJnZXRMaXN0ID0gbGlzdDtcbiAgfVxuICAvLyBsaXN0SXRlbSBuZWVkcyB0byBiZSBhdHRhY2hlZCB0byByb290IHByaW9yIHRvIHNldHRpbmcgaW5kZW50XG4gIGxpc3RJdGVtLnNldEZvcm1hdChub2RlLmdldEZvcm1hdFR5cGUoKSk7XG4gIGxpc3RJdGVtLnNldEluZGVudChub2RlLmdldEluZGVudCgpKTtcbiAgbm9kZS5yZW1vdmUoKTtcbiAgcmV0dXJuIHRhcmdldExpc3Q7XG59XG5cbi8qKlxuICogQSByZWN1cnNpdmUgZnVuY3Rpb24gdGhhdCBnb2VzIHRocm91Z2ggZWFjaCBsaXN0IGFuZCB0aGVpciBjaGlsZHJlbiwgaW5jbHVkaW5nIG5lc3RlZCBsaXN0cyxcbiAqIGFwcGVuZGluZyBsaXN0MiBjaGlsZHJlbiBhZnRlciBsaXN0MSBjaGlsZHJlbiBhbmQgdXBkYXRpbmcgTGlzdEl0ZW1Ob2RlIHZhbHVlcy5cbiAqIEBwYXJhbSBsaXN0MSAtIFRoZSBmaXJzdCBsaXN0IHRvIGJlIG1lcmdlZC5cbiAqIEBwYXJhbSBsaXN0MiAtIFRoZSBzZWNvbmQgbGlzdCB0byBiZSBtZXJnZWQuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTGlzdHMobGlzdDEsIGxpc3QyKSB7XG4gIGNvbnN0IGxpc3RJdGVtMSA9IGxpc3QxLmdldExhc3RDaGlsZCgpO1xuICBjb25zdCBsaXN0SXRlbTIgPSBsaXN0Mi5nZXRGaXJzdENoaWxkKCk7XG4gIGlmIChsaXN0SXRlbTEgJiYgbGlzdEl0ZW0yICYmIGlzTmVzdGVkTGlzdE5vZGUobGlzdEl0ZW0xKSAmJiBpc05lc3RlZExpc3ROb2RlKGxpc3RJdGVtMikpIHtcbiAgICBtZXJnZUxpc3RzKGxpc3RJdGVtMS5nZXRGaXJzdENoaWxkKCksIGxpc3RJdGVtMi5nZXRGaXJzdENoaWxkKCkpO1xuICAgIGxpc3RJdGVtMi5yZW1vdmUoKTtcbiAgfVxuICBjb25zdCB0b01lcmdlID0gbGlzdDIuZ2V0Q2hpbGRyZW4oKTtcbiAgaWYgKHRvTWVyZ2UubGVuZ3RoID4gMCkge1xuICAgIGxpc3QxLmFwcGVuZCguLi50b01lcmdlKTtcbiAgfVxuICBsaXN0Mi5yZW1vdmUoKTtcbn1cblxuLyoqXG4gKiBTZWFyY2hlcyBmb3IgdGhlIG5lYXJlc3QgYW5jZXN0cmFsIExpc3ROb2RlIGFuZCByZW1vdmVzIGl0LiBJZiBzZWxlY3Rpb24gaXMgYW4gZW1wdHkgTGlzdEl0ZW1Ob2RlXG4gKiBpdCB3aWxsIHJlbW92ZSB0aGUgd2hvbGUgbGlzdCwgaW5jbHVkaW5nIHRoZSBMaXN0SXRlbU5vZGUuIEZvciBlYWNoIExpc3RJdGVtTm9kZSBpbiB0aGUgTGlzdE5vZGUsXG4gKiByZW1vdmVMaXN0IHdpbGwgYWxzbyBnZW5lcmF0ZSBuZXcgUGFyYWdyYXBoTm9kZXMgaW4gdGhlIHJlbW92ZWQgTGlzdE5vZGUncyBwbGFjZS4gQW55IGNoaWxkIG5vZGVcbiAqIGluc2lkZSBhIExpc3RJdGVtTm9kZSB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBuZXcgUGFyYWdyYXBoTm9kZXMuXG4gKi9cbmZ1bmN0aW9uICRyZW1vdmVMaXN0KCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY29uc3QgbGlzdE5vZGVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGlmICgkaXNTZWxlY3RpbmdFbXB0eUxpc3RJdGVtKGFuY2hvck5vZGUsIG5vZGVzKSkge1xuICAgICAgbGlzdE5vZGVzLmFkZCgkZ2V0VG9wTGlzdE5vZGUoYW5jaG9yTm9kZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKCRpc0xlYWZOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgbGlzdEl0ZW1Ob2RlID0gJGdldE5lYXJlc3ROb2RlT2ZUeXBlKG5vZGUsIExpc3RJdGVtTm9kZSk7XG4gICAgICAgICAgaWYgKGxpc3RJdGVtTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsaXN0Tm9kZXMuYWRkKCRnZXRUb3BMaXN0Tm9kZShsaXN0SXRlbU5vZGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBsaXN0Tm9kZSBvZiBsaXN0Tm9kZXMpIHtcbiAgICAgIGxldCBpbnNlcnRpb25Qb2ludCA9IGxpc3ROb2RlO1xuICAgICAgY29uc3QgbGlzdEl0ZW1zID0gJGdldEFsbExpc3RJdGVtcyhsaXN0Tm9kZSk7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RJdGVtTm9kZSBvZiBsaXN0SXRlbXMpIHtcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKS5zZXRUZXh0U3R5bGUoc2VsZWN0aW9uLnN0eWxlKS5zZXRUZXh0Rm9ybWF0KHNlbGVjdGlvbi5mb3JtYXQpO1xuICAgICAgICBhcHBlbmQocGFyYWdyYXBoLCBsaXN0SXRlbU5vZGUuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICAgIGluc2VydGlvblBvaW50Lmluc2VydEFmdGVyKHBhcmFncmFwaCk7XG4gICAgICAgIGluc2VydGlvblBvaW50ID0gcGFyYWdyYXBoO1xuXG4gICAgICAgIC8vIFdoZW4gdGhlIGFuY2hvciBhbmQgZm9jdXMgZmFsbCBvbiB0aGUgdGV4dE5vZGVcbiAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSB0byBjaGFuZ2UgdGhlIHNlbGVjdGlvbiBiZWNhdXNlIHRoZSB0ZXh0Tm9kZSB3aWxsIGJlIGFwcGVuZGVkIHRvXG4gICAgICAgIC8vIHRoZSBuZXdseSBnZW5lcmF0ZWQgcGFyYWdyYXBoLlxuICAgICAgICAvLyBXaGVuIHNlbGVjdGlvbiBpcyBpbiBlbXB0eSBuZXN0ZWQgbGlzdCBpdGVtLCBzZWxlY3Rpb24gaXMgYWN0dWFsbHkgb24gdGhlIGxpc3RJdGVtTm9kZS5cbiAgICAgICAgLy8gV2hlbiB0aGUgY29ycmVzcG9uZGluZyBsaXN0SXRlbU5vZGUgaXMgZGVsZXRlZCBhbmQgcmVwbGFjZWQgYnkgdGhlIG5ld2x5IGdlbmVyYXRlZCBwYXJhZ3JhcGhcbiAgICAgICAgLy8gd2Ugc2hvdWxkIG1hbnVhbGx5IHNldCB0aGUgc2VsZWN0aW9uJ3MgZm9jdXMgYW5kIGFuY2hvciB0byB0aGUgbmV3bHkgZ2VuZXJhdGVkIHBhcmFncmFwaC5cbiAgICAgICAgaWYgKGxpc3RJdGVtTm9kZS5fX2tleSA9PT0gc2VsZWN0aW9uLmFuY2hvci5rZXkpIHtcbiAgICAgICAgICAkc2V0UG9pbnRGcm9tQ2FyZXQoc2VsZWN0aW9uLmFuY2hvciwgJG5vcm1hbGl6ZUNhcmV0KCRnZXRDaGlsZENhcmV0KHBhcmFncmFwaCwgJ25leHQnKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0SXRlbU5vZGUuX19rZXkgPT09IHNlbGVjdGlvbi5mb2N1cy5rZXkpIHtcbiAgICAgICAgICAkc2V0UG9pbnRGcm9tQ2FyZXQoc2VsZWN0aW9uLmZvY3VzLCAkbm9ybWFsaXplQ2FyZXQoJGdldENoaWxkQ2FyZXQocGFyYWdyYXBoLCAnbmV4dCcpKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdEl0ZW1Ob2RlLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgbGlzdE5vZGUucmVtb3ZlKCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGFrZXMgdGhlIHZhbHVlIG9mIGEgY2hpbGQgTGlzdEl0ZW1Ob2RlIGFuZCBtYWtlcyBpdCB0aGUgdmFsdWUgdGhlIExpc3RJdGVtTm9kZVxuICogc2hvdWxkIGJlIGlmIGl0IGlzbid0IGFscmVhZHkuIEFsc28gZW5zdXJlcyB0aGF0IGNoZWNrZWQgaXMgdW5kZWZpbmVkIGlmIHRoZVxuICogcGFyZW50IGRvZXMgbm90IGhhdmUgYSBsaXN0IHR5cGUgb2YgJ2NoZWNrJy5cbiAqIEBwYXJhbSBsaXN0IC0gVGhlIGxpc3Qgd2hvc2UgY2hpbGRyZW4gYXJlIHVwZGF0ZWQuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShsaXN0KSB7XG4gIGNvbnN0IGlzTm90Q2hlY2tsaXN0ID0gbGlzdC5nZXRMaXN0VHlwZSgpICE9PSAnY2hlY2snO1xuICBsZXQgdmFsdWUgPSBsaXN0LmdldFN0YXJ0KCk7XG4gIGZvciAoY29uc3QgY2hpbGQgb2YgbGlzdC5nZXRDaGlsZHJlbigpKSB7XG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShjaGlsZCkpIHtcbiAgICAgIGlmIChjaGlsZC5nZXRWYWx1ZSgpICE9PSB2YWx1ZSkge1xuICAgICAgICBjaGlsZC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNOb3RDaGVja2xpc3QgJiYgY2hpbGQuZ2V0TGF0ZXN0KCkuX19jaGVja2VkICE9IG51bGwpIHtcbiAgICAgICAgY2hpbGQuc2V0Q2hlY2tlZCh1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgaWYgKCEkaXNMaXN0Tm9kZShjaGlsZC5nZXRGaXJzdENoaWxkKCkpKSB7XG4gICAgICAgIHZhbHVlKys7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdGhlIG5leHQgc2libGluZyBsaXN0IGlmIHNhbWUgdHlwZS5cbiAqIDx1bD4gd2lsbCBtZXJnZSB3aXRoIDx1bD4sIGJ1dCBOT1QgPHVsPiB3aXRoIDxvbD4uXG4gKiBAcGFyYW0gbGlzdCAtIFRoZSBsaXN0IHdob3NlIG5leHQgc2libGluZyBzaG91bGQgYmUgcG90ZW50aWFsbHkgbWVyZ2VkXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTmV4dFNpYmxpbmdMaXN0SWZTYW1lVHlwZShsaXN0KSB7XG4gIGNvbnN0IG5leHRTaWJsaW5nID0gbGlzdC5nZXROZXh0U2libGluZygpO1xuICBpZiAoJGlzTGlzdE5vZGUobmV4dFNpYmxpbmcpICYmIGxpc3QuZ2V0TGlzdFR5cGUoKSA9PT0gbmV4dFNpYmxpbmcuZ2V0TGlzdFR5cGUoKSkge1xuICAgIG1lcmdlTGlzdHMobGlzdCwgbmV4dFNpYmxpbmcpO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBhbiBlbXB0eSBMaXN0Tm9kZS9MaXN0SXRlbU5vZGUgY2hhaW4gYXQgbGlzdEl0ZW1Ob2RlLCBzbyBhcyB0b1xuICogY3JlYXRlIGFuIGluZGVudCBlZmZlY3QuIFdvbid0IGluZGVudCBMaXN0SXRlbU5vZGVzIHRoYXQgaGF2ZSBhIExpc3ROb2RlIGFzXG4gKiBhIGNoaWxkLCBidXQgZG9lcyBtZXJnZSBzaWJsaW5nIExpc3RJdGVtTm9kZXMgaWYgb25lIGhhcyBhIG5lc3RlZCBMaXN0Tm9kZS5cbiAqIEBwYXJhbSBsaXN0SXRlbU5vZGUgLSBUaGUgTGlzdEl0ZW1Ob2RlIHRvIGJlIGluZGVudGVkLlxuICovXG5mdW5jdGlvbiAkaGFuZGxlSW5kZW50KGxpc3RJdGVtTm9kZSkge1xuICAvLyBnbyB0aHJvdWdoIGVhY2ggbm9kZSBhbmQgZGVjaWRlIHdoZXJlIHRvIG1vdmUgaXQuXG4gIGNvbnN0IHJlbW92ZWQgPSBuZXcgU2V0KCk7XG4gIGlmIChpc05lc3RlZExpc3ROb2RlKGxpc3RJdGVtTm9kZSkgfHwgcmVtb3ZlZC5oYXMobGlzdEl0ZW1Ob2RlLmdldEtleSgpKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwYXJlbnQgPSBsaXN0SXRlbU5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgLy8gV2UgY2FuIGNhc3QgYm90aCBvZiB0aGUgYmVsb3cgYGlzTmVzdGVkTGlzdE5vZGVgIG9ubHkgcmV0dXJucyBhIGJvb2xlYW4gdHlwZSBpbnN0ZWFkIG9mIGEgdXNlci1kZWZpbmVkIHR5cGUgZ3VhcmRzXG4gIGNvbnN0IG5leHRTaWJsaW5nID0gbGlzdEl0ZW1Ob2RlLmdldE5leHRTaWJsaW5nKCk7XG4gIGNvbnN0IHByZXZpb3VzU2libGluZyA9IGxpc3RJdGVtTm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgLy8gaWYgdGhlcmUgYXJlIG5lc3RlZCBsaXN0cyBvbiBlaXRoZXIgc2lkZSwgbWVyZ2UgdGhlbSBhbGwgdG9nZXRoZXIuXG5cbiAgaWYgKGlzTmVzdGVkTGlzdE5vZGUobmV4dFNpYmxpbmcpICYmIGlzTmVzdGVkTGlzdE5vZGUocHJldmlvdXNTaWJsaW5nKSkge1xuICAgIGNvbnN0IGlubmVyTGlzdCA9IHByZXZpb3VzU2libGluZy5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKGlubmVyTGlzdCkpIHtcbiAgICAgIGlubmVyTGlzdC5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIGNvbnN0IG5leHRJbm5lckxpc3QgPSBuZXh0U2libGluZy5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBpZiAoJGlzTGlzdE5vZGUobmV4dElubmVyTGlzdCkpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBuZXh0SW5uZXJMaXN0LmdldENoaWxkcmVuKCk7XG4gICAgICAgIGFwcGVuZChpbm5lckxpc3QsIGNoaWxkcmVuKTtcbiAgICAgICAgbmV4dFNpYmxpbmcucmVtb3ZlKCk7XG4gICAgICAgIHJlbW92ZWQuYWRkKG5leHRTaWJsaW5nLmdldEtleSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNOZXN0ZWRMaXN0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAvLyBpZiB0aGUgTGlzdEl0ZW1Ob2RlIGlzIG5leHQgdG8gYSBuZXN0ZWQgTGlzdE5vZGUsIG1lcmdlIHRoZW1cbiAgICBjb25zdCBpbm5lckxpc3QgPSBuZXh0U2libGluZy5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKGlubmVyTGlzdCkpIHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBpbm5lckxpc3QuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKGZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNOZXN0ZWRMaXN0Tm9kZShwcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgY29uc3QgaW5uZXJMaXN0ID0gcHJldmlvdXNTaWJsaW5nLmdldEZpcnN0Q2hpbGQoKTtcbiAgICBpZiAoJGlzTGlzdE5vZGUoaW5uZXJMaXN0KSkge1xuICAgICAgaW5uZXJMaXN0LmFwcGVuZChsaXN0SXRlbU5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlcndpc2UsIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IG5lc3RlZCBMaXN0Tm9kZVxuXG4gICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgIGNvbnN0IG5ld0xpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpLnNldFRleHRGb3JtYXQobGlzdEl0ZW1Ob2RlLmdldFRleHRGb3JtYXQoKSkuc2V0VGV4dFN0eWxlKGxpc3RJdGVtTm9kZS5nZXRUZXh0U3R5bGUoKSk7XG4gICAgICBjb25zdCBuZXdMaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKHBhcmVudC5nZXRMaXN0VHlwZSgpKS5zZXRUZXh0Rm9ybWF0KHBhcmVudC5nZXRUZXh0Rm9ybWF0KCkpLnNldFRleHRTdHlsZShwYXJlbnQuZ2V0VGV4dFN0eWxlKCkpO1xuICAgICAgbmV3TGlzdEl0ZW0uYXBwZW5kKG5ld0xpc3QpO1xuICAgICAgbmV3TGlzdC5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgcHJldmlvdXNTaWJsaW5nLmluc2VydEFmdGVyKG5ld0xpc3RJdGVtKTtcbiAgICAgIH0gZWxzZSBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgbmV4dFNpYmxpbmcuaW5zZXJ0QmVmb3JlKG5ld0xpc3RJdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudC5hcHBlbmQobmV3TGlzdEl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYW4gaW5kZW50IGJ5IHJlbW92aW5nIGFuIGVtcHR5IExpc3ROb2RlL0xpc3RJdGVtTm9kZSBjaGFpbi4gQW4gaW5kZW50ZWQgTGlzdEl0ZW1Ob2RlXG4gKiBoYXMgYSBncmVhdCBncmFuZHBhcmVudCBub2RlIG9mIHR5cGUgTGlzdE5vZGUsIHdoaWNoIGlzIHdoZXJlIHRoZSBMaXN0SXRlbU5vZGUgd2lsbCByZXNpZGVcbiAqIHdpdGhpbiBhcyBhIGNoaWxkLlxuICogQHBhcmFtIGxpc3RJdGVtTm9kZSAtIFRoZSBMaXN0SXRlbU5vZGUgdG8gcmVtb3ZlIHRoZSBpbmRlbnQgKG91dGRlbnQpLlxuICovXG5mdW5jdGlvbiAkaGFuZGxlT3V0ZGVudChsaXN0SXRlbU5vZGUpIHtcbiAgLy8gZ28gdGhyb3VnaCBlYWNoIG5vZGUgYW5kIGRlY2lkZSB3aGVyZSB0byBtb3ZlIGl0LlxuXG4gIGlmIChpc05lc3RlZExpc3ROb2RlKGxpc3RJdGVtTm9kZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGFyZW50TGlzdCA9IGxpc3RJdGVtTm9kZS5nZXRQYXJlbnQoKTtcbiAgY29uc3QgZ3JhbmRwYXJlbnRMaXN0SXRlbSA9IHBhcmVudExpc3QgPyBwYXJlbnRMaXN0LmdldFBhcmVudCgpIDogdW5kZWZpbmVkO1xuICBjb25zdCBncmVhdEdyYW5kcGFyZW50TGlzdCA9IGdyYW5kcGFyZW50TGlzdEl0ZW0gPyBncmFuZHBhcmVudExpc3RJdGVtLmdldFBhcmVudCgpIDogdW5kZWZpbmVkO1xuICAvLyBJZiBpdCBkb2Vzbid0IGhhdmUgdGhlc2UgYW5jZXN0b3JzLCBpdCdzIG5vdCBpbmRlbnRlZC5cblxuICBpZiAoJGlzTGlzdE5vZGUoZ3JlYXRHcmFuZHBhcmVudExpc3QpICYmICRpc0xpc3RJdGVtTm9kZShncmFuZHBhcmVudExpc3RJdGVtKSAmJiAkaXNMaXN0Tm9kZShwYXJlbnRMaXN0KSkge1xuICAgIC8vIGlmIGl0J3MgdGhlIGZpcnN0IGNoaWxkIGluIGl0J3MgcGFyZW50IGxpc3QsIGluc2VydCBpdCBpbnRvIHRoZVxuICAgIC8vIGdyZWF0IGdyYW5kcGFyZW50IGxpc3QgYmVmb3JlIHRoZSBncmFuZHBhcmVudFxuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJlbnRMaXN0ID8gcGFyZW50TGlzdC5nZXRGaXJzdENoaWxkKCkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbGFzdENoaWxkID0gcGFyZW50TGlzdCA/IHBhcmVudExpc3QuZ2V0TGFzdENoaWxkKCkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGxpc3RJdGVtTm9kZS5pcyhmaXJzdENoaWxkKSkge1xuICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5pbnNlcnRCZWZvcmUobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIGlmIChwYXJlbnRMaXN0LmlzRW1wdHkoKSkge1xuICAgICAgICBncmFuZHBhcmVudExpc3RJdGVtLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgLy8gaWYgaXQncyB0aGUgbGFzdCBjaGlsZCBpbiBpdCdzIHBhcmVudCBsaXN0LCBpbnNlcnQgaXQgaW50byB0aGVcbiAgICAgIC8vIGdyZWF0IGdyYW5kcGFyZW50IGxpc3QgYWZ0ZXIgdGhlIGdyYW5kcGFyZW50LlxuICAgIH0gZWxzZSBpZiAobGlzdEl0ZW1Ob2RlLmlzKGxhc3RDaGlsZCkpIHtcbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0uaW5zZXJ0QWZ0ZXIobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIGlmIChwYXJlbnRMaXN0LmlzRW1wdHkoKSkge1xuICAgICAgICBncmFuZHBhcmVudExpc3RJdGVtLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UsIHdlIG5lZWQgdG8gc3BsaXQgdGhlIHNpYmxpbmdzIGludG8gdHdvIG5ldyBuZXN0ZWQgbGlzdHNcbiAgICAgIGNvbnN0IGxpc3RUeXBlID0gcGFyZW50TGlzdC5nZXRMaXN0VHlwZSgpO1xuICAgICAgY29uc3QgcHJldmlvdXNTaWJsaW5nc0xpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgICAgY29uc3QgcHJldmlvdXNTaWJsaW5nc0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUpO1xuICAgICAgcHJldmlvdXNTaWJsaW5nc0xpc3RJdGVtLmFwcGVuZChwcmV2aW91c1NpYmxpbmdzTGlzdCk7XG4gICAgICBsaXN0SXRlbU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5ncygpLmZvckVhY2goc2libGluZyA9PiBwcmV2aW91c1NpYmxpbmdzTGlzdC5hcHBlbmQoc2libGluZykpO1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmdzTGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gICAgICBjb25zdCBuZXh0U2libGluZ3NMaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlKTtcbiAgICAgIG5leHRTaWJsaW5nc0xpc3RJdGVtLmFwcGVuZChuZXh0U2libGluZ3NMaXN0KTtcbiAgICAgIGFwcGVuZChuZXh0U2libGluZ3NMaXN0LCBsaXN0SXRlbU5vZGUuZ2V0TmV4dFNpYmxpbmdzKCkpO1xuICAgICAgLy8gcHV0IHRoZSBzaWJsaW5nIG5lc3RlZCBsaXN0cyBvbiBlaXRoZXIgc2lkZSBvZiB0aGUgZ3JhbmRwYXJlbnQgbGlzdCBpdGVtIGluIHRoZSBncmVhdCBncmFuZHBhcmVudC5cbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0uaW5zZXJ0QmVmb3JlKHByZXZpb3VzU2libGluZ3NMaXN0SXRlbSk7XG4gICAgICBncmFuZHBhcmVudExpc3RJdGVtLmluc2VydEFmdGVyKG5leHRTaWJsaW5nc0xpc3RJdGVtKTtcbiAgICAgIC8vIHJlcGxhY2UgdGhlIGdyYW5kcGFyZW50IGxpc3QgaXRlbSAobm93IGJldHdlZW4gdGhlIHNpYmxpbmdzKSB3aXRoIHRoZSBvdXRkZW50ZWQgbGlzdCBpdGVtLlxuICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5yZXBsYWNlKGxpc3RJdGVtTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gaW5zZXJ0IGEgUGFyYWdyYXBoTm9kZSBhdCBzZWxlY3Rpb24gYW5kIHNlbGVjdHMgdGhlIG5ldyBub2RlLiBUaGUgc2VsZWN0aW9uIG11c3QgY29udGFpbiBhIExpc3RJdGVtTm9kZVxuICogb3IgYSBub2RlIHRoYXQgZG9lcyBub3QgYWxyZWFkeSBjb250YWluIHRleHQuIElmIGl0cyBncmFuZHBhcmVudCBpcyB0aGUgcm9vdC9zaGFkb3cgcm9vdCwgaXQgd2lsbCBnZXQgdGhlIExpc3ROb2RlXG4gKiAod2hpY2ggc2hvdWxkIGJlIHRoZSBwYXJlbnQgbm9kZSkgYW5kIGluc2VydCB0aGUgUGFyYWdyYXBoTm9kZSBhcyBhIHNpYmxpbmcgdG8gdGhlIExpc3ROb2RlLiBJZiB0aGUgTGlzdE5vZGUgaXNcbiAqIG5lc3RlZCBpbiBhIExpc3RJdGVtTm9kZSBpbnN0ZWFkLCBpdCB3aWxsIGFkZCB0aGUgUGFyYWdyYXBoTm9kZSBhZnRlciB0aGUgZ3JhbmRwYXJlbnQgTGlzdEl0ZW1Ob2RlLlxuICogVGhyb3dzIGFuIGludmFyaWFudCBpZiB0aGUgc2VsZWN0aW9uIGlzIG5vdCBhIGNoaWxkIG9mIGEgTGlzdE5vZGUuXG4gKiBAcmV0dXJucyB0cnVlIGlmIGEgUGFyYWdyYXBoTm9kZSB3YXMgaW5zZXJ0ZWQgc3VjY2Vzc2Z1bGx5LCBmYWxzZSBpZiB0aGVyZSBpcyBubyBzZWxlY3Rpb25cbiAqIG9yIHRoZSBzZWxlY3Rpb24gZG9lcyBub3QgY29udGFpbiBhIExpc3RJdGVtTm9kZSBvciB0aGUgbm9kZSBhbHJlYWR5IGhvbGRzIHRleHQuXG4gKi9cbmZ1bmN0aW9uICRoYW5kbGVMaXN0SW5zZXJ0UGFyYWdyYXBoKCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gT25seSBydW4gdGhpcyBjb2RlIG9uIGVtcHR5IGxpc3QgaXRlbXNcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGlmICghJGlzTGlzdEl0ZW1Ob2RlKGFuY2hvcikgfHwgYW5jaG9yLmdldENoaWxkcmVuU2l6ZSgpICE9PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHRvcExpc3ROb2RlID0gJGdldFRvcExpc3ROb2RlKGFuY2hvcik7XG4gIGNvbnN0IHBhcmVudCA9IGFuY2hvci5nZXRQYXJlbnQoKTtcbiAgaWYgKCEkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBBIExpc3RJdGVtTm9kZSBtdXN0IGhhdmUgYSBMaXN0Tm9kZSBmb3IgYSBwYXJlbnQuYCk7XG4gIH1cbiAgY29uc3QgZ3JhbmRwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gIGxldCByZXBsYWNlbWVudE5vZGU7XG4gIGlmICgkaXNSb290T3JTaGFkb3dSb290KGdyYW5kcGFyZW50KSkge1xuICAgIHJlcGxhY2VtZW50Tm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgdG9wTGlzdE5vZGUuaW5zZXJ0QWZ0ZXIocmVwbGFjZW1lbnROb2RlKTtcbiAgfSBlbHNlIGlmICgkaXNMaXN0SXRlbU5vZGUoZ3JhbmRwYXJlbnQpKSB7XG4gICAgcmVwbGFjZW1lbnROb2RlID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgIGdyYW5kcGFyZW50Lmluc2VydEFmdGVyKHJlcGxhY2VtZW50Tm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJlcGxhY2VtZW50Tm9kZS5zZXRUZXh0U3R5bGUoc2VsZWN0aW9uLnN0eWxlKS5zZXRUZXh0Rm9ybWF0KHNlbGVjdGlvbi5mb3JtYXQpLnNlbGVjdCgpO1xuICBjb25zdCBuZXh0U2libGluZ3MgPSBhbmNob3IuZ2V0TmV4dFNpYmxpbmdzKCk7XG4gIGlmIChuZXh0U2libGluZ3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IG5ld0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUocGFyZW50LmdldExpc3RUeXBlKCkpO1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUocmVwbGFjZW1lbnROb2RlKSkge1xuICAgICAgY29uc3QgbmV3TGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gICAgICBuZXdMaXN0SXRlbS5hcHBlbmQobmV3TGlzdCk7XG4gICAgICByZXBsYWNlbWVudE5vZGUuaW5zZXJ0QWZ0ZXIobmV3TGlzdEl0ZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlbWVudE5vZGUuaW5zZXJ0QWZ0ZXIobmV3TGlzdCk7XG4gICAgfVxuICAgIG5ld0xpc3QuYXBwZW5kKC4uLm5leHRTaWJsaW5ncyk7XG4gIH1cblxuICAvLyBEb24ndCBsZWF2ZSBoYW5naW5nIG5lc3RlZCBlbXB0eSBsaXN0c1xuICAkcmVtb3ZlSGlnaGVzdEVtcHR5TGlzdFBhcmVudChhbmNob3IpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc05hbWVzKC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgcnZhbCA9IFtdO1xuICBmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG4gICAgaWYgKGNsYXNzTmFtZSAmJiB0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZm9yIChjb25zdCBbc10gb2YgY2xhc3NOYW1lLm1hdGNoQWxsKC9cXFMrL2cpKSB7XG4gICAgICAgIHJ2YWwucHVzaChzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbmZ1bmN0aW9uIGFwcGx5TWFya2VyU3R5bGVzKGRvbSwgbm9kZSwgcHJldk5vZGUpIHtcbiAgY29uc3Qgc3R5bGVzID0gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKG5vZGUuX190ZXh0U3R5bGUpO1xuICBmb3IgKGNvbnN0IGsgaW4gc3R5bGVzKSB7XG4gICAgZG9tLnN0eWxlLnNldFByb3BlcnR5KGAtLWxpc3RpdGVtLW1hcmtlci0ke2t9YCwgc3R5bGVzW2tdKTtcbiAgfVxuICBpZiAocHJldk5vZGUpIHtcbiAgICBmb3IgKGNvbnN0IGsgaW4gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKHByZXZOb2RlLl9fdGV4dFN0eWxlKSkge1xuICAgICAgaWYgKCEoayBpbiBzdHlsZXMpKSB7XG4gICAgICAgIGRvbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShgLS1saXN0aXRlbS1tYXJrZXItJHtrfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgTGlzdEl0ZW1Ob2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgJGNvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcoJ2xpc3RpdGVtJywge1xuICAgICAgJHRyYW5zZm9ybTogbm9kZSA9PiB7XG4gICAgICAgIGlmIChub2RlLl9fY2hlY2tlZCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgICAgaWYgKHBhcmVudC5nZXRMaXN0VHlwZSgpICE9PSAnY2hlY2snICYmIG5vZGUuZ2V0Q2hlY2tlZCgpICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0Q2hlY2tlZCh1bmRlZmluZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV4dGVuZHM6IEVsZW1lbnROb2RlLFxuICAgICAgaW1wb3J0RE9NOiBidWlsZEltcG9ydE1hcCh7XG4gICAgICAgIGxpOiAoKSA9PiAoe1xuICAgICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0TGlzdEl0ZW1FbGVtZW50LFxuICAgICAgICAgIHByaW9yaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIGNvbnN0cnVjdG9yKHZhbHVlID0gMSwgY2hlY2tlZCA9IHVuZGVmaW5lZCwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gMSA6IHZhbHVlO1xuICAgIHRoaXMuX19jaGVja2VkID0gY2hlY2tlZDtcbiAgfVxuICBhZnRlckNsb25lRnJvbShwcmV2Tm9kZSkge1xuICAgIHN1cGVyLmFmdGVyQ2xvbmVGcm9tKHByZXZOb2RlKTtcbiAgICB0aGlzLl9fdmFsdWUgPSBwcmV2Tm9kZS5fX3ZhbHVlO1xuICAgIHRoaXMuX19jaGVja2VkID0gcHJldk5vZGUuX19jaGVja2VkO1xuICB9XG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICB0aGlzLnVwZGF0ZUxpc3RJdGVtRE9NKG51bGwsIGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgdXBkYXRlTGlzdEl0ZW1ET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSAmJiBwYXJlbnQuZ2V0TGlzdFR5cGUoKSA9PT0gJ2NoZWNrJykge1xuICAgICAgdXBkYXRlTGlzdEl0ZW1DaGVja2VkKGRvbSwgdGhpcywgcHJldk5vZGUpO1xuICAgIH1cbiAgICBkb20udmFsdWUgPSB0aGlzLl9fdmFsdWU7XG4gICAgJHNldExpc3RJdGVtVGhlbWVDbGFzc05hbWVzKGRvbSwgY29uZmlnLnRoZW1lLCB0aGlzKTtcbiAgICBjb25zdCBwcmV2U3R5bGUgPSBwcmV2Tm9kZSA/IHByZXZOb2RlLl9fc3R5bGUgOiAnJztcbiAgICBjb25zdCBuZXh0U3R5bGUgPSB0aGlzLl9fc3R5bGU7XG4gICAgaWYgKHByZXZTdHlsZSAhPT0gbmV4dFN0eWxlKSB7XG4gICAgICBpZiAobmV4dFN0eWxlID09PSAnJykge1xuICAgICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBuZXh0U3R5bGU7XG4gICAgICB9XG4gICAgfVxuICAgIGFwcGx5TWFya2VyU3R5bGVzKGRvbSwgdGhpcywgcHJldk5vZGUpO1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gdGhpcyBpcyBhbHdheXMgSFRNTExpc3RJdGVtRWxlbWVudFxuICAgIGNvbnN0IGVsZW1lbnQgPSBkb207XG4gICAgdGhpcy51cGRhdGVMaXN0SXRlbURPTShwcmV2Tm9kZSwgZWxlbWVudCwgY29uZmlnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gc3VwZXIudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpLnNldFZhbHVlKHNlcmlhbGl6ZWROb2RlLnZhbHVlKS5zZXRDaGVja2VkKHNlcmlhbGl6ZWROb2RlLmNoZWNrZWQpO1xuICB9XG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5jcmVhdGVET00oZWRpdG9yLl9jb25maWcpO1xuICAgIGNvbnN0IGZvcm1hdFR5cGUgPSB0aGlzLmdldEZvcm1hdFR5cGUoKTtcbiAgICBpZiAoZm9ybWF0VHlwZSkge1xuICAgICAgZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBmb3JtYXRUeXBlO1xuICAgIH1cbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldERpcmVjdGlvbigpO1xuICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgIGVsZW1lbnQuZGlyID0gZGlyZWN0aW9uO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudFxuICAgIH07XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgY2hlY2tlZDogdGhpcy5nZXRDaGVja2VkKCksXG4gICAgICB2YWx1ZTogdGhpcy5nZXRWYWx1ZSgpXG4gICAgfTtcbiAgfVxuICBhcHBlbmQoLi4ubm9kZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgdGhpcy5jYW5NZXJnZVdpdGgobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgICAgIHRoaXMuYXBwZW5kKC4uLmNoaWxkcmVuKTtcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyLmFwcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVwbGFjZShyZXBsYWNlV2l0aE5vZGUsIGluY2x1ZGVDaGlsZHJlbikge1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUocmVwbGFjZVdpdGhOb2RlKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UocmVwbGFjZVdpdGhOb2RlKTtcbiAgICB9XG4gICAgdGhpcy5zZXRJbmRlbnQoMCk7XG4gICAgY29uc3QgbGlzdCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGlmICghJGlzTGlzdE5vZGUobGlzdCkpIHtcbiAgICAgIHJldHVybiByZXBsYWNlV2l0aE5vZGU7XG4gICAgfVxuICAgIGlmIChsaXN0Ll9fZmlyc3QgPT09IHRoaXMuZ2V0S2V5KCkpIHtcbiAgICAgIGxpc3QuaW5zZXJ0QmVmb3JlKHJlcGxhY2VXaXRoTm9kZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0Ll9fbGFzdCA9PT0gdGhpcy5nZXRLZXkoKSkge1xuICAgICAgbGlzdC5pbnNlcnRBZnRlcihyZXBsYWNlV2l0aE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTcGxpdCB0aGUgbGlzdFxuICAgICAgY29uc3QgbmV3TGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0LmdldExpc3RUeXBlKCkpO1xuICAgICAgbGV0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgICAgd2hpbGUgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgIGNvbnN0IG5vZGVUb0FwcGVuZCA9IG5leHRTaWJsaW5nO1xuICAgICAgICBuZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgIG5ld0xpc3QuYXBwZW5kKG5vZGVUb0FwcGVuZCk7XG4gICAgICB9XG4gICAgICBsaXN0Lmluc2VydEFmdGVyKHJlcGxhY2VXaXRoTm9kZSk7XG4gICAgICByZXBsYWNlV2l0aE5vZGUuaW5zZXJ0QWZ0ZXIobmV3TGlzdCk7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICAgIGlmICghJGlzRWxlbWVudE5vZGUocmVwbGFjZVdpdGhOb2RlKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGluY2x1ZGVDaGlsZHJlbiBzaG91bGQgb25seSBiZSB0cnVlIGZvciBFbGVtZW50Tm9kZXNgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgcmVwbGFjZVdpdGhOb2RlLmFwcGVuZChjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgICBpZiAobGlzdC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkge1xuICAgICAgbGlzdC5yZW1vdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcGxhY2VXaXRoTm9kZTtcbiAgfVxuICBpbnNlcnRBZnRlcihub2RlLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IGxpc3ROb2RlID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgaWYgKCEkaXNMaXN0Tm9kZShsaXN0Tm9kZSkpIHtcbiAgICAgIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBpbnNlcnRBZnRlcjogbGlzdCBub2RlIGlzIG5vdCBwYXJlbnQgb2YgbGlzdCBpdGVtIG5vZGVgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLmluc2VydEFmdGVyKG5vZGUsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIH1cbiAgICBjb25zdCBzaWJsaW5ncyA9IHRoaXMuZ2V0TmV4dFNpYmxpbmdzKCk7XG5cbiAgICAvLyBTcGxpdCB0aGUgbGlzdHMgYW5kIGluc2VydCB0aGUgbm9kZSBpbiBiZXR3ZWVuIHRoZW1cbiAgICBsaXN0Tm9kZS5pbnNlcnRBZnRlcihub2RlLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICBpZiAoc2libGluZ3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBuZXdMaXN0Tm9kZSA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0Tm9kZS5nZXRMaXN0VHlwZSgpKTtcbiAgICAgIHNpYmxpbmdzLmZvckVhY2goc2libGluZyA9PiBuZXdMaXN0Tm9kZS5hcHBlbmQoc2libGluZykpO1xuICAgICAgbm9kZS5pbnNlcnRBZnRlcihuZXdMaXN0Tm9kZSwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHJlbW92ZShwcmVzZXJ2ZUVtcHR5UGFyZW50KSB7XG4gICAgY29uc3QgcHJldlNpYmxpbmcgPSB0aGlzLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgIHN1cGVyLnJlbW92ZShwcmVzZXJ2ZUVtcHR5UGFyZW50KTtcbiAgICBpZiAocHJldlNpYmxpbmcgJiYgbmV4dFNpYmxpbmcgJiYgaXNOZXN0ZWRMaXN0Tm9kZShwcmV2U2libGluZykgJiYgaXNOZXN0ZWRMaXN0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIG1lcmdlTGlzdHMocHJldlNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpLCBuZXh0U2libGluZy5nZXRGaXJzdENoaWxkKCkpO1xuICAgICAgbmV4dFNpYmxpbmcucmVtb3ZlKCk7XG4gICAgfVxuICB9XG4gIGluc2VydE5ld0FmdGVyKF8sIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKS51cGRhdGVGcm9tSlNPTih0aGlzLmV4cG9ydEpTT04oKSkuc2V0Q2hlY2tlZCh0aGlzLmdldENoZWNrZWQoKSA/IGZhbHNlIDogdW5kZWZpbmVkKTtcbiAgICB0aGlzLmluc2VydEFmdGVyKG5ld0VsZW1lbnQsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG4gIGNvbGxhcHNlQXRTdGFydChzZWxlY3Rpb24pIHtcbiAgICBjb25zdCBwYXJhZ3JhcGggPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gcGFyYWdyYXBoLmFwcGVuZChjaGlsZCkpO1xuICAgIGNvbnN0IGxpc3ROb2RlID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgY29uc3QgbGlzdE5vZGVQYXJlbnQgPSBsaXN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgY29uc3QgaXNJbmRlbnRlZCA9ICRpc0xpc3RJdGVtTm9kZShsaXN0Tm9kZVBhcmVudCk7XG4gICAgaWYgKGxpc3ROb2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAxKSB7XG4gICAgICBpZiAoaXNJbmRlbnRlZCkge1xuICAgICAgICAvLyBpZiB0aGUgbGlzdCBub2RlIGlzIG5lc3RlZCwgd2UganVzdCB3YW50IHRvIHJlbW92ZSBpdCxcbiAgICAgICAgLy8gZWZmZWN0aXZlbHkgdW5pbmRlbnRpbmcgaXQuXG4gICAgICAgIGxpc3ROb2RlLnJlbW92ZSgpO1xuICAgICAgICBsaXN0Tm9kZVBhcmVudC5zZWxlY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3ROb2RlLmluc2VydEJlZm9yZShwYXJhZ3JhcGgpO1xuICAgICAgICBsaXN0Tm9kZS5yZW1vdmUoKTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBzZWxlY3Rpb24gb24gdGhlIGxpc3QgaXRlbSwgd2UnbGwgbmVlZCB0byBtb3ZlIGl0XG4gICAgICAgIC8vIHRvIHRoZSBwYXJhZ3JhcGhcbiAgICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgICAgIGNvbnN0IGtleSA9IHBhcmFncmFwaC5nZXRLZXkoKTtcbiAgICAgICAgaWYgKGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgYW5jaG9yLmdldE5vZGUoKS5pcyh0aGlzKSkge1xuICAgICAgICAgIGFuY2hvci5zZXQoa2V5LCBhbmNob3Iub2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb2N1cy50eXBlID09PSAnZWxlbWVudCcgJiYgZm9jdXMuZ2V0Tm9kZSgpLmlzKHRoaXMpKSB7XG4gICAgICAgICAgZm9jdXMuc2V0KGtleSwgZm9jdXMub2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3ROb2RlLmluc2VydEJlZm9yZShwYXJhZ3JhcGgpO1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0VmFsdWUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX192YWx1ZTtcbiAgfVxuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX3ZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0Q2hlY2tlZCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBsZXQgbGlzdFR5cGU7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgICAgbGlzdFR5cGUgPSBwYXJlbnQuZ2V0TGlzdFR5cGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RUeXBlID09PSAnY2hlY2snID8gQm9vbGVhbihzZWxmLl9fY2hlY2tlZCkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgc2V0Q2hlY2tlZChjaGVja2VkKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fY2hlY2tlZCA9IGNoZWNrZWQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgdG9nZ2xlQ2hlY2tlZCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHJldHVybiBzZWxmLnNldENoZWNrZWQoIXNlbGYuX19jaGVja2VkKTtcbiAgfVxuICBnZXRJbmRlbnQoKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHBhcmVudCwgd2UgYXJlIGxpa2VseSBzZXJpYWxpemluZ1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCB8fCAhdGhpcy5pc0F0dGFjaGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faW5kZW50O1xuICAgIH1cbiAgICAvLyBMaXN0SXRlbU5vZGUgc2hvdWxkIGFsd2F5cyBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LlxuICAgIGxldCBsaXN0Tm9kZVBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgbGV0IGluZGVudExldmVsID0gMDtcbiAgICB3aGlsZSAoJGlzTGlzdEl0ZW1Ob2RlKGxpc3ROb2RlUGFyZW50KSkge1xuICAgICAgbGlzdE5vZGVQYXJlbnQgPSBsaXN0Tm9kZVBhcmVudC5nZXRQYXJlbnRPclRocm93KCkuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgaW5kZW50TGV2ZWwrKztcbiAgICB9XG4gICAgcmV0dXJuIGluZGVudExldmVsO1xuICB9XG4gIHNldEluZGVudChpbmRlbnQpIHtcbiAgICBpZiAoISh0eXBlb2YgaW5kZW50ID09PSAnbnVtYmVyJykpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgSW52YWxpZCBpbmRlbnQgdmFsdWUuYCk7XG4gICAgfVxuICAgIGluZGVudCA9IE1hdGguZmxvb3IoaW5kZW50KTtcbiAgICBpZiAoIShpbmRlbnQgPj0gMCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgSW5kZW50IHZhbHVlIG11c3QgYmUgbm9uLW5lZ2F0aXZlLmApO1xuICAgIH1cbiAgICBsZXQgY3VycmVudEluZGVudCA9IHRoaXMuZ2V0SW5kZW50KCk7XG4gICAgd2hpbGUgKGN1cnJlbnRJbmRlbnQgIT09IGluZGVudCkge1xuICAgICAgaWYgKGN1cnJlbnRJbmRlbnQgPCBpbmRlbnQpIHtcbiAgICAgICAgJGhhbmRsZUluZGVudCh0aGlzKTtcbiAgICAgICAgY3VycmVudEluZGVudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGhhbmRsZU91dGRlbnQodGhpcyk7XG4gICAgICAgIGN1cnJlbnRJbmRlbnQtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGRlcHJlY2F0ZWQgQGludGVybmFsICovXG4gIGNhbkluc2VydEFmdGVyKG5vZGUpIHtcbiAgICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpO1xuICB9XG5cbiAgLyoqIEBkZXByZWNhdGVkIEBpbnRlcm5hbCAqL1xuICBjYW5SZXBsYWNlV2l0aChyZXBsYWNlbWVudCkge1xuICAgIHJldHVybiAkaXNMaXN0SXRlbU5vZGUocmVwbGFjZW1lbnQpO1xuICB9XG4gIGNhbk1lcmdlV2l0aChub2RlKSB7XG4gICAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShub2RlKSB8fCAkaXNQYXJhZ3JhcGhOb2RlKG5vZGUpO1xuICB9XG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQsIHNlbGVjdGlvbikge1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgICByZXR1cm4gdGhpcy5pc1BhcmVudE9mKGFuY2hvck5vZGUpICYmIHRoaXMuaXNQYXJlbnRPZihmb2N1c05vZGUpICYmIHRoaXMuZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGggPT09IHNlbGVjdGlvbi5nZXRUZXh0Q29udGVudCgpLmxlbmd0aDtcbiAgfVxuICBpc1BhcmVudFJlcXVpcmVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNyZWF0ZVBhcmVudEVsZW1lbnROb2RlKCkge1xuICAgIHJldHVybiAkY3JlYXRlTGlzdE5vZGUoJ2J1bGxldCcpO1xuICB9XG4gIGNhbk1lcmdlV2hlbkVtcHR5KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiAkc2V0TGlzdEl0ZW1UaGVtZUNsYXNzTmFtZXMoZG9tLCBlZGl0b3JUaGVtZUNsYXNzZXMsIG5vZGUpIHtcbiAgY29uc3QgY2xhc3Nlc1RvQWRkID0gW107XG4gIGNvbnN0IGNsYXNzZXNUb1JlbW92ZSA9IFtdO1xuICBjb25zdCBsaXN0VGhlbWUgPSBlZGl0b3JUaGVtZUNsYXNzZXMubGlzdDtcbiAgY29uc3QgbGlzdEl0ZW1DbGFzc05hbWUgPSBsaXN0VGhlbWUgPyBsaXN0VGhlbWUubGlzdGl0ZW0gOiB1bmRlZmluZWQ7XG4gIGxldCBuZXN0ZWRMaXN0SXRlbUNsYXNzTmFtZTtcbiAgaWYgKGxpc3RUaGVtZSAmJiBsaXN0VGhlbWUubmVzdGVkKSB7XG4gICAgbmVzdGVkTGlzdEl0ZW1DbGFzc05hbWUgPSBsaXN0VGhlbWUubmVzdGVkLmxpc3RpdGVtO1xuICB9XG4gIGlmIChsaXN0SXRlbUNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY2xhc3Nlc1RvQWRkLnB1c2goLi4ubm9ybWFsaXplQ2xhc3NOYW1lcyhsaXN0SXRlbUNsYXNzTmFtZSkpO1xuICB9XG4gIGlmIChsaXN0VGhlbWUpIHtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICBjb25zdCBpc0NoZWNrTGlzdCA9ICRpc0xpc3ROb2RlKHBhcmVudE5vZGUpICYmIHBhcmVudE5vZGUuZ2V0TGlzdFR5cGUoKSA9PT0gJ2NoZWNrJztcbiAgICBjb25zdCBjaGVja2VkID0gbm9kZS5nZXRDaGVja2VkKCk7XG4gICAgaWYgKCFpc0NoZWNrTGlzdCB8fCBjaGVja2VkKSB7XG4gICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaChsaXN0VGhlbWUubGlzdGl0ZW1VbmNoZWNrZWQpO1xuICAgIH1cbiAgICBpZiAoIWlzQ2hlY2tMaXN0IHx8ICFjaGVja2VkKSB7XG4gICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaChsaXN0VGhlbWUubGlzdGl0ZW1DaGVja2VkKTtcbiAgICB9XG4gICAgaWYgKGlzQ2hlY2tMaXN0KSB7XG4gICAgICBjbGFzc2VzVG9BZGQucHVzaChjaGVja2VkID8gbGlzdFRoZW1lLmxpc3RpdGVtQ2hlY2tlZCA6IGxpc3RUaGVtZS5saXN0aXRlbVVuY2hlY2tlZCk7XG4gICAgfVxuICB9XG4gIGlmIChuZXN0ZWRMaXN0SXRlbUNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbmVzdGVkTGlzdEl0ZW1DbGFzc2VzID0gbm9ybWFsaXplQ2xhc3NOYW1lcyhuZXN0ZWRMaXN0SXRlbUNsYXNzTmFtZSk7XG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGRyZW4oKS5zb21lKGNoaWxkID0+ICRpc0xpc3ROb2RlKGNoaWxkKSkpIHtcbiAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKC4uLm5lc3RlZExpc3RJdGVtQ2xhc3Nlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsYXNzZXNUb1JlbW92ZS5wdXNoKC4uLm5lc3RlZExpc3RJdGVtQ2xhc3Nlcyk7XG4gICAgfVxuICB9XG4gIGlmIChjbGFzc2VzVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChkb20sIC4uLmNsYXNzZXNUb1JlbW92ZSk7XG4gIH1cbiAgaWYgKGNsYXNzZXNUb0FkZC5sZW5ndGggPiAwKSB7XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChkb20sIC4uLmNsYXNzZXNUb0FkZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RJdGVtQ2hlY2tlZChkb20sIGxpc3RJdGVtTm9kZSwgcHJldkxpc3RJdGVtTm9kZSwgbGlzdE5vZGUpIHtcbiAgLy8gT25seSBhZGQgYXR0cmlidXRlcyBmb3IgbGVhZiBsaXN0IGl0ZW1zXG4gIGlmICgkaXNMaXN0Tm9kZShsaXN0SXRlbU5vZGUuZ2V0Rmlyc3RDaGlsZCgpKSkge1xuICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCd0YWJJbmRleCcpO1xuICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcpO1xuICB9IGVsc2Uge1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnY2hlY2tib3gnKTtcbiAgICBkb20uc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsICctMScpO1xuICAgIGlmICghcHJldkxpc3RJdGVtTm9kZSB8fCBsaXN0SXRlbU5vZGUuX19jaGVja2VkICE9PSBwcmV2TGlzdEl0ZW1Ob2RlLl9fY2hlY2tlZCkge1xuICAgICAgZG9tLnNldEF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJywgbGlzdEl0ZW1Ob2RlLmdldENoZWNrZWQoKSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJGNvbnZlcnRMaXN0SXRlbUVsZW1lbnQoZG9tTm9kZSkge1xuICBjb25zdCBpc0dpdEh1YkNoZWNrTGlzdCA9IGRvbU5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCd0YXNrLWxpc3QtaXRlbScpO1xuICBpZiAoaXNHaXRIdWJDaGVja0xpc3QpIHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGRvbU5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGlmIChjaGlsZC50YWdOYW1lID09PSAnSU5QVVQnKSB7XG4gICAgICAgIHJldHVybiAkY29udmVydENoZWNrYm94SW5wdXQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBhcmlhQ2hlY2tlZEF0dHIgPSBkb21Ob2RlLmdldEF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJyk7XG4gIGNvbnN0IGNoZWNrZWQgPSBhcmlhQ2hlY2tlZEF0dHIgPT09ICd0cnVlJyA/IHRydWUgOiBhcmlhQ2hlY2tlZEF0dHIgPT09ICdmYWxzZScgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlTGlzdEl0ZW1Ob2RlKGNoZWNrZWQpXG4gIH07XG59XG5mdW5jdGlvbiAkY29udmVydENoZWNrYm94SW5wdXQoZG9tTm9kZSkge1xuICBjb25zdCBpc0NoZWNrYm94SW5wdXQgPSBkb21Ob2RlLmdldEF0dHJpYnV0ZSgndHlwZScpID09PSAnY2hlY2tib3gnO1xuICBpZiAoIWlzQ2hlY2tib3hJbnB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBudWxsXG4gICAgfTtcbiAgfVxuICBjb25zdCBjaGVja2VkID0gZG9tTm9kZS5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlTGlzdEl0ZW1Ob2RlKGNoZWNrZWQpXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBMaXN0IEl0ZW0gbm9kZSwgcGFzc2luZyB0cnVlL2ZhbHNlIHdpbGwgY29udmVydCBpdCB0byBhIGNoZWNrYm94IGlucHV0LlxuICogQHBhcmFtIGNoZWNrZWQgLSBJcyB0aGUgTGlzdCBJdGVtIGEgY2hlY2tib3ggYW5kLCBpZiBzbywgaXMgaXQgY2hlY2tlZD8gdW5kZWZpbmVkL251bGw6IG5vdCBhIGNoZWNrYm94LCB0cnVlL2ZhbHNlIGlzIGEgY2hlY2tib3ggYW5kIGNoZWNrZWQvdW5jaGVja2VkLCByZXNwZWN0aXZlbHkuXG4gKiBAcmV0dXJucyBUaGUgbmV3IExpc3QgSXRlbS5cbiAqL1xuZnVuY3Rpb24gJGNyZWF0ZUxpc3RJdGVtTm9kZShjaGVja2VkKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IExpc3RJdGVtTm9kZSh1bmRlZmluZWQsIGNoZWNrZWQpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBub2RlIGlzIGEgTGlzdEl0ZW1Ob2RlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhIExpc3RJdGVtTm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkaXNMaXN0SXRlbU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIExpc3RJdGVtTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgTGlzdE5vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgJGNvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcoJ2xpc3QnLCB7XG4gICAgICAkdHJhbnNmb3JtOiBub2RlID0+IHtcbiAgICAgICAgbWVyZ2VOZXh0U2libGluZ0xpc3RJZlNhbWVUeXBlKG5vZGUpO1xuICAgICAgICB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUobm9kZSk7XG4gICAgICB9LFxuICAgICAgZXh0ZW5kczogRWxlbWVudE5vZGUsXG4gICAgICBpbXBvcnRET006IGJ1aWxkSW1wb3J0TWFwKHtcbiAgICAgICAgb2w6ICgpID0+ICh7XG4gICAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRMaXN0Tm9kZSxcbiAgICAgICAgICBwcmlvcml0eTogMFxuICAgICAgICB9KSxcbiAgICAgICAgdWw6ICgpID0+ICh7XG4gICAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRMaXN0Tm9kZSxcbiAgICAgICAgICBwcmlvcml0eTogMFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihsaXN0VHlwZSA9ICdudW1iZXInLCBzdGFydCA9IDEsIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgY29uc3QgX2xpc3RUeXBlID0gVEFHX1RPX0xJU1RfVFlQRVtsaXN0VHlwZV0gfHwgbGlzdFR5cGU7XG4gICAgdGhpcy5fX2xpc3RUeXBlID0gX2xpc3RUeXBlO1xuICAgIHRoaXMuX190YWcgPSBfbGlzdFR5cGUgPT09ICdudW1iZXInID8gJ29sJyA6ICd1bCc7XG4gICAgdGhpcy5fX3N0YXJ0ID0gc3RhcnQ7XG4gIH1cbiAgYWZ0ZXJDbG9uZUZyb20ocHJldk5vZGUpIHtcbiAgICBzdXBlci5hZnRlckNsb25lRnJvbShwcmV2Tm9kZSk7XG4gICAgdGhpcy5fX2xpc3RUeXBlID0gcHJldk5vZGUuX19saXN0VHlwZTtcbiAgICB0aGlzLl9fdGFnID0gcHJldk5vZGUuX190YWc7XG4gICAgdGhpcy5fX3N0YXJ0ID0gcHJldk5vZGUuX19zdGFydDtcbiAgfVxuICBnZXRUYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX190YWc7XG4gIH1cbiAgc2V0TGlzdFR5cGUodHlwZSkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fbGlzdFR5cGUgPSB0eXBlO1xuICAgIHdyaXRhYmxlLl9fdGFnID0gdHlwZSA9PT0gJ251bWJlcicgPyAnb2wnIDogJ3VsJztcbiAgICByZXR1cm4gd3JpdGFibGU7XG4gIH1cbiAgZ2V0TGlzdFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19saXN0VHlwZTtcbiAgfVxuICBnZXRTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX3N0YXJ0O1xuICB9XG4gIHNldFN0YXJ0KHN0YXJ0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fc3RhcnQgPSBzdGFydDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8vIFZpZXdcblxuICBjcmVhdGVET00oY29uZmlnLCBfZWRpdG9yKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5fX3RhZztcbiAgICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKHRoaXMuX19zdGFydCAhPT0gMSkge1xuICAgICAgZG9tLnNldEF0dHJpYnV0ZSgnc3RhcnQnLCBTdHJpbmcodGhpcy5fX3N0YXJ0KSk7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSW50ZXJuYWwgZmllbGQuXG4gICAgZG9tLl9fbGV4aWNhbExpc3RUeXBlID0gdGhpcy5fX2xpc3RUeXBlO1xuICAgICRzZXRMaXN0VGhlbWVDbGFzc05hbWVzKGRvbSwgY29uZmlnLnRoZW1lLCB0aGlzKTtcbiAgICByZXR1cm4gZG9tO1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBpZiAocHJldk5vZGUuX190YWcgIT09IHRoaXMuX190YWcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAkc2V0TGlzdFRoZW1lQ2xhc3NOYW1lcyhkb20sIGNvbmZpZy50aGVtZSwgdGhpcyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRMaXN0VHlwZShzZXJpYWxpemVkTm9kZS5saXN0VHlwZSkuc2V0U3RhcnQoc2VyaWFsaXplZE5vZGUuc3RhcnQpO1xuICB9XG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5jcmVhdGVET00oZWRpdG9yLl9jb25maWcsIGVkaXRvcik7XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhcnQgIT09IDEpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0YXJ0JywgU3RyaW5nKHRoaXMuX19zdGFydCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19saXN0VHlwZSA9PT0gJ2NoZWNrJykge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnX19sZXhpY2FsTGlzdFR5cGUnLCAnY2hlY2snKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGxpc3RUeXBlOiB0aGlzLmdldExpc3RUeXBlKCksXG4gICAgICBzdGFydDogdGhpcy5nZXRTdGFydCgpLFxuICAgICAgdGFnOiB0aGlzLmdldFRhZygpXG4gICAgfTtcbiAgfVxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIG5vZGVzVG9JbnNlcnQpIHtcbiAgICBsZXQgbGlzdEl0ZW1Ob2Rlc1RvSW5zZXJ0ID0gbm9kZXNUb0luc2VydDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzVG9JbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1RvSW5zZXJ0W2ldO1xuICAgICAgaWYgKCEkaXNMaXN0SXRlbU5vZGUobm9kZSkpIHtcbiAgICAgICAgaWYgKGxpc3RJdGVtTm9kZXNUb0luc2VydCA9PT0gbm9kZXNUb0luc2VydCkge1xuICAgICAgICAgIGxpc3RJdGVtTm9kZXNUb0luc2VydCA9IFsuLi5ub2Rlc1RvSW5zZXJ0XTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0SXRlbU5vZGVzVG9JbnNlcnRbaV0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCkuYXBwZW5kKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmICEoJGlzTGlzdE5vZGUobm9kZSkgfHwgbm9kZS5pc0lubGluZSgpKSA/ICRjcmVhdGVUZXh0Tm9kZShub2RlLmdldFRleHRDb250ZW50KCkpIDogbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5zcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCBsaXN0SXRlbU5vZGVzVG9JbnNlcnQpO1xuICB9XG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQpIHtcbiAgICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKGNoaWxkKTtcbiAgfVxufVxuZnVuY3Rpb24gJHNldExpc3RUaGVtZUNsYXNzTmFtZXMoZG9tLCBlZGl0b3JUaGVtZUNsYXNzZXMsIG5vZGUpIHtcbiAgY29uc3QgY2xhc3Nlc1RvQWRkID0gW107XG4gIGNvbnN0IGNsYXNzZXNUb1JlbW92ZSA9IFtdO1xuICBjb25zdCBsaXN0VGhlbWUgPSBlZGl0b3JUaGVtZUNsYXNzZXMubGlzdDtcbiAgaWYgKGxpc3RUaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbGlzdExldmVsc0NsYXNzTmFtZXMgPSBsaXN0VGhlbWVbYCR7bm9kZS5fX3RhZ31EZXB0aGBdIHx8IFtdO1xuICAgIGNvbnN0IGxpc3REZXB0aCA9ICRnZXRMaXN0RGVwdGgobm9kZSkgLSAxO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRMaXN0RGVwdGggPSBsaXN0RGVwdGggJSBsaXN0TGV2ZWxzQ2xhc3NOYW1lcy5sZW5ndGg7XG4gICAgY29uc3QgbGlzdExldmVsQ2xhc3NOYW1lID0gbGlzdExldmVsc0NsYXNzTmFtZXNbbm9ybWFsaXplZExpc3REZXB0aF07XG4gICAgY29uc3QgbGlzdENsYXNzTmFtZSA9IGxpc3RUaGVtZVtub2RlLl9fdGFnXTtcbiAgICBsZXQgbmVzdGVkTGlzdENsYXNzTmFtZTtcbiAgICBjb25zdCBuZXN0ZWRMaXN0VGhlbWUgPSBsaXN0VGhlbWUubmVzdGVkO1xuICAgIGNvbnN0IGNoZWNrbGlzdENsYXNzTmFtZSA9IGxpc3RUaGVtZS5jaGVja2xpc3Q7XG4gICAgaWYgKG5lc3RlZExpc3RUaGVtZSAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZExpc3RUaGVtZS5saXN0KSB7XG4gICAgICBuZXN0ZWRMaXN0Q2xhc3NOYW1lID0gbmVzdGVkTGlzdFRoZW1lLmxpc3Q7XG4gICAgfVxuICAgIGlmIChsaXN0Q2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKGxpc3RDbGFzc05hbWUpO1xuICAgIH1cbiAgICBpZiAoY2hlY2tsaXN0Q2xhc3NOYW1lICE9PSB1bmRlZmluZWQgJiYgbm9kZS5fX2xpc3RUeXBlID09PSAnY2hlY2snKSB7XG4gICAgICBjbGFzc2VzVG9BZGQucHVzaChjaGVja2xpc3RDbGFzc05hbWUpO1xuICAgIH1cbiAgICBpZiAobGlzdExldmVsQ2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKC4uLm5vcm1hbGl6ZUNsYXNzTmFtZXMobGlzdExldmVsQ2xhc3NOYW1lKSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RMZXZlbHNDbGFzc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpICE9PSBub3JtYWxpemVkTGlzdERlcHRoKSB7XG4gICAgICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2gobm9kZS5fX3RhZyArIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXN0ZWRMaXN0Q2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG5lc3RlZExpc3RJdGVtQ2xhc3NlcyA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMobmVzdGVkTGlzdENsYXNzTmFtZSk7XG4gICAgICBpZiAobGlzdERlcHRoID4gMSkge1xuICAgICAgICBjbGFzc2VzVG9BZGQucHVzaCguLi5uZXN0ZWRMaXN0SXRlbUNsYXNzZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2goLi4ubmVzdGVkTGlzdEl0ZW1DbGFzc2VzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGNsYXNzZXNUb1JlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGRvbSwgLi4uY2xhc3Nlc1RvUmVtb3ZlKTtcbiAgfVxuICBpZiAoY2xhc3Nlc1RvQWRkLmxlbmd0aCA+IDApIHtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGRvbSwgLi4uY2xhc3Nlc1RvQWRkKTtcbiAgfVxufVxuXG4vKlxuICogVGhpcyBmdW5jdGlvbiBub3JtYWxpemVzIHRoZSBjaGlsZHJlbiBvZiBhIExpc3ROb2RlIGFmdGVyIHRoZSBjb252ZXJzaW9uIGZyb20gSFRNTCxcbiAqIGVuc3VyaW5nIHRoYXQgdGhleSBhcmUgYWxsIExpc3RJdGVtTm9kZXMgYW5kIGNvbnRhaW4gZWl0aGVyIGEgc2luZ2xlIG5lc3RlZCBMaXN0Tm9kZVxuICogb3Igc29tZSBvdGhlciBpbmxpbmUgY29udGVudC5cbiAqL1xuZnVuY3Rpb24gJG5vcm1hbGl6ZUNoaWxkcmVuKG5vZGVzKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRMaXN0SXRlbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpKSB7XG4gICAgICBub3JtYWxpemVkTGlzdEl0ZW1zLnB1c2gobm9kZSk7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgIGlmICgkaXNMaXN0Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRMaXN0SXRlbXMucHVzaCgkd3JhcEluTGlzdEl0ZW0oY2hpbGQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxpemVkTGlzdEl0ZW1zLnB1c2goJHdyYXBJbkxpc3RJdGVtKG5vZGUpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWRMaXN0SXRlbXM7XG59XG5mdW5jdGlvbiBpc0RvbUNoZWNrbGlzdChkb21Ob2RlKSB7XG4gIGlmIChkb21Ob2RlLmdldEF0dHJpYnV0ZSgnX19sZXhpY2FsbGlzdHR5cGUnKSA9PT0gJ2NoZWNrJyB8fFxuICAvLyBpcyBnaXRodWIgY2hlY2tsaXN0XG4gIGRvbU5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdjb250YWlucy10YXNrLWxpc3QnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIGlmIGNoaWxkcmVuIGFyZSBjaGVja2xpc3QgaXRlbXMsIHRoZSBub2RlIGlzIGEgY2hlY2tsaXN0IHVsLiBBcHBsaWNhYmxlIGZvciBnb29nbGVkb2MgY2hlY2tsaXN0IHBhc3RpbmcuXG4gIGZvciAoY29uc3QgY2hpbGQgb2YgZG9tTm9kZS5jaGlsZE5vZGVzKSB7XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQoY2hpbGQpICYmIGNoaWxkLmhhc0F0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiAkY29udmVydExpc3ROb2RlKGRvbU5vZGUpIHtcbiAgY29uc3Qgbm9kZU5hbWUgPSBkb21Ob2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGxldCBub2RlID0gbnVsbDtcbiAgaWYgKG5vZGVOYW1lID09PSAnb2wnKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHN0YXJ0ID0gZG9tTm9kZS5zdGFydDtcbiAgICBub2RlID0gJGNyZWF0ZUxpc3ROb2RlKCdudW1iZXInLCBzdGFydCk7XG4gIH0gZWxzZSBpZiAobm9kZU5hbWUgPT09ICd1bCcpIHtcbiAgICBpZiAoaXNEb21DaGVja2xpc3QoZG9tTm9kZSkpIHtcbiAgICAgIG5vZGUgPSAkY3JlYXRlTGlzdE5vZGUoJ2NoZWNrJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSAkY3JlYXRlTGlzdE5vZGUoJ2J1bGxldCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGFmdGVyOiAkbm9ybWFsaXplQ2hpbGRyZW4sXG4gICAgbm9kZVxuICB9O1xufVxuY29uc3QgVEFHX1RPX0xJU1RfVFlQRSA9IHtcbiAgb2w6ICdudW1iZXInLFxuICB1bDogJ2J1bGxldCdcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIExpc3ROb2RlIG9mIGxpc3RUeXBlLlxuICogQHBhcmFtIGxpc3RUeXBlIC0gVGhlIHR5cGUgb2YgbGlzdCB0byBiZSBjcmVhdGVkLiBDYW4gYmUgJ251bWJlcicsICdidWxsZXQnLCBvciAnY2hlY2snLlxuICogQHBhcmFtIHN0YXJ0IC0gV2hlcmUgYW4gb3JkZXJlZCBsaXN0IHN0YXJ0cyBpdHMgY291bnQsIHN0YXJ0ID0gMSBpZiBsZWZ0IHVuZGVmaW5lZC5cbiAqIEByZXR1cm5zIFRoZSBuZXcgTGlzdE5vZGVcbiAqL1xuZnVuY3Rpb24gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlID0gJ251bWJlcicsIHN0YXJ0ID0gMSkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBMaXN0Tm9kZShsaXN0VHlwZSwgc3RhcnQpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBub2RlIGlzIGEgTGlzdE5vZGUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGEgTGlzdE5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gJGlzTGlzdE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIExpc3ROb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IElOU0VSVF9DSEVDS19MSVNUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdJTlNFUlRfQ0hFQ0tfTElTVF9DT01NQU5EJyk7XG5mdW5jdGlvbiByZWdpc3RlckNoZWNrTGlzdChlZGl0b3IpIHtcbiAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfQ0hFQ0tfTElTVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgJGluc2VydExpc3QoJ2NoZWNrJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfQVJST1dfRE9XTl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgcmV0dXJuIGhhbmRsZUFycm93VXBPckRvd24oZXZlbnQsIGVkaXRvciwgZmFsc2UpO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX1VQX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICByZXR1cm4gaGFuZGxlQXJyb3dVcE9yRG93bihldmVudCwgZWRpdG9yLCB0cnVlKTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9FU0NBUEVfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNvbnN0IGFjdGl2ZUl0ZW0gPSBnZXRBY3RpdmVDaGVja0xpc3RJdGVtKCk7XG4gICAgaWYgKGFjdGl2ZUl0ZW0gIT0gbnVsbCkge1xuICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICAgIGlmIChyb290RWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgIHJvb3RFbGVtZW50LmZvY3VzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX1NQQUNFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBhY3RpdmVJdGVtID0gZ2V0QWN0aXZlQ2hlY2tMaXN0SXRlbSgpO1xuICAgIGlmIChhY3RpdmVJdGVtICE9IG51bGwgJiYgZWRpdG9yLmlzRWRpdGFibGUoKSkge1xuICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RJdGVtTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGFjdGl2ZUl0ZW0pO1xuICAgICAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGxpc3RJdGVtTm9kZSkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGxpc3RJdGVtTm9kZS50b2dnbGVDaGVja2VkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19MRUZUX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICByZXR1cm4gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYW5jaG9yXG4gICAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICAgIGNvbnN0IGlzRWxlbWVudCA9IGFuY2hvci50eXBlID09PSAnZWxlbWVudCc7XG4gICAgICAgIGlmIChpc0VsZW1lbnQgfHwgYW5jaG9yLm9mZnNldCA9PT0gMCkge1xuICAgICAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnROb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChhbmNob3JOb2RlLCBub2RlID0+ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpO1xuICAgICAgICAgIGlmICgkaXNMaXN0SXRlbU5vZGUoZWxlbWVudE5vZGUpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50Tm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpICYmIHBhcmVudC5nZXRMaXN0VHlwZSgpID09PSAnY2hlY2snICYmIChpc0VsZW1lbnQgfHwgZWxlbWVudE5vZGUuZ2V0Rmlyc3REZXNjZW5kYW50KCkgPT09IGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRvbU5vZGUgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGVsZW1lbnROb2RlLl9fa2V5KTtcbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGUgIT0gbnVsbCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBkb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJSb290TGlzdGVuZXIoKHJvb3RFbGVtZW50LCBwcmV2RWxlbWVudCkgPT4ge1xuICAgIGlmIChyb290RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgcm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICB9XG4gICAgaWYgKHByZXZFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICBwcmV2RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrKTtcbiAgICAgIHByZXZFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgIH1cbiAgfSkpO1xufVxuZnVuY3Rpb24gaGFuZGxlQ2hlY2tJdGVtRXZlbnQoZXZlbnQsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KHRhcmdldCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZ25vcmUgY2xpY2tzIG9uIExJIHRoYXQgaGF2ZSBuZXN0ZWQgbGlzdHNcbiAgY29uc3QgZmlyc3RDaGlsZCA9IHRhcmdldC5maXJzdENoaWxkO1xuICBpZiAoaXNIVE1MRWxlbWVudChmaXJzdENoaWxkKSAmJiAoZmlyc3RDaGlsZC50YWdOYW1lID09PSAnVUwnIHx8IGZpcnN0Q2hpbGQudGFnTmFtZSA9PT0gJ09MJykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGFyZW50Tm9kZSA9IHRhcmdldC5wYXJlbnROb2RlO1xuXG4gIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgZmllbGRcbiAgaWYgKCFwYXJlbnROb2RlIHx8IHBhcmVudE5vZGUuX19sZXhpY2FsTGlzdFR5cGUgIT09ICdjaGVjaycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3Qgem9vbSA9IGNhbGN1bGF0ZVpvb21MZXZlbCh0YXJnZXQpO1xuICBjb25zdCBjbGllbnRYID0gZXZlbnQuY2xpZW50WCAvIHpvb207XG5cbiAgLy8gVXNlIGdldENvbXB1dGVkU3R5bGUgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZmFsbGJhY2sgdG8gMHB4IHdpZHRoXG4gIGNvbnN0IGJlZm9yZVN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGFyZ2V0LCAnOjpiZWZvcmUnKSA6IHtcbiAgICB3aWR0aDogJzBweCdcbiAgfTtcbiAgY29uc3QgYmVmb3JlV2lkdGhJblBpeGVscyA9IHBhcnNlRmxvYXQoYmVmb3JlU3R5bGVzLndpZHRoKTtcblxuICAvLyBNYWtlIGNsaWNrIGFyZWEgc2xpZ2h0bHkgbGFyZ2VyIGZvciB0b3VjaCBkZXZpY2VzIHRvIGltcHJvdmUgYWNjZXNzaWJpbGl0eVxuICBjb25zdCBpc1RvdWNoRXZlbnQgPSBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJztcbiAgY29uc3QgY2xpY2tBcmVhUGFkZGluZyA9IGlzVG91Y2hFdmVudCA/IDMyIDogMDsgLy8gQWRkIDMycHggcGFkZGluZyBmb3IgdG91Y2ggZXZlbnRzXG5cbiAgaWYgKHRhcmdldC5kaXIgPT09ICdydGwnID8gY2xpZW50WCA8IHJlY3QucmlnaHQgKyBjbGlja0FyZWFQYWRkaW5nICYmIGNsaWVudFggPiByZWN0LnJpZ2h0IC0gYmVmb3JlV2lkdGhJblBpeGVscyAtIGNsaWNrQXJlYVBhZGRpbmcgOiBjbGllbnRYID4gcmVjdC5sZWZ0IC0gY2xpY2tBcmVhUGFkZGluZyAmJiBjbGllbnRYIDwgcmVjdC5sZWZ0ICsgYmVmb3JlV2lkdGhJblBpeGVscyArIGNsaWNrQXJlYVBhZGRpbmcpIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICBoYW5kbGVDaGVja0l0ZW1FdmVudChldmVudCwgKCkgPT4ge1xuICAgIGlmIChpc0hUTUxFbGVtZW50KGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIGNvbnN0IGRvbU5vZGUgPSBldmVudC50YXJnZXQ7XG4gICAgICBjb25zdCBlZGl0b3IgPSBnZXROZWFyZXN0RWRpdG9yRnJvbURPTU5vZGUoZG9tTm9kZSk7XG4gICAgICBpZiAoZWRpdG9yICE9IG51bGwgJiYgZWRpdG9yLmlzRWRpdGFibGUoKSkge1xuICAgICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBub2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoZG9tTm9kZSk7XG4gICAgICAgICAgaWYgKCRpc0xpc3RJdGVtTm9kZShub2RlKSkge1xuICAgICAgICAgICAgZG9tTm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgbm9kZS50b2dnbGVDaGVja2VkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgaGFuZGxlQ2hlY2tJdGVtRXZlbnQoZXZlbnQsICgpID0+IHtcbiAgICAvLyBQcmV2ZW50cyBjYXJldCBtb3Zpbmcgd2hlbiBjbGlja2luZyBvbiBjaGVjayBtYXJrXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRBY3RpdmVDaGVja0xpc3RJdGVtKCkge1xuICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgcmV0dXJuIGlzSFRNTEVsZW1lbnQoYWN0aXZlRWxlbWVudCkgJiYgYWN0aXZlRWxlbWVudC50YWdOYW1lID09PSAnTEknICYmIGFjdGl2ZUVsZW1lbnQucGFyZW50Tm9kZSAhPSBudWxsICYmXG4gIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgZmllbGRcbiAgYWN0aXZlRWxlbWVudC5wYXJlbnROb2RlLl9fbGV4aWNhbExpc3RUeXBlID09PSAnY2hlY2snID8gYWN0aXZlRWxlbWVudCA6IG51bGw7XG59XG5mdW5jdGlvbiBmaW5kQ2hlY2tMaXN0SXRlbVNpYmxpbmcobm9kZSwgYmFja3dhcmQpIHtcbiAgbGV0IHNpYmxpbmcgPSBiYWNrd2FyZCA/IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuXG4gIC8vIEdvaW5nIHVwIGluIGEgdHJlZSB0byBnZXQgbm9uLW51bGwgc2libGluZ1xuICB3aGlsZSAoc2libGluZyA9PSBudWxsICYmICRpc0xpc3RJdGVtTm9kZShwYXJlbnQpKSB7XG4gICAgLy8gR2V0IGxpIC0+IHBhcmVudCB1bC9vbCAtPiBwYXJlbnQgbGlcbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpLmdldFBhcmVudCgpO1xuICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgc2libGluZyA9IGJhY2t3YXJkID8gcGFyZW50LmdldFByZXZpb3VzU2libGluZygpIDogcGFyZW50LmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gR29pbmcgZG93biBpbiBhIHRyZWUgdG8gZ2V0IGZpcnN0IG5vbi1uZXN0ZWQgbGlzdCBpdGVtXG4gIHdoaWxlICgkaXNMaXN0SXRlbU5vZGUoc2libGluZykpIHtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gYmFja3dhcmQgPyBzaWJsaW5nLmdldExhc3RDaGlsZCgpIDogc2libGluZy5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKCEkaXNMaXN0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgcmV0dXJuIHNpYmxpbmc7XG4gICAgfVxuICAgIHNpYmxpbmcgPSBiYWNrd2FyZCA/IGZpcnN0Q2hpbGQuZ2V0TGFzdENoaWxkKCkgOiBmaXJzdENoaWxkLmdldEZpcnN0Q2hpbGQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFycm93VXBPckRvd24oZXZlbnQsIGVkaXRvciwgYmFja3dhcmQpIHtcbiAgY29uc3QgYWN0aXZlSXRlbSA9IGdldEFjdGl2ZUNoZWNrTGlzdEl0ZW0oKTtcbiAgaWYgKGFjdGl2ZUl0ZW0gIT0gbnVsbCkge1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgbGlzdEl0ZW0gPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShhY3RpdmVJdGVtKTtcbiAgICAgIGlmICghJGlzTGlzdEl0ZW1Ob2RlKGxpc3RJdGVtKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0TGlzdEl0ZW0gPSBmaW5kQ2hlY2tMaXN0SXRlbVNpYmxpbmcobGlzdEl0ZW0sIGJhY2t3YXJkKTtcbiAgICAgIGlmIChuZXh0TGlzdEl0ZW0gIT0gbnVsbCkge1xuICAgICAgICBuZXh0TGlzdEl0ZW0uc2VsZWN0U3RhcnQoKTtcbiAgICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShuZXh0TGlzdEl0ZW0uX19rZXkpO1xuICAgICAgICBpZiAoZG9tICE9IG51bGwpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZG9tLmZvY3VzKCk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgVVBEQVRFX0xJU1RfU1RBUlRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1VQREFURV9MSVNUX1NUQVJUX0NPTU1BTkQnKTtcbmNvbnN0IElOU0VSVF9VTk9SREVSRURfTElTVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX1VOT1JERVJFRF9MSVNUX0NPTU1BTkQnKTtcbmNvbnN0IElOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCcpO1xuY29uc3QgUkVNT1ZFX0xJU1RfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1JFTU9WRV9MSVNUX0NPTU1BTkQnKTtcbmZ1bmN0aW9uIHJlZ2lzdGVyTGlzdChlZGl0b3IpIHtcbiAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX09SREVSRURfTElTVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgJGluc2VydExpc3QoJ251bWJlcicpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoVVBEQVRFX0xJU1RfU1RBUlRfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbGlzdE5vZGVLZXksXG4gICAgICBuZXdTdGFydFxuICAgIH0gPSBwYXlsb2FkO1xuICAgIGNvbnN0IGxpc3ROb2RlID0gJGdldE5vZGVCeUtleShsaXN0Tm9kZUtleSk7XG4gICAgaWYgKCEkaXNMaXN0Tm9kZShsaXN0Tm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxpc3ROb2RlLmdldExpc3RUeXBlKCkgPT09ICdudW1iZXInKSB7XG4gICAgICBsaXN0Tm9kZS5zZXRTdGFydChuZXdTdGFydCk7XG4gICAgICB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUobGlzdE5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKElOU0VSVF9VTk9SREVSRURfTElTVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgJGluc2VydExpc3QoJ2J1bGxldCcpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoUkVNT1ZFX0xJU1RfQ09NTUFORCwgKCkgPT4ge1xuICAgICRyZW1vdmVMaXN0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsICgpID0+ICRoYW5kbGVMaXN0SW5zZXJ0UGFyYWdyYXBoKCksIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybShMaXN0SXRlbU5vZGUsIG5vZGUgPT4ge1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgaWYgKCRpc1RleHROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZmlyc3RDaGlsZC5nZXRTdHlsZSgpO1xuICAgICAgICBjb25zdCBmb3JtYXQgPSBmaXJzdENoaWxkLmdldEZvcm1hdCgpO1xuICAgICAgICBpZiAobm9kZS5nZXRUZXh0U3R5bGUoKSAhPT0gc3R5bGUpIHtcbiAgICAgICAgICBub2RlLnNldFRleHRTdHlsZShzdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuZ2V0VGV4dEZvcm1hdCgpICE9PSBmb3JtYXQpIHtcbiAgICAgICAgICBub2RlLnNldFRleHRGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIGVtcHR5LCBjaGVjayB0aGUgc2VsZWN0aW9uXG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAoc2VsZWN0aW9uLnN0eWxlICE9PSBub2RlLmdldFRleHRTdHlsZSgpIHx8IHNlbGVjdGlvbi5mb3JtYXQgIT09IG5vZGUuZ2V0VGV4dEZvcm1hdCgpKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBub2RlLmlzKHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpKSkge1xuICAgICAgICBub2RlLnNldFRleHRTdHlsZShzZWxlY3Rpb24uc3R5bGUpLnNldFRleHRGb3JtYXQoc2VsZWN0aW9uLmZvcm1hdCk7XG4gICAgICB9XG4gICAgfVxuICB9KSwgZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybShUZXh0Tm9kZSwgbm9kZSA9PiB7XG4gICAgY29uc3QgbGlzdEl0ZW1QYXJlbnROb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGxpc3RJdGVtUGFyZW50Tm9kZSkgJiYgbm9kZS5pcyhsaXN0SXRlbVBhcmVudE5vZGUuZ2V0Rmlyc3RDaGlsZCgpKSkge1xuICAgICAgY29uc3Qgc3R5bGUgPSBub2RlLmdldFN0eWxlKCk7XG4gICAgICBjb25zdCBmb3JtYXQgPSBub2RlLmdldEZvcm1hdCgpO1xuICAgICAgaWYgKHN0eWxlICE9PSBsaXN0SXRlbVBhcmVudE5vZGUuZ2V0VGV4dFN0eWxlKCkgfHwgZm9ybWF0ICE9PSBsaXN0SXRlbVBhcmVudE5vZGUuZ2V0VGV4dEZvcm1hdCgpKSB7XG4gICAgICAgIGxpc3RJdGVtUGFyZW50Tm9kZS5zZXRUZXh0U3R5bGUoc3R5bGUpLnNldFRleHRGb3JtYXQoZm9ybWF0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pKTtcbiAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJMaXN0U3RyaWN0SW5kZW50VHJhbnNmb3JtKGVkaXRvcikge1xuICBjb25zdCAkZm9ybWF0TGlzdEluZGVudFN0cmljdCA9IGxpc3RJdGVtTm9kZSA9PiB7XG4gICAgY29uc3QgbGlzdE5vZGUgPSBsaXN0SXRlbU5vZGUuZ2V0UGFyZW50KCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKGxpc3RJdGVtTm9kZS5nZXRGaXJzdENoaWxkKCkpIHx8ICEkaXNMaXN0Tm9kZShsaXN0Tm9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRpbmdMaXN0SXRlbU5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGxpc3RJdGVtTm9kZSwgbm9kZSA9PiAkaXNMaXN0SXRlbU5vZGUobm9kZSkgJiYgJGlzTGlzdE5vZGUobm9kZS5nZXRQYXJlbnQoKSkgJiYgJGlzTGlzdEl0ZW1Ob2RlKG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkpKTtcbiAgICBpZiAoc3RhcnRpbmdMaXN0SXRlbU5vZGUgPT09IG51bGwgJiYgbGlzdEl0ZW1Ob2RlLmdldEluZGVudCgpID4gMCkge1xuICAgICAgbGlzdEl0ZW1Ob2RlLnNldEluZGVudCgwKTtcbiAgICB9IGVsc2UgaWYgKCRpc0xpc3RJdGVtTm9kZShzdGFydGluZ0xpc3RJdGVtTm9kZSkpIHtcbiAgICAgIGNvbnN0IHByZXZMaXN0SXRlbU5vZGUgPSBzdGFydGluZ0xpc3RJdGVtTm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIGlmICgkaXNMaXN0SXRlbU5vZGUocHJldkxpc3RJdGVtTm9kZSkpIHtcbiAgICAgICAgY29uc3QgZW5kTGlzdEl0ZW1Ob2RlID0gJGZpbmRDaGlsZHJlbkVuZExpc3RJdGVtTm9kZShwcmV2TGlzdEl0ZW1Ob2RlKTtcbiAgICAgICAgY29uc3QgZW5kTGlzdE5vZGUgPSBlbmRMaXN0SXRlbU5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmICgkaXNMaXN0Tm9kZShlbmRMaXN0Tm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBwcmV2RGVwdGggPSAkZ2V0TGlzdERlcHRoKGVuZExpc3ROb2RlKTtcbiAgICAgICAgICBjb25zdCBkZXB0aCA9ICRnZXRMaXN0RGVwdGgobGlzdE5vZGUpO1xuICAgICAgICAgIGlmIChwcmV2RGVwdGggKyAxIDwgZGVwdGgpIHtcbiAgICAgICAgICAgIGxpc3RJdGVtTm9kZS5zZXRJbmRlbnQocHJldkRlcHRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0ICRwcm9jZXNzTGlzdFdpdGhTdHJpY3RJbmRlbnQgPSBsaXN0Tm9kZSA9PiB7XG4gICAgY29uc3QgcXVldWUgPSBbbGlzdE5vZGVdO1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBub2RlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgIGlmICghJGlzTGlzdE5vZGUobm9kZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuZ2V0Q2hpbGRyZW4oKSkge1xuICAgICAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGNoaWxkKSkge1xuICAgICAgICAgICRmb3JtYXRMaXN0SW5kZW50U3RyaWN0KGNoaWxkKTtcbiAgICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gY2hpbGQuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgICAgIGlmICgkaXNMaXN0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgICAgICAgcXVldWUucHVzaChmaXJzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKExpc3ROb2RlLCAkcHJvY2Vzc0xpc3RXaXRoU3RyaWN0SW5kZW50KTtcbn1cbmZ1bmN0aW9uICRmaW5kQ2hpbGRyZW5FbmRMaXN0SXRlbU5vZGUobGlzdEl0ZW1Ob2RlKSB7XG4gIGxldCBjdXJyZW50ID0gbGlzdEl0ZW1Ob2RlO1xuICBsZXQgZmlyc3RDaGlsZCA9IGN1cnJlbnQuZ2V0Rmlyc3RDaGlsZCgpO1xuICB3aGlsZSAoJGlzTGlzdE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICBjb25zdCBsYXN0Q2hpbGQgPSBmaXJzdENoaWxkLmdldExhc3RDaGlsZCgpO1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUobGFzdENoaWxkKSkge1xuICAgICAgY3VycmVudCA9IGxhc3RDaGlsZDtcbiAgICAgIGZpcnN0Q2hpbGQgPSBjdXJyZW50LmdldEZpcnN0Q2hpbGQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBjdXJyZW50O1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmsgJGluc2VydExpc3R9IGZyb20gYW4gdXBkYXRlIG9yIGNvbW1hbmQgbGlzdGVuZXIuXG4gKlxuICogSW5zZXJ0cyBhIG5ldyBMaXN0Tm9kZS4gSWYgdGhlIHNlbGVjdGlvbidzIGFuY2hvciBub2RlIGlzIGFuIGVtcHR5IExpc3RJdGVtTm9kZSBhbmQgaXMgYSBjaGlsZCBvZlxuICogdGhlIHJvb3Qvc2hhZG93IHJvb3QsIGl0IHdpbGwgcmVwbGFjZSB0aGUgTGlzdEl0ZW1Ob2RlIHdpdGggYSBMaXN0Tm9kZSBhbmQgdGhlIG9sZCBMaXN0SXRlbU5vZGUuXG4gKiBPdGhlcndpc2UgaXQgd2lsbCByZXBsYWNlIGl0cyBwYXJlbnQgd2l0aCBhIG5ldyBMaXN0Tm9kZSBhbmQgcmUtaW5zZXJ0IHRoZSBMaXN0SXRlbU5vZGUgYW5kIGFueSBwcmV2aW91cyBjaGlsZHJlbi5cbiAqIElmIHRoZSBzZWxlY3Rpb24ncyBhbmNob3Igbm9kZSBpcyBub3QgYW4gZW1wdHkgTGlzdEl0ZW1Ob2RlLCBpdCB3aWxsIGFkZCBhIG5ldyBMaXN0Tm9kZSBvciBtZXJnZSBhbiBleGlzdGluZyBMaXN0Tm9kZSxcbiAqIHVubGVzcyB0aGUgdGhlIG5vZGUgaXMgYSBsZWFmIG5vZGUsIGluIHdoaWNoIGNhc2UgaXQgd2lsbCBhdHRlbXB0IHRvIGZpbmQgYSBMaXN0Tm9kZSB1cCB0aGUgYnJhbmNoIGFuZCByZXBsYWNlIGl0IHdpdGhcbiAqIGEgbmV3IExpc3ROb2RlLCBvciBjcmVhdGUgYSBuZXcgTGlzdE5vZGUgYXQgdGhlIG5lYXJlc3Qgcm9vdC9zaGFkb3cgcm9vdC5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKiBAcGFyYW0gbGlzdFR5cGUgLSBUaGUgdHlwZSBvZiBsaXN0LCBcIm51bWJlclwiIHwgXCJidWxsZXRcIiB8IFwiY2hlY2tcIi5cbiAqL1xuZnVuY3Rpb24gaW5zZXJ0TGlzdChlZGl0b3IsIGxpc3RUeXBlKSB7XG4gIGVkaXRvci51cGRhdGUoKCkgPT4gJGluc2VydExpc3QobGlzdFR5cGUpKTtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rICRyZW1vdmVMaXN0fSBmcm9tIGFuIHVwZGF0ZSBvciBjb21tYW5kIGxpc3RlbmVyLlxuICpcbiAqIFNlYXJjaGVzIGZvciB0aGUgbmVhcmVzdCBhbmNlc3RyYWwgTGlzdE5vZGUgYW5kIHJlbW92ZXMgaXQuIElmIHNlbGVjdGlvbiBpcyBhbiBlbXB0eSBMaXN0SXRlbU5vZGVcbiAqIGl0IHdpbGwgcmVtb3ZlIHRoZSB3aG9sZSBsaXN0LCBpbmNsdWRpbmcgdGhlIExpc3RJdGVtTm9kZS4gRm9yIGVhY2ggTGlzdEl0ZW1Ob2RlIGluIHRoZSBMaXN0Tm9kZSxcbiAqIHJlbW92ZUxpc3Qgd2lsbCBhbHNvIGdlbmVyYXRlIG5ldyBQYXJhZ3JhcGhOb2RlcyBpbiB0aGUgcmVtb3ZlZCBMaXN0Tm9kZSdzIHBsYWNlLiBBbnkgY2hpbGQgbm9kZVxuICogaW5zaWRlIGEgTGlzdEl0ZW1Ob2RlIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIG5ldyBQYXJhZ3JhcGhOb2Rlcy5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUxpc3QoZWRpdG9yKSB7XG4gIGVkaXRvci51cGRhdGUoKCkgPT4gJHJlbW92ZUxpc3QoKSk7XG59XG5cbmV4cG9ydCB7ICRjcmVhdGVMaXN0SXRlbU5vZGUsICRjcmVhdGVMaXN0Tm9kZSwgJGdldExpc3REZXB0aCwgJGhhbmRsZUxpc3RJbnNlcnRQYXJhZ3JhcGgsICRpbnNlcnRMaXN0LCAkaXNMaXN0SXRlbU5vZGUsICRpc0xpc3ROb2RlLCAkcmVtb3ZlTGlzdCwgSU5TRVJUX0NIRUNLX0xJU1RfQ09NTUFORCwgSU5TRVJUX09SREVSRURfTElTVF9DT01NQU5ELCBJTlNFUlRfVU5PUkRFUkVEX0xJU1RfQ09NTUFORCwgTGlzdEl0ZW1Ob2RlLCBMaXN0Tm9kZSwgUkVNT1ZFX0xJU1RfQ09NTUFORCwgVVBEQVRFX0xJU1RfU1RBUlRfQ09NTUFORCwgaW5zZXJ0TGlzdCwgcmVnaXN0ZXJDaGVja0xpc3QsIHJlZ2lzdGVyTGlzdCwgcmVnaXN0ZXJMaXN0U3RyaWN0SW5kZW50VHJhbnNmb3JtLCByZW1vdmVMaXN0IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lexical+list@0.33.1/node_modules/@lexical/list/LexicalList.dev.mjs\n");

/***/ })

};
;