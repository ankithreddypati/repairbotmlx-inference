"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+markdown@0.33.1";
exports.ids = ["vendor-chunks/@lexical+markdown@0.33.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@lexical+markdown@0.33.1/node_modules/@lexical/markdown/LexicalMarkdown.dev.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+markdown@0.33.1/node_modules/@lexical/markdown/LexicalMarkdown.dev.mjs ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $convertFromMarkdownString: () => (/* binding */ $convertFromMarkdownString),\n/* harmony export */   $convertToMarkdownString: () => (/* binding */ $convertToMarkdownString),\n/* harmony export */   BOLD_ITALIC_STAR: () => (/* binding */ BOLD_ITALIC_STAR),\n/* harmony export */   BOLD_ITALIC_UNDERSCORE: () => (/* binding */ BOLD_ITALIC_UNDERSCORE),\n/* harmony export */   BOLD_STAR: () => (/* binding */ BOLD_STAR),\n/* harmony export */   BOLD_UNDERSCORE: () => (/* binding */ BOLD_UNDERSCORE),\n/* harmony export */   CHECK_LIST: () => (/* binding */ CHECK_LIST),\n/* harmony export */   CODE: () => (/* binding */ CODE),\n/* harmony export */   ELEMENT_TRANSFORMERS: () => (/* binding */ ELEMENT_TRANSFORMERS),\n/* harmony export */   HEADING: () => (/* binding */ HEADING),\n/* harmony export */   HIGHLIGHT: () => (/* binding */ HIGHLIGHT),\n/* harmony export */   INLINE_CODE: () => (/* binding */ INLINE_CODE),\n/* harmony export */   ITALIC_STAR: () => (/* binding */ ITALIC_STAR),\n/* harmony export */   ITALIC_UNDERSCORE: () => (/* binding */ ITALIC_UNDERSCORE),\n/* harmony export */   LINK: () => (/* binding */ LINK),\n/* harmony export */   MULTILINE_ELEMENT_TRANSFORMERS: () => (/* binding */ MULTILINE_ELEMENT_TRANSFORMERS),\n/* harmony export */   ORDERED_LIST: () => (/* binding */ ORDERED_LIST),\n/* harmony export */   QUOTE: () => (/* binding */ QUOTE),\n/* harmony export */   STRIKETHROUGH: () => (/* binding */ STRIKETHROUGH),\n/* harmony export */   TEXT_FORMAT_TRANSFORMERS: () => (/* binding */ TEXT_FORMAT_TRANSFORMERS),\n/* harmony export */   TEXT_MATCH_TRANSFORMERS: () => (/* binding */ TEXT_MATCH_TRANSFORMERS),\n/* harmony export */   TRANSFORMERS: () => (/* binding */ TRANSFORMERS),\n/* harmony export */   UNORDERED_LIST: () => (/* binding */ UNORDERED_LIST),\n/* harmony export */   registerMarkdownShortcuts: () => (/* binding */ registerMarkdownShortcuts)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/.pnpm/lexical@0.33.1/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_list__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/list */ \"(ssr)/./node_modules/.pnpm/@lexical+list@0.33.1/node_modules/@lexical/list/LexicalList.dev.mjs\");\n/* harmony import */ var _lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/rich-text */ \"(ssr)/./node_modules/.pnpm/@lexical+rich-text@0.33.1/node_modules/@lexical/rich-text/LexicalRichText.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/.pnpm/@lexical+utils@0.33.1/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var _lexical_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lexical/code */ \"(ssr)/./node_modules/.pnpm/@lexical+code@0.33.1/node_modules/@lexical/code/LexicalCode.dev.mjs\");\n/* harmony import */ var _lexical_link__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/link */ \"(ssr)/./node_modules/.pnpm/@lexical+link@0.33.1/node_modules/@lexical/link/LexicalLink.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction indexBy(list, callback) {\n  const index = {};\n  for (const item of list) {\n    const key = callback(item);\n    if (!key) {\n      continue;\n    }\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    multilineElement: byType['multiline-element'] || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nfunction isEmptyParagraph(node) {\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isParagraphNode)(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Renders string from markdown. The selection is moved to the start after the operation.\n */\nfunction createMarkdownExport(transformers, shouldPreserveNewLines = false) {\n  const byType = transformersByType(transformers);\n  const elementTransformers = [...byType.multilineElement, ...byType.element];\n  const isNewlineDelimited = !shouldPreserveNewLines;\n\n  // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1)\n  // Make sure all text transformers that contain 'code' in their format are at the end of the array. Otherwise, formatted code like\n  // <strong><code>code</code></strong> will be exported as `**Bold Code**`, as the code format will be applied first, and the bold format\n  // will be applied second and thus skipped entirely, as the code format will prevent any further formatting.\n  .sort((a, b) => {\n    return Number(a.format.includes('code')) - Number(b.format.includes('code'));\n  });\n  return node => {\n    const output = [];\n    const children = (node || (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getRoot)()).getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const result = exportTopLevelElements(child, elementTransformers, textFormatTransformers, byType.textMatch);\n      if (result != null) {\n        output.push(\n        // separate consecutive group of texts with a line break: eg. [\"hello\", \"world\"] -> [\"hello\", \"/nworld\"]\n        isNewlineDelimited && i > 0 && !isEmptyParagraph(child) && !isEmptyParagraph(children[i - 1]) ? '\\n'.concat(result) : result);\n      }\n    }\n    // Ensure consecutive groups of texts are at least \\n\\n apart while each empty paragraph render as a newline.\n    // Eg. [\"hello\", \"\", \"\", \"hi\", \"\\nworld\"] -> \"hello\\n\\n\\nhi\\n\\nworld\"\n    return output.join('\\n');\n  };\n}\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    if (!transformer.export) {\n      continue;\n    }\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n    if (result != null) {\n      return result;\n    }\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isElementNode)(node)) {\n    return exportChildren(node, textTransformersIndex, textMatchTransformers);\n  } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isDecoratorNode)(node)) {\n    return node.getTextContent();\n  } else {\n    return null;\n  }\n}\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers, unclosedTags, unclosableTags) {\n  const output = [];\n  const children = node.getChildren();\n  // keep track of unclosed tags from the very beginning\n  if (!unclosedTags) {\n    unclosedTags = [];\n  }\n  if (!unclosableTags) {\n    unclosableTags = [];\n  }\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      if (!transformer.export) {\n        continue;\n      }\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers, unclosedTags,\n      // Add current unclosed tags to the list of unclosable tags - we don't want nested tags from\n      // textmatch transformers to close the outer ones, as that may result in invalid markdown.\n      // E.g. **text [text**](https://lexical.io)\n      // is invalid markdown, as the closing ** is inside the link.\n      //\n      [...unclosableTags, ...unclosedTags]), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex, unclosedTags, unclosableTags));\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isLineBreakNode)(child)) {\n      output.push('\\n');\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex, unclosedTags, unclosableTags));\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isElementNode)(child)) {\n      // empty paragraph returns \"\"\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers, unclosedTags, unclosableTags));\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isDecoratorNode)(child)) {\n      output.push(child.getTextContent());\n    }\n  }\n  return output.join('');\n}\nfunction exportTextFormat(node, textContent, textTransformers,\n// unclosed tags include the markdown tags that haven't been closed yet, and their associated formats\nunclosedTags, unclosableTags) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // If the node has no format, we use the original text.\n  // Otherwise, we escape leading and trailing whitespaces to their corresponding code points,\n  // ensuring the returned string maintains its original formatting, e.g., \"**&#32;&#32;&#32;foo&#32;&#32;&#32;**\".\n  let output = node.getFormat() === 0 ? textContent : escapeLeadingAndTrailingWhitespaces(textContent);\n  if (!node.hasFormat('code')) {\n    // Escape any markdown characters in the text content\n    output = output.replace(/([*_`~\\\\])/g, '\\\\$1');\n  }\n\n  // the opening tags to be added to the result\n  let openingTags = '';\n  // the closing tags to be added to the result\n  let closingTagsBefore = '';\n  let closingTagsAfter = '';\n  const prevNode = getTextSibling(node, true);\n  const nextNode = getTextSibling(node, false);\n  const applied = new Set();\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n\n    // dedup applied formats\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format);\n\n      // append the tag to openingTags, if it's not applied to the previous nodes,\n      // or the nodes before that (which would result in an unclosed tag)\n      if (!hasFormat(prevNode, format) || !unclosedTags.find(element => element.tag === tag)) {\n        unclosedTags.push({\n          format,\n          tag\n        });\n        openingTags += tag;\n      }\n    }\n  }\n\n  // close any tags in the same order they were applied, if necessary\n  for (let i = 0; i < unclosedTags.length; i++) {\n    const nodeHasFormat = hasFormat(node, unclosedTags[i].format);\n    const nextNodeHasFormat = hasFormat(nextNode, unclosedTags[i].format);\n\n    // prevent adding closing tag if next sibling will do it\n    if (nodeHasFormat && nextNodeHasFormat) {\n      continue;\n    }\n    const unhandledUnclosedTags = [...unclosedTags]; // Shallow copy to avoid modifying the original array\n\n    while (unhandledUnclosedTags.length > i) {\n      const unclosedTag = unhandledUnclosedTags.pop();\n\n      // If tag is unclosable, don't close it and leave it in the original array,\n      // So that it can be closed when it's no longer unclosable\n      if (unclosableTags && unclosedTag && unclosableTags.find(element => element.tag === unclosedTag.tag)) {\n        continue;\n      }\n      if (unclosedTag && typeof unclosedTag.tag === 'string') {\n        if (!nodeHasFormat) {\n          // Handles cases where the tag has not been closed before, e.g. if the previous node\n          // was a text match transformer that did not account for closing tags of the next node (e.g. a link)\n          closingTagsBefore += unclosedTag.tag;\n        } else if (!nextNodeHasFormat) {\n          closingTagsAfter += unclosedTag.tag;\n        }\n      }\n      // Mutate the original array to remove the closed tag\n      unclosedTags.pop();\n    }\n    break;\n  }\n  output = openingTags + output + closingTagsAfter;\n  // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n  return closingTagsBefore + output;\n}\n\n// Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n  while (sibling) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isElementNode)(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(sibling)) {\n      return sibling;\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isElementNode)(sibling)) {\n      return null;\n    }\n  }\n  return null;\n}\nfunction hasFormat(node, format) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(node) && node.hasFormat(format);\n}\nfunction escapeLeadingAndTrailingWhitespaces(textContent) {\n  return textContent.replace(/^\\s+|\\s+$/g, match => {\n    return [...match].map(char => '&#' + char.codePointAt(0) + ';').join('');\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction findOutermostTextFormatTransformer(textNode, textFormatTransformersIndex) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n  if (!match) {\n    return null;\n  }\n  const textFormatMatchStart = match.index || 0;\n  const textFormatMatchEnd = textFormatMatchStart + match[0].length;\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n  return {\n    endIndex: textFormatMatchEnd,\n    match,\n    startIndex: textFormatMatchStart,\n    transformer\n  };\n}\n\n// Finds first \"<tag>content<tag>\" match that is not nested into another tag\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n  if (openTagsMatch == null) {\n    return null;\n  }\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      }\n\n      // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n  return null;\n}\nfunction importTextFormatTransformer(textNode, startIndex, endIndex, transformer, match) {\n  const textContent = textNode.getTextContent();\n\n  // No text matches - we can safely process the text format match\n  let transformedNode, nodeAfter, nodeBefore;\n\n  // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n  if (match[0] === textContent) {\n    transformedNode = textNode;\n  } else {\n    if (startIndex === 0) {\n      [transformedNode, nodeAfter] = textNode.splitText(endIndex);\n    } else {\n      [nodeBefore, transformedNode, nodeAfter] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n  transformedNode.setTextContent(match[2]);\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!transformedNode.hasFormat(format)) {\n        transformedNode.toggleFormat(format);\n      }\n    }\n  }\n  return {\n    nodeAfter: nodeAfter,\n    nodeBefore: nodeBefore,\n    transformedNode: transformedNode\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction findOutermostTextMatchTransformer(textNode_, textMatchTransformers) {\n  const textNode = textNode_;\n  let foundMatchStartIndex = undefined;\n  let foundMatchEndIndex = undefined;\n  let foundMatchTransformer = undefined;\n  let foundMatch = undefined;\n  for (const transformer of textMatchTransformers) {\n    if (!transformer.replace || !transformer.importRegExp) {\n      continue;\n    }\n    const match = textNode.getTextContent().match(transformer.importRegExp);\n    if (!match) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = transformer.getEndIndex ? transformer.getEndIndex(textNode, match) : startIndex + match[0].length;\n    if (endIndex === false) {\n      continue;\n    }\n    if (foundMatchStartIndex === undefined || foundMatchEndIndex === undefined || startIndex < foundMatchStartIndex && endIndex > foundMatchEndIndex) {\n      foundMatchStartIndex = startIndex;\n      foundMatchEndIndex = endIndex;\n      foundMatchTransformer = transformer;\n      foundMatch = match;\n    }\n  }\n  if (foundMatchStartIndex === undefined || foundMatchEndIndex === undefined || foundMatchTransformer === undefined || foundMatch === undefined) {\n    return null;\n  }\n  return {\n    endIndex: foundMatchEndIndex,\n    match: foundMatch,\n    startIndex: foundMatchStartIndex,\n    transformer: foundMatchTransformer\n  };\n}\nfunction importFoundTextMatchTransformer(textNode, startIndex, endIndex, transformer, match) {\n  let transformedNode, nodeAfter, nodeBefore;\n  if (startIndex === 0) {\n    [transformedNode, nodeAfter] = textNode.splitText(endIndex);\n  } else {\n    [nodeBefore, transformedNode, nodeAfter] = textNode.splitText(startIndex, endIndex);\n  }\n  if (!transformer.replace) {\n    return null;\n  }\n  const potentialTransformedNode = transformer.replace(transformedNode, match);\n  return {\n    nodeAfter,\n    nodeBefore,\n    transformedNode: potentialTransformedNode || undefined\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Returns true if the node can contain transformable markdown.\n * Code nodes cannot contain transformable markdown.\n * For example, `code **bold**` should not be transformed to\n * <code>code <strong>bold</strong></code>.\n */\nfunction canContainTransformableMarkdown(node) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(node) && !node.hasFormat('code');\n}\n\n/**\n * Handles applying both text format and text match transformers.\n * It finds the outermost text format or text match and applies it,\n * then recursively calls itself to apply the next outermost transformer,\n * until there are no more transformers to apply.\n */\nfunction importTextTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  let foundTextFormat = findOutermostTextFormatTransformer(textNode, textFormatTransformersIndex);\n  let foundTextMatch = findOutermostTextMatchTransformer(textNode, textMatchTransformers);\n  if (foundTextFormat && foundTextMatch) {\n    // Find the outermost transformer\n    if (foundTextFormat.startIndex <= foundTextMatch.startIndex && foundTextFormat.endIndex >= foundTextMatch.endIndex) {\n      // foundTextFormat wraps foundTextMatch - apply foundTextFormat by setting foundTextMatch to null\n      foundTextMatch = null;\n    } else {\n      // foundTextMatch wraps foundTextFormat - apply foundTextMatch by setting foundTextFormat to null\n      foundTextFormat = null;\n    }\n  }\n  if (foundTextFormat) {\n    const result = importTextFormatTransformer(textNode, foundTextFormat.startIndex, foundTextFormat.endIndex, foundTextFormat.transformer, foundTextFormat.match);\n    if (canContainTransformableMarkdown(result.nodeAfter)) {\n      importTextTransformers(result.nodeAfter, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.nodeBefore)) {\n      importTextTransformers(result.nodeBefore, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.transformedNode)) {\n      importTextTransformers(result.transformedNode, textFormatTransformersIndex, textMatchTransformers);\n    }\n  } else if (foundTextMatch) {\n    const result = importFoundTextMatchTransformer(textNode, foundTextMatch.startIndex, foundTextMatch.endIndex, foundTextMatch.transformer, foundTextMatch.match);\n    if (!result) {\n      return;\n    }\n    if (canContainTransformableMarkdown(result.nodeAfter)) {\n      importTextTransformers(result.nodeAfter, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.nodeBefore)) {\n      importTextTransformers(result.nodeBefore, textFormatTransformersIndex, textMatchTransformers);\n    }\n    if (canContainTransformableMarkdown(result.transformedNode)) {\n      importTextTransformers(result.transformedNode, textFormatTransformersIndex, textMatchTransformers);\n    }\n  }\n\n  // Handle escape characters\n  const textContent = textNode.getTextContent();\n  const escapedText = textContent.replace(/\\\\([*_`~\\\\])/g, '$1').replace(/&#(\\d+);/g, (_, codePoint) => {\n    return String.fromCodePoint(codePoint);\n  });\n  textNode.setTextContent(escapedText);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Renders markdown from a string. The selection is moved to the start after the operation.\n */\nfunction createMarkdownImport(transformers, shouldPreserveNewLines = false) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return (markdownString, node) => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = node || (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getRoot)();\n    root.clear();\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i];\n      const [imported, shiftedIndex] = $importMultiline(lines, i, byType.multilineElement, root);\n      if (imported) {\n        // If a multiline markdown element was imported, we don't want to process the lines that were part of it anymore.\n        // There could be other sub-markdown elements (both multiline and normal ones) matching within this matched multiline element's children.\n        // However, it would be the responsibility of the matched multiline transformer to decide how it wants to handle them.\n        // We cannot handle those, as there is no way for us to know how to maintain the correct order of generated lexical nodes for possible children.\n        i = shiftedIndex; // Next loop will start from the line after the last line of the multiline element\n        continue;\n      }\n      $importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch, shouldPreserveNewLines);\n    }\n\n    // By default, removing empty paragraphs as md does not really\n    // allow empty lines and uses them as delimiter.\n    // If you need empty lines set shouldPreserveNewLines = true.\n    const children = root.getChildren();\n    for (const child of children) {\n      if (!shouldPreserveNewLines && isEmptyParagraph(child) && root.getChildrenSize() > 1) {\n        child.remove();\n      }\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)() !== null) {\n      root.selectStart();\n    }\n  };\n}\n\n/**\n *\n * @returns first element of the returned tuple is a boolean indicating if a multiline element was imported. The second element is the index of the last line that was processed.\n */\nfunction $importMultiline(lines, startLineIndex, multilineElementTransformers, rootNode) {\n  for (const transformer of multilineElementTransformers) {\n    const {\n      handleImportAfterStartMatch,\n      regExpEnd,\n      regExpStart,\n      replace\n    } = transformer;\n    const startMatch = lines[startLineIndex].match(regExpStart);\n    if (!startMatch) {\n      continue; // Try next transformer\n    }\n    if (handleImportAfterStartMatch) {\n      const result = handleImportAfterStartMatch({\n        lines,\n        rootNode,\n        startLineIndex,\n        startMatch,\n        transformer\n      });\n      if (result === null) {\n        continue;\n      } else if (result) {\n        return result;\n      }\n    }\n    const regexpEndRegex = typeof regExpEnd === 'object' && 'regExp' in regExpEnd ? regExpEnd.regExp : regExpEnd;\n    const isEndOptional = regExpEnd && typeof regExpEnd === 'object' && 'optional' in regExpEnd ? regExpEnd.optional : !regExpEnd;\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n\n    // check every single line for the closing match. It could also be on the same line as the opening match.\n    while (endLineIndex < linesLength) {\n      const endMatch = regexpEndRegex ? lines[endLineIndex].match(regexpEndRegex) : null;\n      if (!endMatch) {\n        if (!isEndOptional || isEndOptional && endLineIndex < linesLength - 1 // Optional end, but didn't reach the end of the document yet => continue searching for potential closing match\n        ) {\n          endLineIndex++;\n          continue; // Search next line for closing match\n        }\n      }\n\n      // Now, check if the closing match matched is the same as the opening match.\n      // If it is, we need to continue searching for the actual closing match.\n      if (endMatch && startLineIndex === endLineIndex && endMatch.index === startMatch.index) {\n        endLineIndex++;\n        continue; // Search next line for closing match\n      }\n\n      // At this point, we have found the closing match. Next: calculate the lines in between open and closing match\n      // This should not include the matches themselves, and be split up by lines\n      const linesInBetween = [];\n      if (endMatch && startLineIndex === endLineIndex) {\n        linesInBetween.push(lines[startLineIndex].slice(startMatch[0].length, -endMatch[0].length));\n      } else {\n        for (let i = startLineIndex; i <= endLineIndex; i++) {\n          if (i === startLineIndex) {\n            const text = lines[i].slice(startMatch[0].length);\n            linesInBetween.push(text); // Also include empty text\n          } else if (i === endLineIndex && endMatch) {\n            const text = lines[i].slice(0, -endMatch[0].length);\n            linesInBetween.push(text); // Also include empty text\n          } else {\n            linesInBetween.push(lines[i]);\n          }\n        }\n      }\n      if (replace(rootNode, null, startMatch, endMatch, linesInBetween, true) !== false) {\n        // Return here. This $importMultiline function is run line by line and should only process a single multiline element at a time.\n        return [true, endLineIndex];\n      }\n\n      // The replace function returned false, despite finding the matching open and close tags => this transformer does not want to handle it.\n      // Thus, we continue letting the remaining transformers handle the passed lines of text from the beginning\n      break;\n    }\n  }\n\n  // No multiline transformer handled this line successfully\n  return [false, startLineIndex];\n}\nfunction $importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers, shouldPreserveNewLines) {\n  const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$createTextNode)(lineText);\n  const elementNode = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$createParagraphNode)();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      if (replace(elementNode, [textNode], match, true) !== false) {\n        break;\n      }\n    }\n  }\n  importTextTransformers(textNode, textFormatTransformersIndex, textMatchTransformers);\n\n  // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n  if (elementNode.isAttached() && lineText.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n    if (!shouldPreserveNewLines && (\n    // Only append if we're not preserving newlines\n    (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isParagraphNode)(previousNode) || (0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__.$isQuoteNode)(previousNode) || (0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(previousNode))) {\n      let targetNode = previousNode;\n      if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_4__.$findMatchingParent)(lastDescendant, _lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListItemNode);\n        }\n      }\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$createLineBreakNode)(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^|\\+)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n\n    // Single-char tag (e.g. \"*\"),\n    if (tag.length === 1) {\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n    } else {\n      // Multiâ€char tags (e.g. \"**\")\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<!\\\\\\\\)(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?!\\\\\\\\)`);\n    }\n  }\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Regexp to locate *any* potential opening tag (longest first).\n    openTagsRegExp: new RegExp(`${escapeRegExp}(${openTagsRegExp.join('|')})`, 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRootOrShadowRoot)(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent();\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n    if (match && match[0].length === (match[0].endsWith(' ') ? anchorOffset : anchorOffset - 1)) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      if (replace(parentNode, siblings, match, false) !== false) {\n        leadingNode.remove();\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRootOrShadowRoot)(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent();\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExpStart,\n    replace,\n    regExpEnd\n  } of elementTransformers) {\n    if (regExpEnd && !('optional' in regExpEnd) || regExpEnd && 'optional' in regExpEnd && !regExpEnd.optional) {\n      continue;\n    }\n    const match = textContent.match(regExpStart);\n    if (match && match[0].length === (match[0].endsWith(' ') ? anchorOffset : anchorOffset - 1)) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      if (replace(parentNode, siblings, match, null, null, false) !== false) {\n        leadingNode.remove();\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n  if (transformers == null) {\n    return false;\n  }\n\n  // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n  for (const transformer of transformers) {\n    if (!transformer.replace || !transformer.regExp) {\n      continue;\n    }\n    const match = textContent.match(transformer.regExp);\n    if (match === null) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n  return false;\n}\nfunction $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex];\n  // Quick check if we're possibly at the end of inline markdown style\n  const matchers = textFormatTransformers[closeChar];\n  if (!matchers) {\n    return false;\n  }\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1;\n\n    // If tag is not single char check if rest of it matches with text content\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    }\n\n    // Space before closing tag cancels inline markdown\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation after it\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag);\n\n    // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n    let sibling = openNode;\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isLineBreakNode)(sibling)) {\n        break;\n      }\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(sibling)) {\n        if (sibling.hasFormat('code')) {\n          continue;\n        }\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    }\n\n    // Opening tag is not found\n    if (openTagStartIndex < 0) {\n      continue;\n    }\n\n    // No content between opening and closing tag\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    }\n\n    // Checking longer tags for repeating chars (e.g. *** vs **)\n    const prevOpenNodeText = openNode.getTextContent();\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation before it\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    }\n\n    // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    const nextSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$createRangeSelection)();\n    (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$setSelection)(nextSelection);\n    // Adjust offset based on deleted chars\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text');\n\n    // Apply formatting to selected text\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    }\n\n    // Collapse selection up to the focus point\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type);\n\n    // Remove formatting from collapsed selection\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      nextSelection.format = selection.format;\n    }\n    return true;\n  }\n  return false;\n}\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) &&\n    // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n  return -1;\n}\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersByTrigger = indexBy(byType.textFormat, ({\n    tag\n  }) => tag[tag.length - 1]);\n  const textMatchTransformersByTrigger = indexBy(byType.textMatch, ({\n    trigger\n  }) => trigger);\n  for (const transformer of transformers) {\n    const type = transformer.type;\n    if (type === 'element' || type === 'text-match' || type === 'multiline-element') {\n      const dependencies = transformer.dependencies;\n      for (const node of dependencies) {\n        if (!editor.hasNode(node)) {\n          {\n            formatDevErrorMessage(`MarkdownShortcuts: missing dependency ${node.getType()} for transformer. Ensure node dependency is included in editor initial config.`);\n          }\n        }\n      }\n    }\n  }\n  const $transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n    if (runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, byType.multilineElement)) {\n      return;\n    }\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersByTrigger)) {\n      return;\n    }\n    $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersByTrigger);\n  };\n  return editor.registerUpdateListener(({\n    tags,\n    dirtyLeaves,\n    editorState,\n    prevEditorState\n  }) => {\n    // Ignore updates from collaboration and undo/redo (as changes already calculated)\n    if (tags.has(lexical__WEBPACK_IMPORTED_MODULE_1__.COLLABORATION_TAG) || tags.has(lexical__WEBPACK_IMPORTED_MODULE_1__.HISTORIC_TAG)) {\n      return;\n    }\n\n    // If editor is still composing (i.e. backticks) we must wait before the user confirms the key\n    if (editor.isComposing()) {\n      return;\n    }\n    const selection = editorState.read(lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection);\n    const prevSelection = prevEditorState.read(lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection);\n\n    // We expect selection to be a collapsed range and not match previous one (as we want\n    // to trigger transforms only as user types)\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(prevSelection) || !(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection) || !selection.isCollapsed() || selection.is(prevSelection)) {\n      return;\n    }\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1) {\n      return;\n    }\n    editor.update(() => {\n      if (!canContainTransformableMarkdown(anchorNode)) {\n        return;\n      }\n      const parentNode = anchorNode.getParent();\n      if (parentNode === null || (0,_lexical_code__WEBPACK_IMPORTED_MODULE_0__.$isCodeNode)(parentNode)) {\n        return;\n      }\n      $transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst ORDERED_LIST_REGEX = /^(\\s*)(\\d{1,})\\.\\s/;\nconst UNORDERED_LIST_REGEX = /^(\\s*)[-*+]\\s/;\nconst CHECK_LIST_REGEX = /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i;\nconst HEADING_REGEX = /^(#{1,6})\\s/;\nconst QUOTE_REGEX = /^>\\s/;\nconst CODE_START_REGEX = /^[ \\t]*```([\\w-]+)?/;\nconst CODE_END_REGEX = /[ \\t]*```$/;\nconst CODE_SINGLE_LINE_REGEX = /^[ \\t]*```[^`]+(?:(?:`{1,2}|`{4,})[^`]+)*```(?:[^`]|$)/;\nconst TABLE_ROW_REG_EXP = /^(?:\\|)(.+)(?:\\|)\\s?$/;\nconst TABLE_ROW_DIVIDER_REG_EXP = /^(\\| ?:?-*:? ?)+\\|\\s?$/;\nconst createBlockNode = createNode => {\n  return (parentNode, children, match, isImport) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    if (!isImport) {\n      node.select(0, 0);\n    }\n  };\n};\n\n// Amount of spaces that define indentation level\n// TODO: should be an option\nconst LIST_INDENT_SIZE = 4;\nfunction getIndent(whitespaces) {\n  const tabs = whitespaces.match(/\\t/g);\n  const spaces = whitespaces.match(/ /g);\n  let indent = 0;\n  if (tabs) {\n    indent += tabs.length;\n  }\n  if (spaces) {\n    indent += Math.floor(spaces.length / LIST_INDENT_SIZE);\n  }\n  return indent;\n}\nconst listReplace = listType => {\n  return (parentNode, children, match, isImport) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const nextNode = parentNode.getNextSibling();\n    const listItem = (0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$createListItemNode)(listType === 'check' ? match[3] === 'x' : undefined);\n    if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem);\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem);\n      }\n      parentNode.remove();\n    } else if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list = (0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$createListNode)(listType, listType === 'number' ? Number(match[2]) : undefined);\n      list.append(listItem);\n      parentNode.replace(list);\n    }\n    listItem.append(...children);\n    if (!isImport) {\n      listItem.select(0, 0);\n    }\n    const indent = getIndent(match[1]);\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\nconst listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n  for (const listItemNode of children) {\n    if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListItemNode)(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n        if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `- [${listItemNode.getChecked() ? 'x' : ' '}] ` : '- ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n  return output.join('\\n');\n};\nconst HEADING = {\n  dependencies: [_lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__.HeadingNode],\n  export: (node, exportChildren) => {\n    if (!(0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__.$isHeadingNode)(node)) {\n      return null;\n    }\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: HEADING_REGEX,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return (0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__.$createHeadingNode)(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [_lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__.QuoteNode],\n  export: (node, exportChildren) => {\n    if (!(0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__.$isQuoteNode)(node)) {\n      return null;\n    }\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n    return output.join('\\n');\n  },\n  regExp: QUOTE_REGEX,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n      if ((0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__.$isQuoteNode)(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$createLineBreakNode)(), ...children]);\n        parentNode.remove();\n        return;\n      }\n    }\n    const node = (0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__.$createQuoteNode)();\n    node.append(...children);\n    parentNode.replace(node);\n    if (!isImport) {\n      node.select(0, 0);\n    }\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [_lexical_code__WEBPACK_IMPORTED_MODULE_0__.CodeNode],\n  export: node => {\n    if (!(0,_lexical_code__WEBPACK_IMPORTED_MODULE_0__.$isCodeNode)(node)) {\n      return null;\n    }\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExpEnd: {\n    optional: true,\n    regExp: CODE_END_REGEX\n  },\n  regExpStart: CODE_START_REGEX,\n  replace: (rootNode, children, startMatch, endMatch, linesInBetween, isImport) => {\n    let codeBlockNode;\n    let code;\n    if (!children && linesInBetween) {\n      if (linesInBetween.length === 1) {\n        // Single-line code blocks\n        if (endMatch) {\n          // End match on same line. Example: ```markdown hello```. markdown should not be considered the language here.\n          codeBlockNode = (0,_lexical_code__WEBPACK_IMPORTED_MODULE_0__.$createCodeNode)();\n          code = startMatch[1] + linesInBetween[0];\n        } else {\n          // No end match. We should assume the language is next to the backticks and that code will be typed on the next line in the future\n          codeBlockNode = (0,_lexical_code__WEBPACK_IMPORTED_MODULE_0__.$createCodeNode)(startMatch[1]);\n          code = linesInBetween[0].startsWith(' ') ? linesInBetween[0].slice(1) : linesInBetween[0];\n        }\n      } else {\n        // Treat multi-line code blocks as if they always have an end match\n        codeBlockNode = (0,_lexical_code__WEBPACK_IMPORTED_MODULE_0__.$createCodeNode)(startMatch[1]);\n        if (linesInBetween[0].trim().length === 0) {\n          // Filter out all start and end lines that are length 0 until we find the first line with content\n          while (linesInBetween.length > 0 && !linesInBetween[0].length) {\n            linesInBetween.shift();\n          }\n        } else {\n          // The first line already has content => Remove the first space of the line if it exists\n          linesInBetween[0] = linesInBetween[0].startsWith(' ') ? linesInBetween[0].slice(1) : linesInBetween[0];\n        }\n\n        // Filter out all end lines that are length 0 until we find the last line with content\n        while (linesInBetween.length > 0 && !linesInBetween[linesInBetween.length - 1].length) {\n          linesInBetween.pop();\n        }\n        code = linesInBetween.join('\\n');\n      }\n      const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$createTextNode)(code);\n      codeBlockNode.append(textNode);\n      rootNode.append(codeBlockNode);\n    } else if (children) {\n      createBlockNode(match => {\n        return (0,_lexical_code__WEBPACK_IMPORTED_MODULE_0__.$createCodeNode)(match ? match[1] : undefined);\n      })(rootNode, children, startMatch, isImport);\n    }\n  },\n  type: 'multiline-element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [_lexical_list__WEBPACK_IMPORTED_MODULE_3__.ListNode, _lexical_list__WEBPACK_IMPORTED_MODULE_3__.ListItemNode],\n  export: (node, exportChildren) => {\n    return (0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: UNORDERED_LIST_REGEX,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [_lexical_list__WEBPACK_IMPORTED_MODULE_3__.ListNode, _lexical_list__WEBPACK_IMPORTED_MODULE_3__.ListItemNode],\n  export: (node, exportChildren) => {\n    return (0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: CHECK_LIST_REGEX,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [_lexical_list__WEBPACK_IMPORTED_MODULE_3__.ListNode, _lexical_list__WEBPACK_IMPORTED_MODULE_3__.ListItemNode],\n  export: (node, exportChildren) => {\n    return (0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: ORDERED_LIST_REGEX,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst HIGHLIGHT = {\n  format: ['highlight'],\n  tag: '==',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n};\n\n// Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst LINK = {\n  dependencies: [_lexical_link__WEBPACK_IMPORTED_MODULE_5__.LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!(0,_lexical_link__WEBPACK_IMPORTED_MODULE_5__.$isLinkNode)(node) || (0,_lexical_link__WEBPACK_IMPORTED_MODULE_5__.$isAutoLinkNode)(node)) {\n      return null;\n    }\n    const title = node.getTitle();\n    const textContent = exportChildren(node);\n    const linkContent = title ? `[${textContent}](${node.getURL()} \"${title}\")` : `[${textContent}](${node.getURL()})`;\n    return linkContent;\n  },\n  importRegExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))/,\n  regExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl, linkTitle] = match;\n    const linkNode = (0,_lexical_link__WEBPACK_IMPORTED_MODULE_5__.$createLinkNode)(linkUrl, {\n      title: linkTitle\n    });\n    const linkTextNode = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$createTextNode)(linkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n    return linkTextNode;\n  },\n  trigger: ')',\n  type: 'text-match'\n};\nfunction normalizeMarkdown(input, shouldMergeAdjacentLines = false) {\n  const lines = input.split('\\n');\n  let inCodeBlock = false;\n  const sanitizedLines = [];\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const lastLine = sanitizedLines[sanitizedLines.length - 1];\n\n    // Code blocks of ```single line``` don't toggle the inCodeBlock flag\n    if (CODE_SINGLE_LINE_REGEX.test(line)) {\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // Detect the start or end of a code block\n    if (CODE_START_REGEX.test(line) || CODE_END_REGEX.test(line)) {\n      inCodeBlock = !inCodeBlock;\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // If we are inside a code block, keep the line unchanged\n    if (inCodeBlock) {\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // In markdown the concept of \"empty paragraphs\" does not exist.\n    // Blocks must be separated by an empty line. Non-empty adjacent lines must be merged.\n    if (line === '' || lastLine === '' || !lastLine || HEADING_REGEX.test(lastLine) || HEADING_REGEX.test(line) || QUOTE_REGEX.test(line) || ORDERED_LIST_REGEX.test(line) || UNORDERED_LIST_REGEX.test(line) || CHECK_LIST_REGEX.test(line) || TABLE_ROW_REG_EXP.test(line) || TABLE_ROW_DIVIDER_REG_EXP.test(line) || !shouldMergeAdjacentLines) {\n      sanitizedLines.push(line);\n    } else {\n      sanitizedLines[sanitizedLines.length - 1] = lastLine + line;\n    }\n  }\n  return sanitizedLines.join('\\n');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, UNORDERED_LIST, ORDERED_LIST];\nconst MULTILINE_ELEMENT_TRANSFORMERS = [CODE];\n\n// Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...MULTILINE_ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\n\n/**\n * Renders markdown from a string. The selection is moved to the start after the operation.\n *\n *  @param {boolean} [shouldPreserveNewLines] By setting this to true, new lines will be preserved between conversions\n *  @param {boolean} [shouldMergeAdjacentLines] By setting this to true, adjacent non empty lines will be merged according to commonmark spec: https://spec.commonmark.org/0.24/#example-177. Not applicable if shouldPreserveNewLines = true.\n */\nfunction $convertFromMarkdownString(markdown, transformers = TRANSFORMERS, node, shouldPreserveNewLines = false, shouldMergeAdjacentLines = false) {\n  const sanitizedMarkdown = shouldPreserveNewLines ? markdown : normalizeMarkdown(markdown, shouldMergeAdjacentLines);\n  const importMarkdown = createMarkdownImport(transformers, shouldPreserveNewLines);\n  return importMarkdown(sanitizedMarkdown, node);\n}\n\n/**\n * Renders string from markdown. The selection is moved to the start after the operation.\n */\nfunction $convertToMarkdownString(transformers = TRANSFORMERS, node, shouldPreserveNewLines = false) {\n  const exportMarkdown = createMarkdownExport(transformers, shouldPreserveNewLines);\n  return exportMarkdown(node);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrbWFya2Rvd25AMC4zMy4xL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9tYXJrZG93bi9MZXhpY2FsTWFya2Rvd24uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaVQ7QUFDdEw7QUFDSztBQUMzRTtBQUNrQjtBQUNpQjs7QUFFeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMseUNBQXlDLElBQUk7QUFDN0M7QUFDQSxPQUFPLHlEQUFnQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsb0RBQVc7QUFDMUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDhCQUE4QixpREFBUTtBQUN0QyxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVEQUFjO0FBQ3BCO0FBQ0EsSUFBSSxTQUFTLHlEQUFnQjtBQUM3QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFnQjtBQUN4QjtBQUNBLE1BQU0sU0FBUyxvREFBVztBQUMxQjtBQUNBLE1BQU0sU0FBUyx1REFBYztBQUM3QjtBQUNBO0FBQ0EsTUFBTSxTQUFTLHlEQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsS0FBSyxLQUFLLFFBQVEsS0FBSyxLQUFLO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBVztBQUNyQjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7QUFDQSxTQUFTLHVEQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0RBQVc7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvREFBVztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQVE7QUFDakM7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLFlBQVk7QUFDWjtBQUNBLHVDQUF1QztBQUN2QyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdEQUFlO0FBQ2xDLHNCQUFzQiw2REFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlEQUFnQixrQkFBa0IsZ0VBQVksa0JBQWtCLDBEQUFXO0FBQy9FO0FBQ0EsVUFBVSwwREFBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsdUJBQXVCLG1FQUFtQixpQkFBaUIsMERBQWU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDZEQUFvQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RCxVQUFVLEtBQUssVUFBVSxTQUFTLFVBQVUsU0FBUyxVQUFVLFdBQVcsVUFBVSwrQkFBK0IsVUFBVSxXQUFXLFVBQVU7QUFDM00sTUFBTTtBQUNOO0FBQ0EsMERBQTBELFVBQVUsU0FBUyxVQUFVLGtCQUFrQixVQUFVLCtCQUErQixVQUFVO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhLEdBQUcseUJBQXlCO0FBQzNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sNERBQW1CO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw0REFBbUI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseURBQWdCO0FBQzFCO0FBQ0E7QUFDQSxVQUFVLG9EQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DLDBCQUEwQiw4REFBcUI7QUFDL0MsSUFBSSxzREFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsZ0JBQWdCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLHNEQUFpQixjQUFjLGlEQUFZO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0RBQWE7QUFDcEQsK0NBQStDLGtEQUFhOztBQUU1RDtBQUNBO0FBQ0EsU0FBUywwREFBaUIsb0JBQW9CLDBEQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvREFBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwREFBVztBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxHQUFHO0FBQ3pDO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsSUFBSSxHQUFHLEdBQUc7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtFQUFtQjtBQUN4QyxRQUFRLDBEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUywwREFBVztBQUMxQjtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQiw4REFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhEQUFlO0FBQ3ZCO0FBQ0E7QUFDQSxZQUFZLDBEQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw0QkFBNEIsbUNBQW1DLHNDQUFzQztBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyREFBVztBQUM1QjtBQUNBLFNBQVMsa0VBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzRUFBa0I7QUFDN0IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5REFBUztBQUMxQjtBQUNBLFNBQVMsZ0VBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0VBQVk7QUFDdEIsZ0VBQWdFLDZEQUFvQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvRUFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbURBQVE7QUFDekI7QUFDQSxTQUFTLDBEQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOERBQWU7QUFDekM7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwwQkFBMEIsOERBQWU7QUFDekM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHdCQUF3Qiw4REFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQWU7QUFDdEM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGVBQWUsOERBQWU7QUFDOUIsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtREFBUSxFQUFFLHVEQUFZO0FBQ3ZDO0FBQ0EsV0FBVywwREFBVztBQUN0QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtREFBUSxFQUFFLHVEQUFZO0FBQ3ZDO0FBQ0EsV0FBVywwREFBVztBQUN0QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtREFBUSxFQUFFLHVEQUFZO0FBQ3ZDO0FBQ0EsV0FBVywwREFBVztBQUN0QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtREFBUTtBQUN6QjtBQUNBLFNBQVMsMERBQVcsVUFBVSw4REFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZLElBQUksZUFBZSxHQUFHLE1BQU0sVUFBVSxZQUFZLElBQUksY0FBYztBQUNwSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4REFBZTtBQUNwQztBQUNBLEtBQUs7QUFDTCx5QkFBeUIsd0RBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFhIiwic291cmNlcyI6WyIvVXNlcnMvYW5raXRocmVkZHkvRGVza3RvcC9oYWNrYXRob25zL2thZ2dsZWdlbW1hL2xlcmVwYWlyYm90aW5mZXJlbmNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9AbGV4aWNhbCttYXJrZG93bkAwLjMzLjEvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL21hcmtkb3duL0xleGljYWxNYXJrZG93bi5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGlzUGFyYWdyYXBoTm9kZSwgJGlzVGV4dE5vZGUsICRnZXRSb290LCAkaXNFbGVtZW50Tm9kZSwgJGlzRGVjb3JhdG9yTm9kZSwgJGlzTGluZUJyZWFrTm9kZSwgJGdldFNlbGVjdGlvbiwgJGNyZWF0ZVRleHROb2RlLCAkY3JlYXRlUGFyYWdyYXBoTm9kZSwgJGNyZWF0ZUxpbmVCcmVha05vZGUsIENPTExBQk9SQVRJT05fVEFHLCBISVNUT1JJQ19UQUcsICRpc1JhbmdlU2VsZWN0aW9uLCAkaXNSb290T3JTaGFkb3dSb290LCAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24sICRzZXRTZWxlY3Rpb24gfSBmcm9tICdsZXhpY2FsJztcbmltcG9ydCB7ICRpc0xpc3ROb2RlLCAkaXNMaXN0SXRlbU5vZGUsIExpc3ROb2RlLCBMaXN0SXRlbU5vZGUsICRjcmVhdGVMaXN0SXRlbU5vZGUsICRjcmVhdGVMaXN0Tm9kZSB9IGZyb20gJ0BsZXhpY2FsL2xpc3QnO1xuaW1wb3J0IHsgJGlzUXVvdGVOb2RlLCBIZWFkaW5nTm9kZSwgJGlzSGVhZGluZ05vZGUsIFF1b3RlTm9kZSwgJGNyZWF0ZVF1b3RlTm9kZSwgJGNyZWF0ZUhlYWRpbmdOb2RlIH0gZnJvbSAnQGxleGljYWwvcmljaC10ZXh0JztcbmltcG9ydCB7ICRmaW5kTWF0Y2hpbmdQYXJlbnQgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyAkaXNDb2RlTm9kZSwgQ29kZU5vZGUsICRjcmVhdGVDb2RlTm9kZSB9IGZyb20gJ0BsZXhpY2FsL2NvZGUnO1xuaW1wb3J0IHsgTGlua05vZGUsICRpc0xpbmtOb2RlLCAkaXNBdXRvTGlua05vZGUsICRjcmVhdGVMaW5rTm9kZSB9IGZyb20gJ0BsZXhpY2FsL2xpbmsnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGluZGV4QnkobGlzdCwgY2FsbGJhY2spIHtcbiAgY29uc3QgaW5kZXggPSB7fTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIGxpc3QpIHtcbiAgICBjb25zdCBrZXkgPSBjYWxsYmFjayhpdGVtKTtcbiAgICBpZiAoIWtleSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpbmRleFtrZXldKSB7XG4gICAgICBpbmRleFtrZXldLnB1c2goaXRlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4W2tleV0gPSBbaXRlbV07XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyc0J5VHlwZSh0cmFuc2Zvcm1lcnMpIHtcbiAgY29uc3QgYnlUeXBlID0gaW5kZXhCeSh0cmFuc2Zvcm1lcnMsIHQgPT4gdC50eXBlKTtcbiAgcmV0dXJuIHtcbiAgICBlbGVtZW50OiBieVR5cGUuZWxlbWVudCB8fCBbXSxcbiAgICBtdWx0aWxpbmVFbGVtZW50OiBieVR5cGVbJ211bHRpbGluZS1lbGVtZW50J10gfHwgW10sXG4gICAgdGV4dEZvcm1hdDogYnlUeXBlWyd0ZXh0LWZvcm1hdCddIHx8IFtdLFxuICAgIHRleHRNYXRjaDogYnlUeXBlWyd0ZXh0LW1hdGNoJ10gfHwgW11cbiAgfTtcbn1cbmNvbnN0IFBVTkNUVUFUSU9OX09SX1NQQUNFID0gL1shLS86LUBbLWB7LX5cXHNdLztcbmNvbnN0IE1BUktET1dOX0VNUFRZX0xJTkVfUkVHX0VYUCA9IC9eXFxzezAsM30kLztcbmZ1bmN0aW9uIGlzRW1wdHlQYXJhZ3JhcGgobm9kZSkge1xuICBpZiAoISRpc1BhcmFncmFwaE5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZmlyc3RDaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICByZXR1cm4gZmlyc3RDaGlsZCA9PSBudWxsIHx8IG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDEgJiYgJGlzVGV4dE5vZGUoZmlyc3RDaGlsZCkgJiYgTUFSS0RPV05fRU1QVFlfTElORV9SRUdfRVhQLnRlc3QoZmlyc3RDaGlsZC5nZXRUZXh0Q29udGVudCgpKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8qKlxuICogUmVuZGVycyBzdHJpbmcgZnJvbSBtYXJrZG93bi4gVGhlIHNlbGVjdGlvbiBpcyBtb3ZlZCB0byB0aGUgc3RhcnQgYWZ0ZXIgdGhlIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWFya2Rvd25FeHBvcnQodHJhbnNmb3JtZXJzLCBzaG91bGRQcmVzZXJ2ZU5ld0xpbmVzID0gZmFsc2UpIHtcbiAgY29uc3QgYnlUeXBlID0gdHJhbnNmb3JtZXJzQnlUeXBlKHRyYW5zZm9ybWVycyk7XG4gIGNvbnN0IGVsZW1lbnRUcmFuc2Zvcm1lcnMgPSBbLi4uYnlUeXBlLm11bHRpbGluZUVsZW1lbnQsIC4uLmJ5VHlwZS5lbGVtZW50XTtcbiAgY29uc3QgaXNOZXdsaW5lRGVsaW1pdGVkID0gIXNob3VsZFByZXNlcnZlTmV3TGluZXM7XG5cbiAgLy8gRXhwb3J0IG9ubHkgdXNlcyB0ZXh0IGZvcm1hdHMgdGhhdCBhcmUgcmVzcG9uc2libGUgZm9yIHNpbmdsZSBmb3JtYXRcbiAgLy8gZS5nLiBpdCB3aWxsIGZpbHRlciBvdXQgKioqIChib2xkLCBpdGFsaWMpIGFuZCBpbnN0ZWFkIHVzZSBzZXBhcmF0ZSAqKiBhbmQgKlxuICBjb25zdCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzID0gYnlUeXBlLnRleHRGb3JtYXQuZmlsdGVyKHRyYW5zZm9ybWVyID0+IHRyYW5zZm9ybWVyLmZvcm1hdC5sZW5ndGggPT09IDEpXG4gIC8vIE1ha2Ugc3VyZSBhbGwgdGV4dCB0cmFuc2Zvcm1lcnMgdGhhdCBjb250YWluICdjb2RlJyBpbiB0aGVpciBmb3JtYXQgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LiBPdGhlcndpc2UsIGZvcm1hdHRlZCBjb2RlIGxpa2VcbiAgLy8gPHN0cm9uZz48Y29kZT5jb2RlPC9jb2RlPjwvc3Ryb25nPiB3aWxsIGJlIGV4cG9ydGVkIGFzIGAqKkJvbGQgQ29kZSoqYCwgYXMgdGhlIGNvZGUgZm9ybWF0IHdpbGwgYmUgYXBwbGllZCBmaXJzdCwgYW5kIHRoZSBib2xkIGZvcm1hdFxuICAvLyB3aWxsIGJlIGFwcGxpZWQgc2Vjb25kIGFuZCB0aHVzIHNraXBwZWQgZW50aXJlbHksIGFzIHRoZSBjb2RlIGZvcm1hdCB3aWxsIHByZXZlbnQgYW55IGZ1cnRoZXIgZm9ybWF0dGluZy5cbiAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICByZXR1cm4gTnVtYmVyKGEuZm9ybWF0LmluY2x1ZGVzKCdjb2RlJykpIC0gTnVtYmVyKGIuZm9ybWF0LmluY2x1ZGVzKCdjb2RlJykpO1xuICB9KTtcbiAgcmV0dXJuIG5vZGUgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gKG5vZGUgfHwgJGdldFJvb3QoKSkuZ2V0Q2hpbGRyZW4oKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXhwb3J0VG9wTGV2ZWxFbGVtZW50cyhjaGlsZCwgZWxlbWVudFRyYW5zZm9ybWVycywgdGV4dEZvcm1hdFRyYW5zZm9ybWVycywgYnlUeXBlLnRleHRNYXRjaCk7XG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goXG4gICAgICAgIC8vIHNlcGFyYXRlIGNvbnNlY3V0aXZlIGdyb3VwIG9mIHRleHRzIHdpdGggYSBsaW5lIGJyZWFrOiBlZy4gW1wiaGVsbG9cIiwgXCJ3b3JsZFwiXSAtPiBbXCJoZWxsb1wiLCBcIi9ud29ybGRcIl1cbiAgICAgICAgaXNOZXdsaW5lRGVsaW1pdGVkICYmIGkgPiAwICYmICFpc0VtcHR5UGFyYWdyYXBoKGNoaWxkKSAmJiAhaXNFbXB0eVBhcmFncmFwaChjaGlsZHJlbltpIC0gMV0pID8gJ1xcbicuY29uY2F0KHJlc3VsdCkgOiByZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBFbnN1cmUgY29uc2VjdXRpdmUgZ3JvdXBzIG9mIHRleHRzIGFyZSBhdCBsZWFzdCBcXG5cXG4gYXBhcnQgd2hpbGUgZWFjaCBlbXB0eSBwYXJhZ3JhcGggcmVuZGVyIGFzIGEgbmV3bGluZS5cbiAgICAvLyBFZy4gW1wiaGVsbG9cIiwgXCJcIiwgXCJcIiwgXCJoaVwiLCBcIlxcbndvcmxkXCJdIC0+IFwiaGVsbG9cXG5cXG5cXG5oaVxcblxcbndvcmxkXCJcbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oJ1xcbicpO1xuICB9O1xufVxuZnVuY3Rpb24gZXhwb3J0VG9wTGV2ZWxFbGVtZW50cyhub2RlLCBlbGVtZW50VHJhbnNmb3JtZXJzLCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycykge1xuICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIGVsZW1lbnRUcmFuc2Zvcm1lcnMpIHtcbiAgICBpZiAoIXRyYW5zZm9ybWVyLmV4cG9ydCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRyYW5zZm9ybWVyLmV4cG9ydChub2RlLCBfbm9kZSA9PiBleHBvcnRDaGlsZHJlbihfbm9kZSwgdGV4dFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpKTtcbiAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIHJldHVybiBleHBvcnRDaGlsZHJlbihub2RlLCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycyk7XG4gIH0gZWxzZSBpZiAoJGlzRGVjb3JhdG9yTm9kZShub2RlKSkge1xuICAgIHJldHVybiBub2RlLmdldFRleHRDb250ZW50KCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4cG9ydENoaWxkcmVuKG5vZGUsIHRleHRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzLCB1bmNsb3NlZFRhZ3MsIHVuY2xvc2FibGVUYWdzKSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgLy8ga2VlcCB0cmFjayBvZiB1bmNsb3NlZCB0YWdzIGZyb20gdGhlIHZlcnkgYmVnaW5uaW5nXG4gIGlmICghdW5jbG9zZWRUYWdzKSB7XG4gICAgdW5jbG9zZWRUYWdzID0gW107XG4gIH1cbiAgaWYgKCF1bmNsb3NhYmxlVGFncykge1xuICAgIHVuY2xvc2FibGVUYWdzID0gW107XG4gIH1cbiAgbWFpbkxvb3A6IGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRleHRNYXRjaFRyYW5zZm9ybWVycykge1xuICAgICAgaWYgKCF0cmFuc2Zvcm1lci5leHBvcnQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB0cmFuc2Zvcm1lci5leHBvcnQoY2hpbGQsIHBhcmVudE5vZGUgPT4gZXhwb3J0Q2hpbGRyZW4ocGFyZW50Tm9kZSwgdGV4dFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMsIHVuY2xvc2VkVGFncyxcbiAgICAgIC8vIEFkZCBjdXJyZW50IHVuY2xvc2VkIHRhZ3MgdG8gdGhlIGxpc3Qgb2YgdW5jbG9zYWJsZSB0YWdzIC0gd2UgZG9uJ3Qgd2FudCBuZXN0ZWQgdGFncyBmcm9tXG4gICAgICAvLyB0ZXh0bWF0Y2ggdHJhbnNmb3JtZXJzIHRvIGNsb3NlIHRoZSBvdXRlciBvbmVzLCBhcyB0aGF0IG1heSByZXN1bHQgaW4gaW52YWxpZCBtYXJrZG93bi5cbiAgICAgIC8vIEUuZy4gKip0ZXh0IFt0ZXh0KipdKGh0dHBzOi8vbGV4aWNhbC5pbylcbiAgICAgIC8vIGlzIGludmFsaWQgbWFya2Rvd24sIGFzIHRoZSBjbG9zaW5nICoqIGlzIGluc2lkZSB0aGUgbGluay5cbiAgICAgIC8vXG4gICAgICBbLi4udW5jbG9zYWJsZVRhZ3MsIC4uLnVuY2xvc2VkVGFnc10pLCAodGV4dE5vZGUsIHRleHRDb250ZW50KSA9PiBleHBvcnRUZXh0Rm9ybWF0KHRleHROb2RlLCB0ZXh0Q29udGVudCwgdGV4dFRyYW5zZm9ybWVyc0luZGV4LCB1bmNsb3NlZFRhZ3MsIHVuY2xvc2FibGVUYWdzKSk7XG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgb3V0cHV0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgY29udGludWUgbWFpbkxvb3A7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkaXNMaW5lQnJlYWtOb2RlKGNoaWxkKSkge1xuICAgICAgb3V0cHV0LnB1c2goJ1xcbicpO1xuICAgIH0gZWxzZSBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICBvdXRwdXQucHVzaChleHBvcnRUZXh0Rm9ybWF0KGNoaWxkLCBjaGlsZC5nZXRUZXh0Q29udGVudCgpLCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgsIHVuY2xvc2VkVGFncywgdW5jbG9zYWJsZVRhZ3MpKTtcbiAgICB9IGVsc2UgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSkge1xuICAgICAgLy8gZW1wdHkgcGFyYWdyYXBoIHJldHVybnMgXCJcIlxuICAgICAgb3V0cHV0LnB1c2goZXhwb3J0Q2hpbGRyZW4oY2hpbGQsIHRleHRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzLCB1bmNsb3NlZFRhZ3MsIHVuY2xvc2FibGVUYWdzKSk7XG4gICAgfSBlbHNlIGlmICgkaXNEZWNvcmF0b3JOb2RlKGNoaWxkKSkge1xuICAgICAgb3V0cHV0LnB1c2goY2hpbGQuZ2V0VGV4dENvbnRlbnQoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJyk7XG59XG5mdW5jdGlvbiBleHBvcnRUZXh0Rm9ybWF0KG5vZGUsIHRleHRDb250ZW50LCB0ZXh0VHJhbnNmb3JtZXJzLFxuLy8gdW5jbG9zZWQgdGFncyBpbmNsdWRlIHRoZSBtYXJrZG93biB0YWdzIHRoYXQgaGF2ZW4ndCBiZWVuIGNsb3NlZCB5ZXQsIGFuZCB0aGVpciBhc3NvY2lhdGVkIGZvcm1hdHNcbnVuY2xvc2VkVGFncywgdW5jbG9zYWJsZVRhZ3MpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBoYW5kbGVzIHRoZSBjYXNlIG9mIGEgc3RyaW5nIGxvb2tpbmcgbGlrZSB0aGlzOiBcIiAgIGZvbyAgIFwiXG4gIC8vIFdoZXJlIGl0IHdvdWxkIGJlIGludmFsaWQgbWFya2Rvd24gdG8gZ2VuZXJhdGU6IFwiKiogICBmb28gICAqKlwiXG4gIC8vIElmIHRoZSBub2RlIGhhcyBubyBmb3JtYXQsIHdlIHVzZSB0aGUgb3JpZ2luYWwgdGV4dC5cbiAgLy8gT3RoZXJ3aXNlLCB3ZSBlc2NhcGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZXMgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBjb2RlIHBvaW50cyxcbiAgLy8gZW5zdXJpbmcgdGhlIHJldHVybmVkIHN0cmluZyBtYWludGFpbnMgaXRzIG9yaWdpbmFsIGZvcm1hdHRpbmcsIGUuZy4sIFwiKiomIzMyOyYjMzI7JiMzMjtmb28mIzMyOyYjMzI7JiMzMjsqKlwiLlxuICBsZXQgb3V0cHV0ID0gbm9kZS5nZXRGb3JtYXQoKSA9PT0gMCA/IHRleHRDb250ZW50IDogZXNjYXBlTGVhZGluZ0FuZFRyYWlsaW5nV2hpdGVzcGFjZXModGV4dENvbnRlbnQpO1xuICBpZiAoIW5vZGUuaGFzRm9ybWF0KCdjb2RlJykpIHtcbiAgICAvLyBFc2NhcGUgYW55IG1hcmtkb3duIGNoYXJhY3RlcnMgaW4gdGhlIHRleHQgY29udGVudFxuICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC8oWypfYH5cXFxcXSkvZywgJ1xcXFwkMScpO1xuICB9XG5cbiAgLy8gdGhlIG9wZW5pbmcgdGFncyB0byBiZSBhZGRlZCB0byB0aGUgcmVzdWx0XG4gIGxldCBvcGVuaW5nVGFncyA9ICcnO1xuICAvLyB0aGUgY2xvc2luZyB0YWdzIHRvIGJlIGFkZGVkIHRvIHRoZSByZXN1bHRcbiAgbGV0IGNsb3NpbmdUYWdzQmVmb3JlID0gJyc7XG4gIGxldCBjbG9zaW5nVGFnc0FmdGVyID0gJyc7XG4gIGNvbnN0IHByZXZOb2RlID0gZ2V0VGV4dFNpYmxpbmcobm9kZSwgdHJ1ZSk7XG4gIGNvbnN0IG5leHROb2RlID0gZ2V0VGV4dFNpYmxpbmcobm9kZSwgZmFsc2UpO1xuICBjb25zdCBhcHBsaWVkID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRleHRUcmFuc2Zvcm1lcnMpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0cmFuc2Zvcm1lci5mb3JtYXRbMF07XG4gICAgY29uc3QgdGFnID0gdHJhbnNmb3JtZXIudGFnO1xuXG4gICAgLy8gZGVkdXAgYXBwbGllZCBmb3JtYXRzXG4gICAgaWYgKGhhc0Zvcm1hdChub2RlLCBmb3JtYXQpICYmICFhcHBsaWVkLmhhcyhmb3JtYXQpKSB7XG4gICAgICAvLyBNdWx0aXBsZSB0YWdzIG1pZ2h0IGJlIHVzZWQgZm9yIHRoZSBzYW1lIGZvcm1hdCAoKiwgXylcbiAgICAgIGFwcGxpZWQuYWRkKGZvcm1hdCk7XG5cbiAgICAgIC8vIGFwcGVuZCB0aGUgdGFnIHRvIG9wZW5pbmdUYWdzLCBpZiBpdCdzIG5vdCBhcHBsaWVkIHRvIHRoZSBwcmV2aW91cyBub2RlcyxcbiAgICAgIC8vIG9yIHRoZSBub2RlcyBiZWZvcmUgdGhhdCAod2hpY2ggd291bGQgcmVzdWx0IGluIGFuIHVuY2xvc2VkIHRhZylcbiAgICAgIGlmICghaGFzRm9ybWF0KHByZXZOb2RlLCBmb3JtYXQpIHx8ICF1bmNsb3NlZFRhZ3MuZmluZChlbGVtZW50ID0+IGVsZW1lbnQudGFnID09PSB0YWcpKSB7XG4gICAgICAgIHVuY2xvc2VkVGFncy5wdXNoKHtcbiAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgdGFnXG4gICAgICAgIH0pO1xuICAgICAgICBvcGVuaW5nVGFncyArPSB0YWc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gY2xvc2UgYW55IHRhZ3MgaW4gdGhlIHNhbWUgb3JkZXIgdGhleSB3ZXJlIGFwcGxpZWQsIGlmIG5lY2Vzc2FyeVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHVuY2xvc2VkVGFncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGVIYXNGb3JtYXQgPSBoYXNGb3JtYXQobm9kZSwgdW5jbG9zZWRUYWdzW2ldLmZvcm1hdCk7XG4gICAgY29uc3QgbmV4dE5vZGVIYXNGb3JtYXQgPSBoYXNGb3JtYXQobmV4dE5vZGUsIHVuY2xvc2VkVGFnc1tpXS5mb3JtYXQpO1xuXG4gICAgLy8gcHJldmVudCBhZGRpbmcgY2xvc2luZyB0YWcgaWYgbmV4dCBzaWJsaW5nIHdpbGwgZG8gaXRcbiAgICBpZiAobm9kZUhhc0Zvcm1hdCAmJiBuZXh0Tm9kZUhhc0Zvcm1hdCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHVuaGFuZGxlZFVuY2xvc2VkVGFncyA9IFsuLi51bmNsb3NlZFRhZ3NdOyAvLyBTaGFsbG93IGNvcHkgdG8gYXZvaWQgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbCBhcnJheVxuXG4gICAgd2hpbGUgKHVuaGFuZGxlZFVuY2xvc2VkVGFncy5sZW5ndGggPiBpKSB7XG4gICAgICBjb25zdCB1bmNsb3NlZFRhZyA9IHVuaGFuZGxlZFVuY2xvc2VkVGFncy5wb3AoKTtcblxuICAgICAgLy8gSWYgdGFnIGlzIHVuY2xvc2FibGUsIGRvbid0IGNsb3NlIGl0IGFuZCBsZWF2ZSBpdCBpbiB0aGUgb3JpZ2luYWwgYXJyYXksXG4gICAgICAvLyBTbyB0aGF0IGl0IGNhbiBiZSBjbG9zZWQgd2hlbiBpdCdzIG5vIGxvbmdlciB1bmNsb3NhYmxlXG4gICAgICBpZiAodW5jbG9zYWJsZVRhZ3MgJiYgdW5jbG9zZWRUYWcgJiYgdW5jbG9zYWJsZVRhZ3MuZmluZChlbGVtZW50ID0+IGVsZW1lbnQudGFnID09PSB1bmNsb3NlZFRhZy50YWcpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHVuY2xvc2VkVGFnICYmIHR5cGVvZiB1bmNsb3NlZFRhZy50YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghbm9kZUhhc0Zvcm1hdCkge1xuICAgICAgICAgIC8vIEhhbmRsZXMgY2FzZXMgd2hlcmUgdGhlIHRhZyBoYXMgbm90IGJlZW4gY2xvc2VkIGJlZm9yZSwgZS5nLiBpZiB0aGUgcHJldmlvdXMgbm9kZVxuICAgICAgICAgIC8vIHdhcyBhIHRleHQgbWF0Y2ggdHJhbnNmb3JtZXIgdGhhdCBkaWQgbm90IGFjY291bnQgZm9yIGNsb3NpbmcgdGFncyBvZiB0aGUgbmV4dCBub2RlIChlLmcuIGEgbGluaylcbiAgICAgICAgICBjbG9zaW5nVGFnc0JlZm9yZSArPSB1bmNsb3NlZFRhZy50YWc7XG4gICAgICAgIH0gZWxzZSBpZiAoIW5leHROb2RlSGFzRm9ybWF0KSB7XG4gICAgICAgICAgY2xvc2luZ1RhZ3NBZnRlciArPSB1bmNsb3NlZFRhZy50YWc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE11dGF0ZSB0aGUgb3JpZ2luYWwgYXJyYXkgdG8gcmVtb3ZlIHRoZSBjbG9zZWQgdGFnXG4gICAgICB1bmNsb3NlZFRhZ3MucG9wKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIG91dHB1dCA9IG9wZW5pbmdUYWdzICsgb3V0cHV0ICsgY2xvc2luZ1RhZ3NBZnRlcjtcbiAgLy8gUmVwbGFjZSB0cmltbWVkIHZlcnNpb24gb2YgdGV4dENvbnRlbnQgZW5zdXJpbmcgc3Vycm91bmRpbmcgd2hpdGVzcGFjZSBpcyBub3QgbW9kaWZpZWRcbiAgcmV0dXJuIGNsb3NpbmdUYWdzQmVmb3JlICsgb3V0cHV0O1xufVxuXG4vLyBHZXQgbmV4dCBvciBwcmV2aW91cyB0ZXh0IHNpYmxpbmcgYSB0ZXh0IG5vZGUsIGluY2x1ZGluZyBjYXNlc1xuLy8gd2hlbiBpdCdzIGEgY2hpbGQgb2YgaW5saW5lIGVsZW1lbnQgKGUuZy4gbGluaylcbmZ1bmN0aW9uIGdldFRleHRTaWJsaW5nKG5vZGUsIGJhY2t3YXJkKSB7XG4gIGxldCBzaWJsaW5nID0gYmFja3dhcmQgPyBub2RlLmdldFByZXZpb3VzU2libGluZygpIDogbm9kZS5nZXROZXh0U2libGluZygpO1xuICBpZiAoIXNpYmxpbmcpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBpZiAocGFyZW50LmlzSW5saW5lKCkpIHtcbiAgICAgIHNpYmxpbmcgPSBiYWNrd2FyZCA/IHBhcmVudC5nZXRQcmV2aW91c1NpYmxpbmcoKSA6IHBhcmVudC5nZXROZXh0U2libGluZygpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoc2libGluZykge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShzaWJsaW5nKSkge1xuICAgICAgaWYgKCFzaWJsaW5nLmlzSW5saW5lKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXNjZW5kYW50ID0gYmFja3dhcmQgPyBzaWJsaW5nLmdldExhc3REZXNjZW5kYW50KCkgOiBzaWJsaW5nLmdldEZpcnN0RGVzY2VuZGFudCgpO1xuICAgICAgaWYgKCRpc1RleHROb2RlKGRlc2NlbmRhbnQpKSB7XG4gICAgICAgIHJldHVybiBkZXNjZW5kYW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2libGluZyA9IGJhY2t3YXJkID8gc2libGluZy5nZXRQcmV2aW91c1NpYmxpbmcoKSA6IHNpYmxpbmcuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRpc1RleHROb2RlKHNpYmxpbmcpKSB7XG4gICAgICByZXR1cm4gc2libGluZztcbiAgICB9XG4gICAgaWYgKCEkaXNFbGVtZW50Tm9kZShzaWJsaW5nKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaGFzRm9ybWF0KG5vZGUsIGZvcm1hdCkge1xuICByZXR1cm4gJGlzVGV4dE5vZGUobm9kZSkgJiYgbm9kZS5oYXNGb3JtYXQoZm9ybWF0KTtcbn1cbmZ1bmN0aW9uIGVzY2FwZUxlYWRpbmdBbmRUcmFpbGluZ1doaXRlc3BhY2VzKHRleHRDb250ZW50KSB7XG4gIHJldHVybiB0ZXh0Q29udGVudC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBtYXRjaCA9PiB7XG4gICAgcmV0dXJuIFsuLi5tYXRjaF0ubWFwKGNoYXIgPT4gJyYjJyArIGNoYXIuY29kZVBvaW50QXQoMCkgKyAnOycpLmpvaW4oJycpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBmaW5kT3V0ZXJtb3N0VGV4dEZvcm1hdFRyYW5zZm9ybWVyKHRleHROb2RlLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgpIHtcbiAgY29uc3QgdGV4dENvbnRlbnQgPSB0ZXh0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICBjb25zdCBtYXRjaCA9IGZpbmRPdXRlcm1vc3RNYXRjaCh0ZXh0Q29udGVudCwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4KTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHRleHRGb3JtYXRNYXRjaFN0YXJ0ID0gbWF0Y2guaW5kZXggfHwgMDtcbiAgY29uc3QgdGV4dEZvcm1hdE1hdGNoRW5kID0gdGV4dEZvcm1hdE1hdGNoU3RhcnQgKyBtYXRjaFswXS5sZW5ndGg7XG4gIGNvbnN0IHRyYW5zZm9ybWVyID0gdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4LnRyYW5zZm9ybWVyc0J5VGFnW21hdGNoWzFdXTtcbiAgcmV0dXJuIHtcbiAgICBlbmRJbmRleDogdGV4dEZvcm1hdE1hdGNoRW5kLFxuICAgIG1hdGNoLFxuICAgIHN0YXJ0SW5kZXg6IHRleHRGb3JtYXRNYXRjaFN0YXJ0LFxuICAgIHRyYW5zZm9ybWVyXG4gIH07XG59XG5cbi8vIEZpbmRzIGZpcnN0IFwiPHRhZz5jb250ZW50PHRhZz5cIiBtYXRjaCB0aGF0IGlzIG5vdCBuZXN0ZWQgaW50byBhbm90aGVyIHRhZ1xuZnVuY3Rpb24gZmluZE91dGVybW9zdE1hdGNoKHRleHRDb250ZW50LCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgpIHtcbiAgY29uc3Qgb3BlblRhZ3NNYXRjaCA9IHRleHRDb250ZW50Lm1hdGNoKHRleHRUcmFuc2Zvcm1lcnNJbmRleC5vcGVuVGFnc1JlZ0V4cCk7XG4gIGlmIChvcGVuVGFnc01hdGNoID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmb3IgKGNvbnN0IG1hdGNoIG9mIG9wZW5UYWdzTWF0Y2gpIHtcbiAgICAvLyBPcGVuIHRhZ3MgcmVnIGV4cCBtaWdodCBjYXB0dXJlIGxlYWRpbmcgc3BhY2Ugc28gcmVtb3ZpbmcgaXRcbiAgICAvLyBiZWZvcmUgdXNpbmcgbWF0Y2ggdG8gZmluZCB0cmFuc2Zvcm1lclxuICAgIGNvbnN0IHRhZyA9IG1hdGNoLnJlcGxhY2UoL15cXHMvLCAnJyk7XG4gICAgY29uc3QgZnVsbE1hdGNoUmVnRXhwID0gdGV4dFRyYW5zZm9ybWVyc0luZGV4LmZ1bGxNYXRjaFJlZ0V4cEJ5VGFnW3RhZ107XG4gICAgaWYgKGZ1bGxNYXRjaFJlZ0V4cCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZnVsbE1hdGNoID0gdGV4dENvbnRlbnQubWF0Y2goZnVsbE1hdGNoUmVnRXhwKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1lciA9IHRleHRUcmFuc2Zvcm1lcnNJbmRleC50cmFuc2Zvcm1lcnNCeVRhZ1t0YWddO1xuICAgIGlmIChmdWxsTWF0Y2ggIT0gbnVsbCAmJiB0cmFuc2Zvcm1lciAhPSBudWxsKSB7XG4gICAgICBpZiAodHJhbnNmb3JtZXIuaW50cmF3b3JkICE9PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZnVsbE1hdGNoO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3Igbm9uLWludHJhd29yZCB0cmFuc2Zvcm1lcnMgY2hlY2tpbmcgaWYgaXQncyB3aXRoaW4gYSB3b3JkXG4gICAgICAvLyBvciBzdXJyb3VuZGVkIHdpdGggc3BhY2UvcHVuY3R1YXRpb24vbmV3bGluZVxuICAgICAgY29uc3Qge1xuICAgICAgICBpbmRleCA9IDBcbiAgICAgIH0gPSBmdWxsTWF0Y2g7XG4gICAgICBjb25zdCBiZWZvcmVDaGFyID0gdGV4dENvbnRlbnRbaW5kZXggLSAxXTtcbiAgICAgIGNvbnN0IGFmdGVyQ2hhciA9IHRleHRDb250ZW50W2luZGV4ICsgZnVsbE1hdGNoWzBdLmxlbmd0aF07XG4gICAgICBpZiAoKCFiZWZvcmVDaGFyIHx8IFBVTkNUVUFUSU9OX09SX1NQQUNFLnRlc3QoYmVmb3JlQ2hhcikpICYmICghYWZ0ZXJDaGFyIHx8IFBVTkNUVUFUSU9OX09SX1NQQUNFLnRlc3QoYWZ0ZXJDaGFyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bGxNYXRjaDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpbXBvcnRUZXh0Rm9ybWF0VHJhbnNmb3JtZXIodGV4dE5vZGUsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCB0cmFuc2Zvcm1lciwgbWF0Y2gpIHtcbiAgY29uc3QgdGV4dENvbnRlbnQgPSB0ZXh0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuXG4gIC8vIE5vIHRleHQgbWF0Y2hlcyAtIHdlIGNhbiBzYWZlbHkgcHJvY2VzcyB0aGUgdGV4dCBmb3JtYXQgbWF0Y2hcbiAgbGV0IHRyYW5zZm9ybWVkTm9kZSwgbm9kZUFmdGVyLCBub2RlQmVmb3JlO1xuXG4gIC8vIElmIG1hdGNoaW5nIGZ1bGwgY29udGVudCB0aGVyZSdzIG5vIG5lZWQgdG8gcnVuIHNwbGl0VGV4dCBhbmQgY2FuIHJldXNlIGV4aXN0aW5nIHRleHROb2RlXG4gIC8vIHRvIHVwZGF0ZSBpdHMgY29udGVudCBhbmQgYXBwbHkgZm9ybWF0LiBFLmcuIGZvciAqKl9IZWxsb18qKiBzdHJpbmcgYWZ0ZXIgYXBwbHlpbmcgYm9sZFxuICAvLyBmb3JtYXQgKCoqKSBpdCB3aWxsIHJldXNlIHRoZSBzYW1lIHRleHQgbm9kZSB0byBhcHBseSBpdGFsaWMgKF8pXG4gIGlmIChtYXRjaFswXSA9PT0gdGV4dENvbnRlbnQpIHtcbiAgICB0cmFuc2Zvcm1lZE5vZGUgPSB0ZXh0Tm9kZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RhcnRJbmRleCA9PT0gMCkge1xuICAgICAgW3RyYW5zZm9ybWVkTm9kZSwgbm9kZUFmdGVyXSA9IHRleHROb2RlLnNwbGl0VGV4dChlbmRJbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFtub2RlQmVmb3JlLCB0cmFuc2Zvcm1lZE5vZGUsIG5vZGVBZnRlcl0gPSB0ZXh0Tm9kZS5zcGxpdFRleHQoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgIH1cbiAgfVxuICB0cmFuc2Zvcm1lZE5vZGUuc2V0VGV4dENvbnRlbnQobWF0Y2hbMl0pO1xuICBpZiAodHJhbnNmb3JtZXIpIHtcbiAgICBmb3IgKGNvbnN0IGZvcm1hdCBvZiB0cmFuc2Zvcm1lci5mb3JtYXQpIHtcbiAgICAgIGlmICghdHJhbnNmb3JtZWROb2RlLmhhc0Zvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIHRyYW5zZm9ybWVkTm9kZS50b2dnbGVGb3JtYXQoZm9ybWF0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBub2RlQWZ0ZXI6IG5vZGVBZnRlcixcbiAgICBub2RlQmVmb3JlOiBub2RlQmVmb3JlLFxuICAgIHRyYW5zZm9ybWVkTm9kZTogdHJhbnNmb3JtZWROb2RlXG4gIH07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gZmluZE91dGVybW9zdFRleHRNYXRjaFRyYW5zZm9ybWVyKHRleHROb2RlXywgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IHRleHROb2RlID0gdGV4dE5vZGVfO1xuICBsZXQgZm91bmRNYXRjaFN0YXJ0SW5kZXggPSB1bmRlZmluZWQ7XG4gIGxldCBmb3VuZE1hdGNoRW5kSW5kZXggPSB1bmRlZmluZWQ7XG4gIGxldCBmb3VuZE1hdGNoVHJhbnNmb3JtZXIgPSB1bmRlZmluZWQ7XG4gIGxldCBmb3VuZE1hdGNoID0gdW5kZWZpbmVkO1xuICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRleHRNYXRjaFRyYW5zZm9ybWVycykge1xuICAgIGlmICghdHJhbnNmb3JtZXIucmVwbGFjZSB8fCAhdHJhbnNmb3JtZXIuaW1wb3J0UmVnRXhwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSB0ZXh0Tm9kZS5nZXRUZXh0Q29udGVudCgpLm1hdGNoKHRyYW5zZm9ybWVyLmltcG9ydFJlZ0V4cCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBtYXRjaC5pbmRleCB8fCAwO1xuICAgIGNvbnN0IGVuZEluZGV4ID0gdHJhbnNmb3JtZXIuZ2V0RW5kSW5kZXggPyB0cmFuc2Zvcm1lci5nZXRFbmRJbmRleCh0ZXh0Tm9kZSwgbWF0Y2gpIDogc3RhcnRJbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICBpZiAoZW5kSW5kZXggPT09IGZhbHNlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZvdW5kTWF0Y2hTdGFydEluZGV4ID09PSB1bmRlZmluZWQgfHwgZm91bmRNYXRjaEVuZEluZGV4ID09PSB1bmRlZmluZWQgfHwgc3RhcnRJbmRleCA8IGZvdW5kTWF0Y2hTdGFydEluZGV4ICYmIGVuZEluZGV4ID4gZm91bmRNYXRjaEVuZEluZGV4KSB7XG4gICAgICBmb3VuZE1hdGNoU3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgICBmb3VuZE1hdGNoRW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgIGZvdW5kTWF0Y2hUcmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyO1xuICAgICAgZm91bmRNYXRjaCA9IG1hdGNoO1xuICAgIH1cbiAgfVxuICBpZiAoZm91bmRNYXRjaFN0YXJ0SW5kZXggPT09IHVuZGVmaW5lZCB8fCBmb3VuZE1hdGNoRW5kSW5kZXggPT09IHVuZGVmaW5lZCB8fCBmb3VuZE1hdGNoVHJhbnNmb3JtZXIgPT09IHVuZGVmaW5lZCB8fCBmb3VuZE1hdGNoID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGVuZEluZGV4OiBmb3VuZE1hdGNoRW5kSW5kZXgsXG4gICAgbWF0Y2g6IGZvdW5kTWF0Y2gsXG4gICAgc3RhcnRJbmRleDogZm91bmRNYXRjaFN0YXJ0SW5kZXgsXG4gICAgdHJhbnNmb3JtZXI6IGZvdW5kTWF0Y2hUcmFuc2Zvcm1lclxuICB9O1xufVxuZnVuY3Rpb24gaW1wb3J0Rm91bmRUZXh0TWF0Y2hUcmFuc2Zvcm1lcih0ZXh0Tm9kZSwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIHRyYW5zZm9ybWVyLCBtYXRjaCkge1xuICBsZXQgdHJhbnNmb3JtZWROb2RlLCBub2RlQWZ0ZXIsIG5vZGVCZWZvcmU7XG4gIGlmIChzdGFydEluZGV4ID09PSAwKSB7XG4gICAgW3RyYW5zZm9ybWVkTm9kZSwgbm9kZUFmdGVyXSA9IHRleHROb2RlLnNwbGl0VGV4dChlbmRJbmRleCk7XG4gIH0gZWxzZSB7XG4gICAgW25vZGVCZWZvcmUsIHRyYW5zZm9ybWVkTm9kZSwgbm9kZUFmdGVyXSA9IHRleHROb2RlLnNwbGl0VGV4dChzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gIH1cbiAgaWYgKCF0cmFuc2Zvcm1lci5yZXBsYWNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcG90ZW50aWFsVHJhbnNmb3JtZWROb2RlID0gdHJhbnNmb3JtZXIucmVwbGFjZSh0cmFuc2Zvcm1lZE5vZGUsIG1hdGNoKTtcbiAgcmV0dXJuIHtcbiAgICBub2RlQWZ0ZXIsXG4gICAgbm9kZUJlZm9yZSxcbiAgICB0cmFuc2Zvcm1lZE5vZGU6IHBvdGVudGlhbFRyYW5zZm9ybWVkTm9kZSB8fCB1bmRlZmluZWRcbiAgfTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGNhbiBjb250YWluIHRyYW5zZm9ybWFibGUgbWFya2Rvd24uXG4gKiBDb2RlIG5vZGVzIGNhbm5vdCBjb250YWluIHRyYW5zZm9ybWFibGUgbWFya2Rvd24uXG4gKiBGb3IgZXhhbXBsZSwgYGNvZGUgKipib2xkKipgIHNob3VsZCBub3QgYmUgdHJhbnNmb3JtZWQgdG9cbiAqIDxjb2RlPmNvZGUgPHN0cm9uZz5ib2xkPC9zdHJvbmc+PC9jb2RlPi5cbiAqL1xuZnVuY3Rpb24gY2FuQ29udGFpblRyYW5zZm9ybWFibGVNYXJrZG93bihub2RlKSB7XG4gIHJldHVybiAkaXNUZXh0Tm9kZShub2RlKSAmJiAhbm9kZS5oYXNGb3JtYXQoJ2NvZGUnKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGFwcGx5aW5nIGJvdGggdGV4dCBmb3JtYXQgYW5kIHRleHQgbWF0Y2ggdHJhbnNmb3JtZXJzLlxuICogSXQgZmluZHMgdGhlIG91dGVybW9zdCB0ZXh0IGZvcm1hdCBvciB0ZXh0IG1hdGNoIGFuZCBhcHBsaWVzIGl0LFxuICogdGhlbiByZWN1cnNpdmVseSBjYWxscyBpdHNlbGYgdG8gYXBwbHkgdGhlIG5leHQgb3V0ZXJtb3N0IHRyYW5zZm9ybWVyLFxuICogdW50aWwgdGhlcmUgYXJlIG5vIG1vcmUgdHJhbnNmb3JtZXJzIHRvIGFwcGx5LlxuICovXG5mdW5jdGlvbiBpbXBvcnRUZXh0VHJhbnNmb3JtZXJzKHRleHROb2RlLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycykge1xuICBsZXQgZm91bmRUZXh0Rm9ybWF0ID0gZmluZE91dGVybW9zdFRleHRGb3JtYXRUcmFuc2Zvcm1lcih0ZXh0Tm9kZSwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4KTtcbiAgbGV0IGZvdW5kVGV4dE1hdGNoID0gZmluZE91dGVybW9zdFRleHRNYXRjaFRyYW5zZm9ybWVyKHRleHROb2RlLCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpO1xuICBpZiAoZm91bmRUZXh0Rm9ybWF0ICYmIGZvdW5kVGV4dE1hdGNoKSB7XG4gICAgLy8gRmluZCB0aGUgb3V0ZXJtb3N0IHRyYW5zZm9ybWVyXG4gICAgaWYgKGZvdW5kVGV4dEZvcm1hdC5zdGFydEluZGV4IDw9IGZvdW5kVGV4dE1hdGNoLnN0YXJ0SW5kZXggJiYgZm91bmRUZXh0Rm9ybWF0LmVuZEluZGV4ID49IGZvdW5kVGV4dE1hdGNoLmVuZEluZGV4KSB7XG4gICAgICAvLyBmb3VuZFRleHRGb3JtYXQgd3JhcHMgZm91bmRUZXh0TWF0Y2ggLSBhcHBseSBmb3VuZFRleHRGb3JtYXQgYnkgc2V0dGluZyBmb3VuZFRleHRNYXRjaCB0byBudWxsXG4gICAgICBmb3VuZFRleHRNYXRjaCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvdW5kVGV4dE1hdGNoIHdyYXBzIGZvdW5kVGV4dEZvcm1hdCAtIGFwcGx5IGZvdW5kVGV4dE1hdGNoIGJ5IHNldHRpbmcgZm91bmRUZXh0Rm9ybWF0IHRvIG51bGxcbiAgICAgIGZvdW5kVGV4dEZvcm1hdCA9IG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChmb3VuZFRleHRGb3JtYXQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBpbXBvcnRUZXh0Rm9ybWF0VHJhbnNmb3JtZXIodGV4dE5vZGUsIGZvdW5kVGV4dEZvcm1hdC5zdGFydEluZGV4LCBmb3VuZFRleHRGb3JtYXQuZW5kSW5kZXgsIGZvdW5kVGV4dEZvcm1hdC50cmFuc2Zvcm1lciwgZm91bmRUZXh0Rm9ybWF0Lm1hdGNoKTtcbiAgICBpZiAoY2FuQ29udGFpblRyYW5zZm9ybWFibGVNYXJrZG93bihyZXN1bHQubm9kZUFmdGVyKSkge1xuICAgICAgaW1wb3J0VGV4dFRyYW5zZm9ybWVycyhyZXN1bHQubm9kZUFmdGVyLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycyk7XG4gICAgfVxuICAgIGlmIChjYW5Db250YWluVHJhbnNmb3JtYWJsZU1hcmtkb3duKHJlc3VsdC5ub2RlQmVmb3JlKSkge1xuICAgICAgaW1wb3J0VGV4dFRyYW5zZm9ybWVycyhyZXN1bHQubm9kZUJlZm9yZSwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpO1xuICAgIH1cbiAgICBpZiAoY2FuQ29udGFpblRyYW5zZm9ybWFibGVNYXJrZG93bihyZXN1bHQudHJhbnNmb3JtZWROb2RlKSkge1xuICAgICAgaW1wb3J0VGV4dFRyYW5zZm9ybWVycyhyZXN1bHQudHJhbnNmb3JtZWROb2RlLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZvdW5kVGV4dE1hdGNoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gaW1wb3J0Rm91bmRUZXh0TWF0Y2hUcmFuc2Zvcm1lcih0ZXh0Tm9kZSwgZm91bmRUZXh0TWF0Y2guc3RhcnRJbmRleCwgZm91bmRUZXh0TWF0Y2guZW5kSW5kZXgsIGZvdW5kVGV4dE1hdGNoLnRyYW5zZm9ybWVyLCBmb3VuZFRleHRNYXRjaC5tYXRjaCk7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhbkNvbnRhaW5UcmFuc2Zvcm1hYmxlTWFya2Rvd24ocmVzdWx0Lm5vZGVBZnRlcikpIHtcbiAgICAgIGltcG9ydFRleHRUcmFuc2Zvcm1lcnMocmVzdWx0Lm5vZGVBZnRlciwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpO1xuICAgIH1cbiAgICBpZiAoY2FuQ29udGFpblRyYW5zZm9ybWFibGVNYXJrZG93bihyZXN1bHQubm9kZUJlZm9yZSkpIHtcbiAgICAgIGltcG9ydFRleHRUcmFuc2Zvcm1lcnMocmVzdWx0Lm5vZGVCZWZvcmUsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKTtcbiAgICB9XG4gICAgaWYgKGNhbkNvbnRhaW5UcmFuc2Zvcm1hYmxlTWFya2Rvd24ocmVzdWx0LnRyYW5zZm9ybWVkTm9kZSkpIHtcbiAgICAgIGltcG9ydFRleHRUcmFuc2Zvcm1lcnMocmVzdWx0LnRyYW5zZm9ybWVkTm9kZSwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBlc2NhcGUgY2hhcmFjdGVyc1xuICBjb25zdCB0ZXh0Q29udGVudCA9IHRleHROb2RlLmdldFRleHRDb250ZW50KCk7XG4gIGNvbnN0IGVzY2FwZWRUZXh0ID0gdGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXChbKl9gflxcXFxdKS9nLCAnJDEnKS5yZXBsYWNlKC8mIyhcXGQrKTsvZywgKF8sIGNvZGVQb2ludCkgPT4ge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlUG9pbnQpO1xuICB9KTtcbiAgdGV4dE5vZGUuc2V0VGV4dENvbnRlbnQoZXNjYXBlZFRleHQpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogUmVuZGVycyBtYXJrZG93biBmcm9tIGEgc3RyaW5nLiBUaGUgc2VsZWN0aW9uIGlzIG1vdmVkIHRvIHRoZSBzdGFydCBhZnRlciB0aGUgb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNYXJrZG93bkltcG9ydCh0cmFuc2Zvcm1lcnMsIHNob3VsZFByZXNlcnZlTmV3TGluZXMgPSBmYWxzZSkge1xuICBjb25zdCBieVR5cGUgPSB0cmFuc2Zvcm1lcnNCeVR5cGUodHJhbnNmb3JtZXJzKTtcbiAgY29uc3QgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4ID0gY3JlYXRlVGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4KGJ5VHlwZS50ZXh0Rm9ybWF0KTtcbiAgcmV0dXJuIChtYXJrZG93blN0cmluZywgbm9kZSkgPT4ge1xuICAgIGNvbnN0IGxpbmVzID0gbWFya2Rvd25TdHJpbmcuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGxpbmVzTGVuZ3RoID0gbGluZXMubGVuZ3RoO1xuICAgIGNvbnN0IHJvb3QgPSBub2RlIHx8ICRnZXRSb290KCk7XG4gICAgcm9vdC5jbGVhcigpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXNMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGluZVRleHQgPSBsaW5lc1tpXTtcbiAgICAgIGNvbnN0IFtpbXBvcnRlZCwgc2hpZnRlZEluZGV4XSA9ICRpbXBvcnRNdWx0aWxpbmUobGluZXMsIGksIGJ5VHlwZS5tdWx0aWxpbmVFbGVtZW50LCByb290KTtcbiAgICAgIGlmIChpbXBvcnRlZCkge1xuICAgICAgICAvLyBJZiBhIG11bHRpbGluZSBtYXJrZG93biBlbGVtZW50IHdhcyBpbXBvcnRlZCwgd2UgZG9uJ3Qgd2FudCB0byBwcm9jZXNzIHRoZSBsaW5lcyB0aGF0IHdlcmUgcGFydCBvZiBpdCBhbnltb3JlLlxuICAgICAgICAvLyBUaGVyZSBjb3VsZCBiZSBvdGhlciBzdWItbWFya2Rvd24gZWxlbWVudHMgKGJvdGggbXVsdGlsaW5lIGFuZCBub3JtYWwgb25lcykgbWF0Y2hpbmcgd2l0aGluIHRoaXMgbWF0Y2hlZCBtdWx0aWxpbmUgZWxlbWVudCdzIGNoaWxkcmVuLlxuICAgICAgICAvLyBIb3dldmVyLCBpdCB3b3VsZCBiZSB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIG1hdGNoZWQgbXVsdGlsaW5lIHRyYW5zZm9ybWVyIHRvIGRlY2lkZSBob3cgaXQgd2FudHMgdG8gaGFuZGxlIHRoZW0uXG4gICAgICAgIC8vIFdlIGNhbm5vdCBoYW5kbGUgdGhvc2UsIGFzIHRoZXJlIGlzIG5vIHdheSBmb3IgdXMgdG8ga25vdyBob3cgdG8gbWFpbnRhaW4gdGhlIGNvcnJlY3Qgb3JkZXIgb2YgZ2VuZXJhdGVkIGxleGljYWwgbm9kZXMgZm9yIHBvc3NpYmxlIGNoaWxkcmVuLlxuICAgICAgICBpID0gc2hpZnRlZEluZGV4OyAvLyBOZXh0IGxvb3Agd2lsbCBzdGFydCBmcm9tIHRoZSBsaW5lIGFmdGVyIHRoZSBsYXN0IGxpbmUgb2YgdGhlIG11bHRpbGluZSBlbGVtZW50XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgJGltcG9ydEJsb2NrcyhsaW5lVGV4dCwgcm9vdCwgYnlUeXBlLmVsZW1lbnQsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCwgYnlUeXBlLnRleHRNYXRjaCwgc2hvdWxkUHJlc2VydmVOZXdMaW5lcyk7XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgcmVtb3ZpbmcgZW1wdHkgcGFyYWdyYXBocyBhcyBtZCBkb2VzIG5vdCByZWFsbHlcbiAgICAvLyBhbGxvdyBlbXB0eSBsaW5lcyBhbmQgdXNlcyB0aGVtIGFzIGRlbGltaXRlci5cbiAgICAvLyBJZiB5b3UgbmVlZCBlbXB0eSBsaW5lcyBzZXQgc2hvdWxkUHJlc2VydmVOZXdMaW5lcyA9IHRydWUuXG4gICAgY29uc3QgY2hpbGRyZW4gPSByb290LmdldENoaWxkcmVuKCk7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKCFzaG91bGRQcmVzZXJ2ZU5ld0xpbmVzICYmIGlzRW1wdHlQYXJhZ3JhcGgoY2hpbGQpICYmIHJvb3QuZ2V0Q2hpbGRyZW5TaXplKCkgPiAxKSB7XG4gICAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGdldFNlbGVjdGlvbigpICE9PSBudWxsKSB7XG4gICAgICByb290LnNlbGVjdFN0YXJ0KCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJucyBmaXJzdCBlbGVtZW50IG9mIHRoZSByZXR1cm5lZCB0dXBsZSBpcyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIG11bHRpbGluZSBlbGVtZW50IHdhcyBpbXBvcnRlZC4gVGhlIHNlY29uZCBlbGVtZW50IGlzIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBsaW5lIHRoYXQgd2FzIHByb2Nlc3NlZC5cbiAqL1xuZnVuY3Rpb24gJGltcG9ydE11bHRpbGluZShsaW5lcywgc3RhcnRMaW5lSW5kZXgsIG11bHRpbGluZUVsZW1lbnRUcmFuc2Zvcm1lcnMsIHJvb3ROb2RlKSB7XG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgbXVsdGlsaW5lRWxlbWVudFRyYW5zZm9ybWVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGhhbmRsZUltcG9ydEFmdGVyU3RhcnRNYXRjaCxcbiAgICAgIHJlZ0V4cEVuZCxcbiAgICAgIHJlZ0V4cFN0YXJ0LFxuICAgICAgcmVwbGFjZVxuICAgIH0gPSB0cmFuc2Zvcm1lcjtcbiAgICBjb25zdCBzdGFydE1hdGNoID0gbGluZXNbc3RhcnRMaW5lSW5kZXhdLm1hdGNoKHJlZ0V4cFN0YXJ0KTtcbiAgICBpZiAoIXN0YXJ0TWF0Y2gpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBUcnkgbmV4dCB0cmFuc2Zvcm1lclxuICAgIH1cbiAgICBpZiAoaGFuZGxlSW1wb3J0QWZ0ZXJTdGFydE1hdGNoKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBoYW5kbGVJbXBvcnRBZnRlclN0YXJ0TWF0Y2goe1xuICAgICAgICBsaW5lcyxcbiAgICAgICAgcm9vdE5vZGUsXG4gICAgICAgIHN0YXJ0TGluZUluZGV4LFxuICAgICAgICBzdGFydE1hdGNoLFxuICAgICAgICB0cmFuc2Zvcm1lclxuICAgICAgfSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVnZXhwRW5kUmVnZXggPSB0eXBlb2YgcmVnRXhwRW5kID09PSAnb2JqZWN0JyAmJiAncmVnRXhwJyBpbiByZWdFeHBFbmQgPyByZWdFeHBFbmQucmVnRXhwIDogcmVnRXhwRW5kO1xuICAgIGNvbnN0IGlzRW5kT3B0aW9uYWwgPSByZWdFeHBFbmQgJiYgdHlwZW9mIHJlZ0V4cEVuZCA9PT0gJ29iamVjdCcgJiYgJ29wdGlvbmFsJyBpbiByZWdFeHBFbmQgPyByZWdFeHBFbmQub3B0aW9uYWwgOiAhcmVnRXhwRW5kO1xuICAgIGxldCBlbmRMaW5lSW5kZXggPSBzdGFydExpbmVJbmRleDtcbiAgICBjb25zdCBsaW5lc0xlbmd0aCA9IGxpbmVzLmxlbmd0aDtcblxuICAgIC8vIGNoZWNrIGV2ZXJ5IHNpbmdsZSBsaW5lIGZvciB0aGUgY2xvc2luZyBtYXRjaC4gSXQgY291bGQgYWxzbyBiZSBvbiB0aGUgc2FtZSBsaW5lIGFzIHRoZSBvcGVuaW5nIG1hdGNoLlxuICAgIHdoaWxlIChlbmRMaW5lSW5kZXggPCBsaW5lc0xlbmd0aCkge1xuICAgICAgY29uc3QgZW5kTWF0Y2ggPSByZWdleHBFbmRSZWdleCA/IGxpbmVzW2VuZExpbmVJbmRleF0ubWF0Y2gocmVnZXhwRW5kUmVnZXgpIDogbnVsbDtcbiAgICAgIGlmICghZW5kTWF0Y2gpIHtcbiAgICAgICAgaWYgKCFpc0VuZE9wdGlvbmFsIHx8IGlzRW5kT3B0aW9uYWwgJiYgZW5kTGluZUluZGV4IDwgbGluZXNMZW5ndGggLSAxIC8vIE9wdGlvbmFsIGVuZCwgYnV0IGRpZG4ndCByZWFjaCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudCB5ZXQgPT4gY29udGludWUgc2VhcmNoaW5nIGZvciBwb3RlbnRpYWwgY2xvc2luZyBtYXRjaFxuICAgICAgICApIHtcbiAgICAgICAgICBlbmRMaW5lSW5kZXgrKztcbiAgICAgICAgICBjb250aW51ZTsgLy8gU2VhcmNoIG5leHQgbGluZSBmb3IgY2xvc2luZyBtYXRjaFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdywgY2hlY2sgaWYgdGhlIGNsb3NpbmcgbWF0Y2ggbWF0Y2hlZCBpcyB0aGUgc2FtZSBhcyB0aGUgb3BlbmluZyBtYXRjaC5cbiAgICAgIC8vIElmIGl0IGlzLCB3ZSBuZWVkIHRvIGNvbnRpbnVlIHNlYXJjaGluZyBmb3IgdGhlIGFjdHVhbCBjbG9zaW5nIG1hdGNoLlxuICAgICAgaWYgKGVuZE1hdGNoICYmIHN0YXJ0TGluZUluZGV4ID09PSBlbmRMaW5lSW5kZXggJiYgZW5kTWF0Y2guaW5kZXggPT09IHN0YXJ0TWF0Y2guaW5kZXgpIHtcbiAgICAgICAgZW5kTGluZUluZGV4Kys7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBTZWFyY2ggbmV4dCBsaW5lIGZvciBjbG9zaW5nIG1hdGNoXG4gICAgICB9XG5cbiAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgZm91bmQgdGhlIGNsb3NpbmcgbWF0Y2guIE5leHQ6IGNhbGN1bGF0ZSB0aGUgbGluZXMgaW4gYmV0d2VlbiBvcGVuIGFuZCBjbG9zaW5nIG1hdGNoXG4gICAgICAvLyBUaGlzIHNob3VsZCBub3QgaW5jbHVkZSB0aGUgbWF0Y2hlcyB0aGVtc2VsdmVzLCBhbmQgYmUgc3BsaXQgdXAgYnkgbGluZXNcbiAgICAgIGNvbnN0IGxpbmVzSW5CZXR3ZWVuID0gW107XG4gICAgICBpZiAoZW5kTWF0Y2ggJiYgc3RhcnRMaW5lSW5kZXggPT09IGVuZExpbmVJbmRleCkge1xuICAgICAgICBsaW5lc0luQmV0d2Vlbi5wdXNoKGxpbmVzW3N0YXJ0TGluZUluZGV4XS5zbGljZShzdGFydE1hdGNoWzBdLmxlbmd0aCwgLWVuZE1hdGNoWzBdLmxlbmd0aCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZUluZGV4OyBpIDw9IGVuZExpbmVJbmRleDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgPT09IHN0YXJ0TGluZUluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gbGluZXNbaV0uc2xpY2Uoc3RhcnRNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgbGluZXNJbkJldHdlZW4ucHVzaCh0ZXh0KTsgLy8gQWxzbyBpbmNsdWRlIGVtcHR5IHRleHRcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IGVuZExpbmVJbmRleCAmJiBlbmRNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGxpbmVzW2ldLnNsaWNlKDAsIC1lbmRNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgbGluZXNJbkJldHdlZW4ucHVzaCh0ZXh0KTsgLy8gQWxzbyBpbmNsdWRlIGVtcHR5IHRleHRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZXNJbkJldHdlZW4ucHVzaChsaW5lc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVwbGFjZShyb290Tm9kZSwgbnVsbCwgc3RhcnRNYXRjaCwgZW5kTWF0Y2gsIGxpbmVzSW5CZXR3ZWVuLCB0cnVlKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgLy8gUmV0dXJuIGhlcmUuIFRoaXMgJGltcG9ydE11bHRpbGluZSBmdW5jdGlvbiBpcyBydW4gbGluZSBieSBsaW5lIGFuZCBzaG91bGQgb25seSBwcm9jZXNzIGEgc2luZ2xlIG11bHRpbGluZSBlbGVtZW50IGF0IGEgdGltZS5cbiAgICAgICAgcmV0dXJuIFt0cnVlLCBlbmRMaW5lSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgcmVwbGFjZSBmdW5jdGlvbiByZXR1cm5lZCBmYWxzZSwgZGVzcGl0ZSBmaW5kaW5nIHRoZSBtYXRjaGluZyBvcGVuIGFuZCBjbG9zZSB0YWdzID0+IHRoaXMgdHJhbnNmb3JtZXIgZG9lcyBub3Qgd2FudCB0byBoYW5kbGUgaXQuXG4gICAgICAvLyBUaHVzLCB3ZSBjb250aW51ZSBsZXR0aW5nIHRoZSByZW1haW5pbmcgdHJhbnNmb3JtZXJzIGhhbmRsZSB0aGUgcGFzc2VkIGxpbmVzIG9mIHRleHQgZnJvbSB0aGUgYmVnaW5uaW5nXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBObyBtdWx0aWxpbmUgdHJhbnNmb3JtZXIgaGFuZGxlZCB0aGlzIGxpbmUgc3VjY2Vzc2Z1bGx5XG4gIHJldHVybiBbZmFsc2UsIHN0YXJ0TGluZUluZGV4XTtcbn1cbmZ1bmN0aW9uICRpbXBvcnRCbG9ja3MobGluZVRleHQsIHJvb3ROb2RlLCBlbGVtZW50VHJhbnNmb3JtZXJzLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycywgc2hvdWxkUHJlc2VydmVOZXdMaW5lcykge1xuICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShsaW5lVGV4dCk7XG4gIGNvbnN0IGVsZW1lbnROb2RlID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgZWxlbWVudE5vZGUuYXBwZW5kKHRleHROb2RlKTtcbiAgcm9vdE5vZGUuYXBwZW5kKGVsZW1lbnROb2RlKTtcbiAgZm9yIChjb25zdCB7XG4gICAgcmVnRXhwLFxuICAgIHJlcGxhY2VcbiAgfSBvZiBlbGVtZW50VHJhbnNmb3JtZXJzKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBsaW5lVGV4dC5tYXRjaChyZWdFeHApO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdGV4dE5vZGUuc2V0VGV4dENvbnRlbnQobGluZVRleHQuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKSk7XG4gICAgICBpZiAocmVwbGFjZShlbGVtZW50Tm9kZSwgW3RleHROb2RlXSwgbWF0Y2gsIHRydWUpICE9PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaW1wb3J0VGV4dFRyYW5zZm9ybWVycyh0ZXh0Tm9kZSwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpO1xuXG4gIC8vIElmIG5vIHRyYW5zZm9ybWVyIGZvdW5kIGFuZCB3ZSBsZWZ0IHdpdGggb3JpZ2luYWwgcGFyYWdyYXBoIG5vZGVcbiAgLy8gY2FuIGNoZWNrIGlmIGl0cyBjb250ZW50IGNhbiBiZSBhcHBlbmRlZCB0byB0aGUgcHJldmlvdXMgbm9kZVxuICAvLyBpZiBpdCdzIGEgcGFyYWdyYXBoLCBxdW90ZSBvciBsaXN0XG4gIGlmIChlbGVtZW50Tm9kZS5pc0F0dGFjaGVkKCkgJiYgbGluZVRleHQubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHByZXZpb3VzTm9kZSA9IGVsZW1lbnROb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGlmICghc2hvdWxkUHJlc2VydmVOZXdMaW5lcyAmJiAoXG4gICAgLy8gT25seSBhcHBlbmQgaWYgd2UncmUgbm90IHByZXNlcnZpbmcgbmV3bGluZXNcbiAgICAkaXNQYXJhZ3JhcGhOb2RlKHByZXZpb3VzTm9kZSkgfHwgJGlzUXVvdGVOb2RlKHByZXZpb3VzTm9kZSkgfHwgJGlzTGlzdE5vZGUocHJldmlvdXNOb2RlKSkpIHtcbiAgICAgIGxldCB0YXJnZXROb2RlID0gcHJldmlvdXNOb2RlO1xuICAgICAgaWYgKCRpc0xpc3ROb2RlKHByZXZpb3VzTm9kZSkpIHtcbiAgICAgICAgY29uc3QgbGFzdERlc2NlbmRhbnQgPSBwcmV2aW91c05vZGUuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgICAgICAgaWYgKGxhc3REZXNjZW5kYW50ID09IG51bGwpIHtcbiAgICAgICAgICB0YXJnZXROb2RlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXROb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChsYXN0RGVzY2VuZGFudCwgJGlzTGlzdEl0ZW1Ob2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRhcmdldE5vZGUgIT0gbnVsbCAmJiB0YXJnZXROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpID4gMCkge1xuICAgICAgICB0YXJnZXROb2RlLnNwbGljZSh0YXJnZXROb2RlLmdldENoaWxkcmVuU2l6ZSgpLCAwLCBbJGNyZWF0ZUxpbmVCcmVha05vZGUoKSwgLi4uZWxlbWVudE5vZGUuZ2V0Q2hpbGRyZW4oKV0pO1xuICAgICAgICBlbGVtZW50Tm9kZS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCh0ZXh0VHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVyc0J5VGFnID0ge307XG4gIGNvbnN0IGZ1bGxNYXRjaFJlZ0V4cEJ5VGFnID0ge307XG4gIGNvbnN0IG9wZW5UYWdzUmVnRXhwID0gW107XG4gIGNvbnN0IGVzY2FwZVJlZ0V4cCA9IGAoPzwhW1xcXFxcXFxcXSlgO1xuICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRleHRUcmFuc2Zvcm1lcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICB0YWdcbiAgICB9ID0gdHJhbnNmb3JtZXI7XG4gICAgdHJhbnNmb3JtZXJzQnlUYWdbdGFnXSA9IHRyYW5zZm9ybWVyO1xuICAgIGNvbnN0IHRhZ1JlZ0V4cCA9IHRhZy5yZXBsYWNlKC8oXFwqfFxcXnxcXCspL2csICdcXFxcJDEnKTtcbiAgICBvcGVuVGFnc1JlZ0V4cC5wdXNoKHRhZ1JlZ0V4cCk7XG5cbiAgICAvLyBTaW5nbGUtY2hhciB0YWcgKGUuZy4gXCIqXCIpLFxuICAgIGlmICh0YWcubGVuZ3RoID09PSAxKSB7XG4gICAgICBmdWxsTWF0Y2hSZWdFeHBCeVRhZ1t0YWddID0gbmV3IFJlZ0V4cChgKD88IVtcXFxcXFxcXCR7dGFnUmVnRXhwfV0pKCR7dGFnUmVnRXhwfSkoKFxcXFxcXFxcJHt0YWdSZWdFeHB9KT8uKj9bXiR7dGFnUmVnRXhwfVxcXFxzXShcXFxcXFxcXCR7dGFnUmVnRXhwfSk/KSgoPzwhXFxcXFxcXFwpfCg/PD1cXFxcXFxcXFxcXFxcXFxcKSkoJHt0YWdSZWdFeHB9KSg/IVtcXFxcXFxcXCR7dGFnUmVnRXhwfV0pYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE11bHRp4oCQY2hhciB0YWdzIChlLmcuIFwiKipcIilcbiAgICAgIGZ1bGxNYXRjaFJlZ0V4cEJ5VGFnW3RhZ10gPSBuZXcgUmVnRXhwKGAoPzwhXFxcXFxcXFwpKCR7dGFnUmVnRXhwfSkoKFxcXFxcXFxcJHt0YWdSZWdFeHB9KT8uKj9bXlxcXFxzXShcXFxcXFxcXCR7dGFnUmVnRXhwfSk/KSgoPzwhXFxcXFxcXFwpfCg/PD1cXFxcXFxcXFxcXFxcXFxcKSkoJHt0YWdSZWdFeHB9KSg/IVxcXFxcXFxcKWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIC8vIFJlZyBleHAgdG8gZmluZCBvcGVuIHRhZyArIGNvbnRlbnQgKyBjbG9zZSB0YWdcbiAgICBmdWxsTWF0Y2hSZWdFeHBCeVRhZyxcbiAgICAvLyBSZWdleHAgdG8gbG9jYXRlICphbnkqIHBvdGVudGlhbCBvcGVuaW5nIHRhZyAobG9uZ2VzdCBmaXJzdCkuXG4gICAgb3BlblRhZ3NSZWdFeHA6IG5ldyBSZWdFeHAoYCR7ZXNjYXBlUmVnRXhwfSgke29wZW5UYWdzUmVnRXhwLmpvaW4oJ3wnKX0pYCwgJ2cnKSxcbiAgICB0cmFuc2Zvcm1lcnNCeVRhZ1xuICB9O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8vIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIGBpbnZhcmlhbnRgIGNhbGxzLlxuXG5mdW5jdGlvbiBmb3JtYXREZXZFcnJvck1lc3NhZ2UobWVzc2FnZSkge1xuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIHJ1bkVsZW1lbnRUcmFuc2Zvcm1lcnMocGFyZW50Tm9kZSwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBlbGVtZW50VHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IGdyYW5kUGFyZW50Tm9kZSA9IHBhcmVudE5vZGUuZ2V0UGFyZW50KCk7XG4gIGlmICghJGlzUm9vdE9yU2hhZG93Um9vdChncmFuZFBhcmVudE5vZGUpIHx8IHBhcmVudE5vZGUuZ2V0Rmlyc3RDaGlsZCgpICE9PSBhbmNob3JOb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHRleHRDb250ZW50ID0gYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudCgpO1xuXG4gIC8vIENoZWNraW5nIGZvciBhbmNob3JPZmZzZXQgcG9zaXRpb24gdG8gcHJldmVudCBhbnkgY2hlY2tzIGZvciBjYXNlcyB3aGVuIGNhcmV0IGlzIHRvbyBmYXJcbiAgLy8gZnJvbSBhIGxpbmUgc3RhcnQgdG8gYmUgYSBwYXJ0IG9mIGJsb2NrLWxldmVsIG1hcmtkb3duIHRyaWdnZXIuXG4gIC8vXG4gIC8vIFRPRE86XG4gIC8vIENhbiBoYXZlIGEgcXVpY2sgY2hlY2sgaWYgY2FyZXQgaXMgY2xvc2UgZW5vdWdoIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZyAoZS5nLiBvZmZzZXQgbGVzcyB0aGFuIDEwLTIwKVxuICAvLyBzaW5jZSBvdGhlcndpc2UgaXQgd29uJ3QgYmUgYSBtYXJrZG93biBzaG9ydGN1dCwgYnV0IHRhYmxlcyBhcmUgZXhjZXB0aW9uXG4gIGlmICh0ZXh0Q29udGVudFthbmNob3JPZmZzZXQgLSAxXSAhPT0gJyAnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3Qge1xuICAgIHJlZ0V4cCxcbiAgICByZXBsYWNlXG4gIH0gb2YgZWxlbWVudFRyYW5zZm9ybWVycykge1xuICAgIGNvbnN0IG1hdGNoID0gdGV4dENvbnRlbnQubWF0Y2gocmVnRXhwKTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMF0ubGVuZ3RoID09PSAobWF0Y2hbMF0uZW5kc1dpdGgoJyAnKSA/IGFuY2hvck9mZnNldCA6IGFuY2hvck9mZnNldCAtIDEpKSB7XG4gICAgICBjb25zdCBuZXh0U2libGluZ3MgPSBhbmNob3JOb2RlLmdldE5leHRTaWJsaW5ncygpO1xuICAgICAgY29uc3QgW2xlYWRpbmdOb2RlLCByZW1haW5kZXJOb2RlXSA9IGFuY2hvck5vZGUuc3BsaXRUZXh0KGFuY2hvck9mZnNldCk7XG4gICAgICBjb25zdCBzaWJsaW5ncyA9IHJlbWFpbmRlck5vZGUgPyBbcmVtYWluZGVyTm9kZSwgLi4ubmV4dFNpYmxpbmdzXSA6IG5leHRTaWJsaW5ncztcbiAgICAgIGlmIChyZXBsYWNlKHBhcmVudE5vZGUsIHNpYmxpbmdzLCBtYXRjaCwgZmFsc2UpICE9PSBmYWxzZSkge1xuICAgICAgICBsZWFkaW5nTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJ1bk11bHRpbGluZUVsZW1lbnRUcmFuc2Zvcm1lcnMocGFyZW50Tm9kZSwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBlbGVtZW50VHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IGdyYW5kUGFyZW50Tm9kZSA9IHBhcmVudE5vZGUuZ2V0UGFyZW50KCk7XG4gIGlmICghJGlzUm9vdE9yU2hhZG93Um9vdChncmFuZFBhcmVudE5vZGUpIHx8IHBhcmVudE5vZGUuZ2V0Rmlyc3RDaGlsZCgpICE9PSBhbmNob3JOb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHRleHRDb250ZW50ID0gYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudCgpO1xuXG4gIC8vIENoZWNraW5nIGZvciBhbmNob3JPZmZzZXQgcG9zaXRpb24gdG8gcHJldmVudCBhbnkgY2hlY2tzIGZvciBjYXNlcyB3aGVuIGNhcmV0IGlzIHRvbyBmYXJcbiAgLy8gZnJvbSBhIGxpbmUgc3RhcnQgdG8gYmUgYSBwYXJ0IG9mIGJsb2NrLWxldmVsIG1hcmtkb3duIHRyaWdnZXIuXG4gIC8vXG4gIC8vIFRPRE86XG4gIC8vIENhbiBoYXZlIGEgcXVpY2sgY2hlY2sgaWYgY2FyZXQgaXMgY2xvc2UgZW5vdWdoIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZyAoZS5nLiBvZmZzZXQgbGVzcyB0aGFuIDEwLTIwKVxuICAvLyBzaW5jZSBvdGhlcndpc2UgaXQgd29uJ3QgYmUgYSBtYXJrZG93biBzaG9ydGN1dCwgYnV0IHRhYmxlcyBhcmUgZXhjZXB0aW9uXG4gIGlmICh0ZXh0Q29udGVudFthbmNob3JPZmZzZXQgLSAxXSAhPT0gJyAnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3Qge1xuICAgIHJlZ0V4cFN0YXJ0LFxuICAgIHJlcGxhY2UsXG4gICAgcmVnRXhwRW5kXG4gIH0gb2YgZWxlbWVudFRyYW5zZm9ybWVycykge1xuICAgIGlmIChyZWdFeHBFbmQgJiYgISgnb3B0aW9uYWwnIGluIHJlZ0V4cEVuZCkgfHwgcmVnRXhwRW5kICYmICdvcHRpb25hbCcgaW4gcmVnRXhwRW5kICYmICFyZWdFeHBFbmQub3B0aW9uYWwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IHRleHRDb250ZW50Lm1hdGNoKHJlZ0V4cFN0YXJ0KTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMF0ubGVuZ3RoID09PSAobWF0Y2hbMF0uZW5kc1dpdGgoJyAnKSA/IGFuY2hvck9mZnNldCA6IGFuY2hvck9mZnNldCAtIDEpKSB7XG4gICAgICBjb25zdCBuZXh0U2libGluZ3MgPSBhbmNob3JOb2RlLmdldE5leHRTaWJsaW5ncygpO1xuICAgICAgY29uc3QgW2xlYWRpbmdOb2RlLCByZW1haW5kZXJOb2RlXSA9IGFuY2hvck5vZGUuc3BsaXRUZXh0KGFuY2hvck9mZnNldCk7XG4gICAgICBjb25zdCBzaWJsaW5ncyA9IHJlbWFpbmRlck5vZGUgPyBbcmVtYWluZGVyTm9kZSwgLi4ubmV4dFNpYmxpbmdzXSA6IG5leHRTaWJsaW5ncztcbiAgICAgIGlmIChyZXBsYWNlKHBhcmVudE5vZGUsIHNpYmxpbmdzLCBtYXRjaCwgbnVsbCwgbnVsbCwgZmFsc2UpICE9PSBmYWxzZSkge1xuICAgICAgICBsZWFkaW5nTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJ1blRleHRNYXRjaFRyYW5zZm9ybWVycyhhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIHRyYW5zZm9ybWVyc0J5VHJpZ2dlcikge1xuICBsZXQgdGV4dENvbnRlbnQgPSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50KCk7XG4gIGNvbnN0IGxhc3RDaGFyID0gdGV4dENvbnRlbnRbYW5jaG9yT2Zmc2V0IC0gMV07XG4gIGNvbnN0IHRyYW5zZm9ybWVycyA9IHRyYW5zZm9ybWVyc0J5VHJpZ2dlcltsYXN0Q2hhcl07XG4gIGlmICh0cmFuc2Zvcm1lcnMgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIHR5cGluZyBpbiB0aGUgbWlkZGxlIG9mIGNvbnRlbnQsIHJlbW92ZSB0aGUgdGFpbCB0byBkb1xuICAvLyByZWcgZXhwIG1hdGNoIHVwIHRvIGEgc3RyaW5nIGVuZCAoY2FyZXQgcG9zaXRpb24pXG4gIGlmIChhbmNob3JPZmZzZXQgPCB0ZXh0Q29udGVudC5sZW5ndGgpIHtcbiAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnNsaWNlKDAsIGFuY2hvck9mZnNldCk7XG4gIH1cbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiB0cmFuc2Zvcm1lcnMpIHtcbiAgICBpZiAoIXRyYW5zZm9ybWVyLnJlcGxhY2UgfHwgIXRyYW5zZm9ybWVyLnJlZ0V4cCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gdGV4dENvbnRlbnQubWF0Y2godHJhbnNmb3JtZXIucmVnRXhwKTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBzdGFydEluZGV4ID0gbWF0Y2guaW5kZXggfHwgMDtcbiAgICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgbGV0IHJlcGxhY2VOb2RlO1xuICAgIGlmIChzdGFydEluZGV4ID09PSAwKSB7XG4gICAgICBbcmVwbGFjZU5vZGVdID0gYW5jaG9yTm9kZS5zcGxpdFRleHQoZW5kSW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBbLCByZXBsYWNlTm9kZV0gPSBhbmNob3JOb2RlLnNwbGl0VGV4dChzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgfVxuICAgIHJlcGxhY2VOb2RlLnNlbGVjdE5leHQoMCwgMCk7XG4gICAgdHJhbnNmb3JtZXIucmVwbGFjZShyZXBsYWNlTm9kZSwgbWF0Y2gpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uICRydW5UZXh0Rm9ybWF0VHJhbnNmb3JtZXJzKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgdGV4dEZvcm1hdFRyYW5zZm9ybWVycykge1xuICBjb25zdCB0ZXh0Q29udGVudCA9IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgY29uc3QgY2xvc2VUYWdFbmRJbmRleCA9IGFuY2hvck9mZnNldCAtIDE7XG4gIGNvbnN0IGNsb3NlQ2hhciA9IHRleHRDb250ZW50W2Nsb3NlVGFnRW5kSW5kZXhdO1xuICAvLyBRdWljayBjaGVjayBpZiB3ZSdyZSBwb3NzaWJseSBhdCB0aGUgZW5kIG9mIGlubGluZSBtYXJrZG93biBzdHlsZVxuICBjb25zdCBtYXRjaGVycyA9IHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNbY2xvc2VDaGFyXTtcbiAgaWYgKCFtYXRjaGVycykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IG1hdGNoZXIgb2YgbWF0Y2hlcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICB0YWdcbiAgICB9ID0gbWF0Y2hlcjtcbiAgICBjb25zdCB0YWdMZW5ndGggPSB0YWcubGVuZ3RoO1xuICAgIGNvbnN0IGNsb3NlVGFnU3RhcnRJbmRleCA9IGNsb3NlVGFnRW5kSW5kZXggLSB0YWdMZW5ndGggKyAxO1xuXG4gICAgLy8gSWYgdGFnIGlzIG5vdCBzaW5nbGUgY2hhciBjaGVjayBpZiByZXN0IG9mIGl0IG1hdGNoZXMgd2l0aCB0ZXh0IGNvbnRlbnRcbiAgICBpZiAodGFnTGVuZ3RoID4gMSkge1xuICAgICAgaWYgKCFpc0VxdWFsU3ViU3RyaW5nKHRleHRDb250ZW50LCBjbG9zZVRhZ1N0YXJ0SW5kZXgsIHRhZywgMCwgdGFnTGVuZ3RoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTcGFjZSBiZWZvcmUgY2xvc2luZyB0YWcgY2FuY2VscyBpbmxpbmUgbWFya2Rvd25cbiAgICBpZiAodGV4dENvbnRlbnRbY2xvc2VUYWdTdGFydEluZGV4IC0gMV0gPT09ICcgJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gU29tZSB0YWdzIGNhbiBub3QgYmUgdXNlZCB3aXRoaW4gd29yZHMsIGhlbmNlIHNob3VsZCBoYXZlIG5ld2xpbmUvc3BhY2UvcHVuY3R1YXRpb24gYWZ0ZXIgaXRcbiAgICBjb25zdCBhZnRlckNsb3NlVGFnQ2hhciA9IHRleHRDb250ZW50W2Nsb3NlVGFnRW5kSW5kZXggKyAxXTtcbiAgICBpZiAobWF0Y2hlci5pbnRyYXdvcmQgPT09IGZhbHNlICYmIGFmdGVyQ2xvc2VUYWdDaGFyICYmICFQVU5DVFVBVElPTl9PUl9TUEFDRS50ZXN0KGFmdGVyQ2xvc2VUYWdDaGFyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGNsb3NlTm9kZSA9IGFuY2hvck5vZGU7XG4gICAgbGV0IG9wZW5Ob2RlID0gY2xvc2VOb2RlO1xuICAgIGxldCBvcGVuVGFnU3RhcnRJbmRleCA9IGdldE9wZW5UYWdTdGFydEluZGV4KHRleHRDb250ZW50LCBjbG9zZVRhZ1N0YXJ0SW5kZXgsIHRhZyk7XG5cbiAgICAvLyBHbyB0aHJvdWdoIHRleHQgbm9kZSBzaWJsaW5ncyBhbmQgc2VhcmNoIGZvciBvcGVuaW5nIHRhZ1xuICAgIC8vIGlmIGhhdmVuJ3QgZm91bmQgaXQgd2l0aGluIHRoZSBzYW1lIHRleHQgbm9kZSBhcyBjbG9zaW5nIHRhZ1xuICAgIGxldCBzaWJsaW5nID0gb3Blbk5vZGU7XG4gICAgd2hpbGUgKG9wZW5UYWdTdGFydEluZGV4IDwgMCAmJiAoc2libGluZyA9IHNpYmxpbmcuZ2V0UHJldmlvdXNTaWJsaW5nKCkpKSB7XG4gICAgICBpZiAoJGlzTGluZUJyZWFrTm9kZShzaWJsaW5nKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICgkaXNUZXh0Tm9kZShzaWJsaW5nKSkge1xuICAgICAgICBpZiAoc2libGluZy5oYXNGb3JtYXQoJ2NvZGUnKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpYmxpbmdUZXh0Q29udGVudCA9IHNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgb3Blbk5vZGUgPSBzaWJsaW5nO1xuICAgICAgICBvcGVuVGFnU3RhcnRJbmRleCA9IGdldE9wZW5UYWdTdGFydEluZGV4KHNpYmxpbmdUZXh0Q29udGVudCwgc2libGluZ1RleHRDb250ZW50Lmxlbmd0aCwgdGFnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPcGVuaW5nIHRhZyBpcyBub3QgZm91bmRcbiAgICBpZiAob3BlblRhZ1N0YXJ0SW5kZXggPCAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBObyBjb250ZW50IGJldHdlZW4gb3BlbmluZyBhbmQgY2xvc2luZyB0YWdcbiAgICBpZiAob3Blbk5vZGUgPT09IGNsb3NlTm9kZSAmJiBvcGVuVGFnU3RhcnRJbmRleCArIHRhZ0xlbmd0aCA9PT0gY2xvc2VUYWdTdGFydEluZGV4KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBDaGVja2luZyBsb25nZXIgdGFncyBmb3IgcmVwZWF0aW5nIGNoYXJzIChlLmcuICoqKiB2cyAqKilcbiAgICBjb25zdCBwcmV2T3Blbk5vZGVUZXh0ID0gb3Blbk5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBpZiAob3BlblRhZ1N0YXJ0SW5kZXggPiAwICYmIHByZXZPcGVuTm9kZVRleHRbb3BlblRhZ1N0YXJ0SW5kZXggLSAxXSA9PT0gY2xvc2VDaGFyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBTb21lIHRhZ3MgY2FuIG5vdCBiZSB1c2VkIHdpdGhpbiB3b3JkcywgaGVuY2Ugc2hvdWxkIGhhdmUgbmV3bGluZS9zcGFjZS9wdW5jdHVhdGlvbiBiZWZvcmUgaXRcbiAgICBjb25zdCBiZWZvcmVPcGVuVGFnQ2hhciA9IHByZXZPcGVuTm9kZVRleHRbb3BlblRhZ1N0YXJ0SW5kZXggLSAxXTtcbiAgICBpZiAobWF0Y2hlci5pbnRyYXdvcmQgPT09IGZhbHNlICYmIGJlZm9yZU9wZW5UYWdDaGFyICYmICFQVU5DVFVBVElPTl9PUl9TUEFDRS50ZXN0KGJlZm9yZU9wZW5UYWdDaGFyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdGV4dCBmcm9tIG9wZW5pbmcgYW5kIGNsb3NpbmcgdGFncyAoc3RhcnRpbmcgZnJvbSBjbG9zaW5nIHRhZ1xuICAgIC8vIHRvIHByZXZlbnQgYW55IG9mZnNldCBzaGlmdHMgaWYgd2Ugc3RhcnQgZnJvbSBvcGVuaW5nIG9uZSlcbiAgICBjb25zdCBwcmV2Q2xvc2VOb2RlVGV4dCA9IGNsb3NlTm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGNvbnN0IGNsb3NlTm9kZVRleHQgPSBwcmV2Q2xvc2VOb2RlVGV4dC5zbGljZSgwLCBjbG9zZVRhZ1N0YXJ0SW5kZXgpICsgcHJldkNsb3NlTm9kZVRleHQuc2xpY2UoY2xvc2VUYWdFbmRJbmRleCArIDEpO1xuICAgIGNsb3NlTm9kZS5zZXRUZXh0Q29udGVudChjbG9zZU5vZGVUZXh0KTtcbiAgICBjb25zdCBvcGVuTm9kZVRleHQgPSBvcGVuTm9kZSA9PT0gY2xvc2VOb2RlID8gY2xvc2VOb2RlVGV4dCA6IHByZXZPcGVuTm9kZVRleHQ7XG4gICAgb3Blbk5vZGUuc2V0VGV4dENvbnRlbnQob3Blbk5vZGVUZXh0LnNsaWNlKDAsIG9wZW5UYWdTdGFydEluZGV4KSArIG9wZW5Ob2RlVGV4dC5zbGljZShvcGVuVGFnU3RhcnRJbmRleCArIHRhZ0xlbmd0aCkpO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBuZXh0U2VsZWN0aW9uID0gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uKCk7XG4gICAgJHNldFNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKTtcbiAgICAvLyBBZGp1c3Qgb2Zmc2V0IGJhc2VkIG9uIGRlbGV0ZWQgY2hhcnNcbiAgICBjb25zdCBuZXdPZmZzZXQgPSBjbG9zZVRhZ0VuZEluZGV4IC0gdGFnTGVuZ3RoICogKG9wZW5Ob2RlID09PSBjbG9zZU5vZGUgPyAyIDogMSkgKyAxO1xuICAgIG5leHRTZWxlY3Rpb24uYW5jaG9yLnNldChvcGVuTm9kZS5fX2tleSwgb3BlblRhZ1N0YXJ0SW5kZXgsICd0ZXh0Jyk7XG4gICAgbmV4dFNlbGVjdGlvbi5mb2N1cy5zZXQoY2xvc2VOb2RlLl9fa2V5LCBuZXdPZmZzZXQsICd0ZXh0Jyk7XG5cbiAgICAvLyBBcHBseSBmb3JtYXR0aW5nIHRvIHNlbGVjdGVkIHRleHRcbiAgICBmb3IgKGNvbnN0IGZvcm1hdCBvZiBtYXRjaGVyLmZvcm1hdCkge1xuICAgICAgaWYgKCFuZXh0U2VsZWN0aW9uLmhhc0Zvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIG5leHRTZWxlY3Rpb24uZm9ybWF0VGV4dChmb3JtYXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbGxhcHNlIHNlbGVjdGlvbiB1cCB0byB0aGUgZm9jdXMgcG9pbnRcbiAgICBuZXh0U2VsZWN0aW9uLmFuY2hvci5zZXQobmV4dFNlbGVjdGlvbi5mb2N1cy5rZXksIG5leHRTZWxlY3Rpb24uZm9jdXMub2Zmc2V0LCBuZXh0U2VsZWN0aW9uLmZvY3VzLnR5cGUpO1xuXG4gICAgLy8gUmVtb3ZlIGZvcm1hdHRpbmcgZnJvbSBjb2xsYXBzZWQgc2VsZWN0aW9uXG4gICAgZm9yIChjb25zdCBmb3JtYXQgb2YgbWF0Y2hlci5mb3JtYXQpIHtcbiAgICAgIGlmIChuZXh0U2VsZWN0aW9uLmhhc0Zvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIG5leHRTZWxlY3Rpb24udG9nZ2xlRm9ybWF0KGZvcm1hdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBuZXh0U2VsZWN0aW9uLmZvcm1hdCA9IHNlbGVjdGlvbi5mb3JtYXQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldE9wZW5UYWdTdGFydEluZGV4KHN0cmluZywgbWF4SW5kZXgsIHRhZykge1xuICBjb25zdCB0YWdMZW5ndGggPSB0YWcubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gbWF4SW5kZXg7IGkgPj0gdGFnTGVuZ3RoOyBpLS0pIHtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gaSAtIHRhZ0xlbmd0aDtcbiAgICBpZiAoaXNFcXVhbFN1YlN0cmluZyhzdHJpbmcsIHN0YXJ0SW5kZXgsIHRhZywgMCwgdGFnTGVuZ3RoKSAmJlxuICAgIC8vIFNwYWNlIGFmdGVyIG9wZW5pbmcgdGFnIGNhbmNlbHMgdHJhbnNmb3JtYXRpb25cbiAgICBzdHJpbmdbc3RhcnRJbmRleCArIHRhZ0xlbmd0aF0gIT09ICcgJykge1xuICAgICAgcmV0dXJuIHN0YXJ0SW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGlzRXF1YWxTdWJTdHJpbmcoc3RyaW5nQSwgYVN0YXJ0LCBzdHJpbmdCLCBiU3RhcnQsIGxlbmd0aCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0cmluZ0FbYVN0YXJ0ICsgaV0gIT09IHN0cmluZ0JbYlN0YXJ0ICsgaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZWdpc3Rlck1hcmtkb3duU2hvcnRjdXRzKGVkaXRvciwgdHJhbnNmb3JtZXJzID0gVFJBTlNGT1JNRVJTKSB7XG4gIGNvbnN0IGJ5VHlwZSA9IHRyYW5zZm9ybWVyc0J5VHlwZSh0cmFuc2Zvcm1lcnMpO1xuICBjb25zdCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzQnlUcmlnZ2VyID0gaW5kZXhCeShieVR5cGUudGV4dEZvcm1hdCwgKHtcbiAgICB0YWdcbiAgfSkgPT4gdGFnW3RhZy5sZW5ndGggLSAxXSk7XG4gIGNvbnN0IHRleHRNYXRjaFRyYW5zZm9ybWVyc0J5VHJpZ2dlciA9IGluZGV4QnkoYnlUeXBlLnRleHRNYXRjaCwgKHtcbiAgICB0cmlnZ2VyXG4gIH0pID0+IHRyaWdnZXIpO1xuICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycykge1xuICAgIGNvbnN0IHR5cGUgPSB0cmFuc2Zvcm1lci50eXBlO1xuICAgIGlmICh0eXBlID09PSAnZWxlbWVudCcgfHwgdHlwZSA9PT0gJ3RleHQtbWF0Y2gnIHx8IHR5cGUgPT09ICdtdWx0aWxpbmUtZWxlbWVudCcpIHtcbiAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IHRyYW5zZm9ybWVyLmRlcGVuZGVuY2llcztcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgaWYgKCFlZGl0b3IuaGFzTm9kZShub2RlKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgTWFya2Rvd25TaG9ydGN1dHM6IG1pc3NpbmcgZGVwZW5kZW5jeSAke25vZGUuZ2V0VHlwZSgpfSBmb3IgdHJhbnNmb3JtZXIuIEVuc3VyZSBub2RlIGRlcGVuZGVuY3kgaXMgaW5jbHVkZWQgaW4gZWRpdG9yIGluaXRpYWwgY29uZmlnLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCAkdHJhbnNmb3JtID0gKHBhcmVudE5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCkgPT4ge1xuICAgIGlmIChydW5FbGVtZW50VHJhbnNmb3JtZXJzKHBhcmVudE5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgYnlUeXBlLmVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChydW5NdWx0aWxpbmVFbGVtZW50VHJhbnNmb3JtZXJzKHBhcmVudE5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgYnlUeXBlLm11bHRpbGluZUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChydW5UZXh0TWF0Y2hUcmFuc2Zvcm1lcnMoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnNCeVRyaWdnZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICRydW5UZXh0Rm9ybWF0VHJhbnNmb3JtZXJzKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0J5VHJpZ2dlcik7XG4gIH07XG4gIHJldHVybiBlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoe1xuICAgIHRhZ3MsXG4gICAgZGlydHlMZWF2ZXMsXG4gICAgZWRpdG9yU3RhdGUsXG4gICAgcHJldkVkaXRvclN0YXRlXG4gIH0pID0+IHtcbiAgICAvLyBJZ25vcmUgdXBkYXRlcyBmcm9tIGNvbGxhYm9yYXRpb24gYW5kIHVuZG8vcmVkbyAoYXMgY2hhbmdlcyBhbHJlYWR5IGNhbGN1bGF0ZWQpXG4gICAgaWYgKHRhZ3MuaGFzKENPTExBQk9SQVRJT05fVEFHKSB8fCB0YWdzLmhhcyhISVNUT1JJQ19UQUcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgZWRpdG9yIGlzIHN0aWxsIGNvbXBvc2luZyAoaS5lLiBiYWNrdGlja3MpIHdlIG11c3Qgd2FpdCBiZWZvcmUgdGhlIHVzZXIgY29uZmlybXMgdGhlIGtleVxuICAgIGlmIChlZGl0b3IuaXNDb21wb3NpbmcoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5yZWFkKCRnZXRTZWxlY3Rpb24pO1xuICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBwcmV2RWRpdG9yU3RhdGUucmVhZCgkZ2V0U2VsZWN0aW9uKTtcblxuICAgIC8vIFdlIGV4cGVjdCBzZWxlY3Rpb24gdG8gYmUgYSBjb2xsYXBzZWQgcmFuZ2UgYW5kIG5vdCBtYXRjaCBwcmV2aW91cyBvbmUgKGFzIHdlIHdhbnRcbiAgICAvLyB0byB0cmlnZ2VyIHRyYW5zZm9ybXMgb25seSBhcyB1c2VyIHR5cGVzKVxuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgfHwgISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8IHNlbGVjdGlvbi5pcyhwcmV2U2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JLZXkgPSBzZWxlY3Rpb24uYW5jaG9yLmtleTtcbiAgICBjb25zdCBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gZWRpdG9yU3RhdGUuX25vZGVNYXAuZ2V0KGFuY2hvcktleSk7XG4gICAgaWYgKCEkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSB8fCAhZGlydHlMZWF2ZXMuaGFzKGFuY2hvcktleSkgfHwgYW5jaG9yT2Zmc2V0ICE9PSAxICYmIGFuY2hvck9mZnNldCA+IHByZXZTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCArIDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBpZiAoIWNhbkNvbnRhaW5UcmFuc2Zvcm1hYmxlTWFya2Rvd24oYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGFuY2hvck5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gbnVsbCB8fCAkaXNDb2RlTm9kZShwYXJlbnROb2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAkdHJhbnNmb3JtKHBhcmVudE5vZGUsIGFuY2hvck5vZGUsIHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgT1JERVJFRF9MSVNUX1JFR0VYID0gL14oXFxzKikoXFxkezEsfSlcXC5cXHMvO1xuY29uc3QgVU5PUkRFUkVEX0xJU1RfUkVHRVggPSAvXihcXHMqKVstKitdXFxzLztcbmNvbnN0IENIRUNLX0xJU1RfUkVHRVggPSAvXihcXHMqKSg/Oi1cXHMpP1xccz8oXFxbKFxcc3x4KT9cXF0pXFxzL2k7XG5jb25zdCBIRUFESU5HX1JFR0VYID0gL14oI3sxLDZ9KVxccy87XG5jb25zdCBRVU9URV9SRUdFWCA9IC9ePlxccy87XG5jb25zdCBDT0RFX1NUQVJUX1JFR0VYID0gL15bIFxcdF0qYGBgKFtcXHctXSspPy87XG5jb25zdCBDT0RFX0VORF9SRUdFWCA9IC9bIFxcdF0qYGBgJC87XG5jb25zdCBDT0RFX1NJTkdMRV9MSU5FX1JFR0VYID0gL15bIFxcdF0qYGBgW15gXSsoPzooPzpgezEsMn18YHs0LH0pW15gXSspKmBgYCg/OlteYF18JCkvO1xuY29uc3QgVEFCTEVfUk9XX1JFR19FWFAgPSAvXig/OlxcfCkoLispKD86XFx8KVxccz8kLztcbmNvbnN0IFRBQkxFX1JPV19ESVZJREVSX1JFR19FWFAgPSAvXihcXHwgPzo/LSo6PyA/KStcXHxcXHM/JC87XG5jb25zdCBjcmVhdGVCbG9ja05vZGUgPSBjcmVhdGVOb2RlID0+IHtcbiAgcmV0dXJuIChwYXJlbnROb2RlLCBjaGlsZHJlbiwgbWF0Y2gsIGlzSW1wb3J0KSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGNyZWF0ZU5vZGUobWF0Y2gpO1xuICAgIG5vZGUuYXBwZW5kKC4uLmNoaWxkcmVuKTtcbiAgICBwYXJlbnROb2RlLnJlcGxhY2Uobm9kZSk7XG4gICAgaWYgKCFpc0ltcG9ydCkge1xuICAgICAgbm9kZS5zZWxlY3QoMCwgMCk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gQW1vdW50IG9mIHNwYWNlcyB0aGF0IGRlZmluZSBpbmRlbnRhdGlvbiBsZXZlbFxuLy8gVE9ETzogc2hvdWxkIGJlIGFuIG9wdGlvblxuY29uc3QgTElTVF9JTkRFTlRfU0laRSA9IDQ7XG5mdW5jdGlvbiBnZXRJbmRlbnQod2hpdGVzcGFjZXMpIHtcbiAgY29uc3QgdGFicyA9IHdoaXRlc3BhY2VzLm1hdGNoKC9cXHQvZyk7XG4gIGNvbnN0IHNwYWNlcyA9IHdoaXRlc3BhY2VzLm1hdGNoKC8gL2cpO1xuICBsZXQgaW5kZW50ID0gMDtcbiAgaWYgKHRhYnMpIHtcbiAgICBpbmRlbnQgKz0gdGFicy5sZW5ndGg7XG4gIH1cbiAgaWYgKHNwYWNlcykge1xuICAgIGluZGVudCArPSBNYXRoLmZsb29yKHNwYWNlcy5sZW5ndGggLyBMSVNUX0lOREVOVF9TSVpFKTtcbiAgfVxuICByZXR1cm4gaW5kZW50O1xufVxuY29uc3QgbGlzdFJlcGxhY2UgPSBsaXN0VHlwZSA9PiB7XG4gIHJldHVybiAocGFyZW50Tm9kZSwgY2hpbGRyZW4sIG1hdGNoLCBpc0ltcG9ydCkgPT4ge1xuICAgIGNvbnN0IHByZXZpb3VzTm9kZSA9IHBhcmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgY29uc3QgbmV4dE5vZGUgPSBwYXJlbnROb2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgY29uc3QgbGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKGxpc3RUeXBlID09PSAnY2hlY2snID8gbWF0Y2hbM10gPT09ICd4JyA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKG5leHROb2RlKSAmJiBuZXh0Tm9kZS5nZXRMaXN0VHlwZSgpID09PSBsaXN0VHlwZSkge1xuICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IG5leHROb2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKGxpc3RJdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNob3VsZCBuZXZlciBoYXBwZW4sIGJ1dCBsZXQncyBoYW5kbGUgZ3JhY2VmdWxseSwganVzdCBpbiBjYXNlLlxuICAgICAgICBuZXh0Tm9kZS5hcHBlbmQobGlzdEl0ZW0pO1xuICAgICAgfVxuICAgICAgcGFyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICB9IGVsc2UgaWYgKCRpc0xpc3ROb2RlKHByZXZpb3VzTm9kZSkgJiYgcHJldmlvdXNOb2RlLmdldExpc3RUeXBlKCkgPT09IGxpc3RUeXBlKSB7XG4gICAgICBwcmV2aW91c05vZGUuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICAgIHBhcmVudE5vZGUucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUsIGxpc3RUeXBlID09PSAnbnVtYmVyJyA/IE51bWJlcihtYXRjaFsyXSkgOiB1bmRlZmluZWQpO1xuICAgICAgbGlzdC5hcHBlbmQobGlzdEl0ZW0pO1xuICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlKGxpc3QpO1xuICAgIH1cbiAgICBsaXN0SXRlbS5hcHBlbmQoLi4uY2hpbGRyZW4pO1xuICAgIGlmICghaXNJbXBvcnQpIHtcbiAgICAgIGxpc3RJdGVtLnNlbGVjdCgwLCAwKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZW50ID0gZ2V0SW5kZW50KG1hdGNoWzFdKTtcbiAgICBpZiAoaW5kZW50KSB7XG4gICAgICBsaXN0SXRlbS5zZXRJbmRlbnQoaW5kZW50KTtcbiAgICB9XG4gIH07XG59O1xuY29uc3QgbGlzdEV4cG9ydCA9IChsaXN0Tm9kZSwgZXhwb3J0Q2hpbGRyZW4sIGRlcHRoKSA9PiB7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBjb25zdCBjaGlsZHJlbiA9IGxpc3ROb2RlLmdldENoaWxkcmVuKCk7XG4gIGxldCBpbmRleCA9IDA7XG4gIGZvciAoY29uc3QgbGlzdEl0ZW1Ob2RlIG9mIGNoaWxkcmVuKSB7XG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShsaXN0SXRlbU5vZGUpKSB7XG4gICAgICBpZiAobGlzdEl0ZW1Ob2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBsaXN0SXRlbU5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgICBpZiAoJGlzTGlzdE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChsaXN0RXhwb3J0KGZpcnN0Q2hpbGQsIGV4cG9ydENoaWxkcmVuLCBkZXB0aCArIDEpKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaW5kZW50ID0gJyAnLnJlcGVhdChkZXB0aCAqIExJU1RfSU5ERU5UX1NJWkUpO1xuICAgICAgY29uc3QgbGlzdFR5cGUgPSBsaXN0Tm9kZS5nZXRMaXN0VHlwZSgpO1xuICAgICAgY29uc3QgcHJlZml4ID0gbGlzdFR5cGUgPT09ICdudW1iZXInID8gYCR7bGlzdE5vZGUuZ2V0U3RhcnQoKSArIGluZGV4fS4gYCA6IGxpc3RUeXBlID09PSAnY2hlY2snID8gYC0gWyR7bGlzdEl0ZW1Ob2RlLmdldENoZWNrZWQoKSA/ICd4JyA6ICcgJ31dIGAgOiAnLSAnO1xuICAgICAgb3V0cHV0LnB1c2goaW5kZW50ICsgcHJlZml4ICsgZXhwb3J0Q2hpbGRyZW4obGlzdEl0ZW1Ob2RlKSk7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJ1xcbicpO1xufTtcbmNvbnN0IEhFQURJTkcgPSB7XG4gIGRlcGVuZGVuY2llczogW0hlYWRpbmdOb2RlXSxcbiAgZXhwb3J0OiAobm9kZSwgZXhwb3J0Q2hpbGRyZW4pID0+IHtcbiAgICBpZiAoISRpc0hlYWRpbmdOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWwgPSBOdW1iZXIobm9kZS5nZXRUYWcoKS5zbGljZSgxKSk7XG4gICAgcmV0dXJuICcjJy5yZXBlYXQobGV2ZWwpICsgJyAnICsgZXhwb3J0Q2hpbGRyZW4obm9kZSk7XG4gIH0sXG4gIHJlZ0V4cDogSEVBRElOR19SRUdFWCxcbiAgcmVwbGFjZTogY3JlYXRlQmxvY2tOb2RlKG1hdGNoID0+IHtcbiAgICBjb25zdCB0YWcgPSAnaCcgKyBtYXRjaFsxXS5sZW5ndGg7XG4gICAgcmV0dXJuICRjcmVhdGVIZWFkaW5nTm9kZSh0YWcpO1xuICB9KSxcbiAgdHlwZTogJ2VsZW1lbnQnXG59O1xuY29uc3QgUVVPVEUgPSB7XG4gIGRlcGVuZGVuY2llczogW1F1b3RlTm9kZV0sXG4gIGV4cG9ydDogKG5vZGUsIGV4cG9ydENoaWxkcmVuKSA9PiB7XG4gICAgaWYgKCEkaXNRdW90ZU5vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsaW5lcyA9IGV4cG9ydENoaWxkcmVuKG5vZGUpLnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIG91dHB1dC5wdXNoKCc+ICcgKyBsaW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5qb2luKCdcXG4nKTtcbiAgfSxcbiAgcmVnRXhwOiBRVU9URV9SRUdFWCxcbiAgcmVwbGFjZTogKHBhcmVudE5vZGUsIGNoaWxkcmVuLCBfbWF0Y2gsIGlzSW1wb3J0KSA9PiB7XG4gICAgaWYgKGlzSW1wb3J0KSB7XG4gICAgICBjb25zdCBwcmV2aW91c05vZGUgPSBwYXJlbnROb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgaWYgKCRpc1F1b3RlTm9kZShwcmV2aW91c05vZGUpKSB7XG4gICAgICAgIHByZXZpb3VzTm9kZS5zcGxpY2UocHJldmlvdXNOb2RlLmdldENoaWxkcmVuU2l6ZSgpLCAwLCBbJGNyZWF0ZUxpbmVCcmVha05vZGUoKSwgLi4uY2hpbGRyZW5dKTtcbiAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZVF1b3RlTm9kZSgpO1xuICAgIG5vZGUuYXBwZW5kKC4uLmNoaWxkcmVuKTtcbiAgICBwYXJlbnROb2RlLnJlcGxhY2Uobm9kZSk7XG4gICAgaWYgKCFpc0ltcG9ydCkge1xuICAgICAgbm9kZS5zZWxlY3QoMCwgMCk7XG4gICAgfVxuICB9LFxuICB0eXBlOiAnZWxlbWVudCdcbn07XG5jb25zdCBDT0RFID0ge1xuICBkZXBlbmRlbmNpZXM6IFtDb2RlTm9kZV0sXG4gIGV4cG9ydDogbm9kZSA9PiB7XG4gICAgaWYgKCEkaXNDb2RlTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRleHRDb250ZW50ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIHJldHVybiAnYGBgJyArIChub2RlLmdldExhbmd1YWdlKCkgfHwgJycpICsgKHRleHRDb250ZW50ID8gJ1xcbicgKyB0ZXh0Q29udGVudCA6ICcnKSArICdcXG4nICsgJ2BgYCc7XG4gIH0sXG4gIHJlZ0V4cEVuZDoge1xuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIHJlZ0V4cDogQ09ERV9FTkRfUkVHRVhcbiAgfSxcbiAgcmVnRXhwU3RhcnQ6IENPREVfU1RBUlRfUkVHRVgsXG4gIHJlcGxhY2U6IChyb290Tm9kZSwgY2hpbGRyZW4sIHN0YXJ0TWF0Y2gsIGVuZE1hdGNoLCBsaW5lc0luQmV0d2VlbiwgaXNJbXBvcnQpID0+IHtcbiAgICBsZXQgY29kZUJsb2NrTm9kZTtcbiAgICBsZXQgY29kZTtcbiAgICBpZiAoIWNoaWxkcmVuICYmIGxpbmVzSW5CZXR3ZWVuKSB7XG4gICAgICBpZiAobGluZXNJbkJldHdlZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIFNpbmdsZS1saW5lIGNvZGUgYmxvY2tzXG4gICAgICAgIGlmIChlbmRNYXRjaCkge1xuICAgICAgICAgIC8vIEVuZCBtYXRjaCBvbiBzYW1lIGxpbmUuIEV4YW1wbGU6IGBgYG1hcmtkb3duIGhlbGxvYGBgLiBtYXJrZG93biBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgdGhlIGxhbmd1YWdlIGhlcmUuXG4gICAgICAgICAgY29kZUJsb2NrTm9kZSA9ICRjcmVhdGVDb2RlTm9kZSgpO1xuICAgICAgICAgIGNvZGUgPSBzdGFydE1hdGNoWzFdICsgbGluZXNJbkJldHdlZW5bMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gZW5kIG1hdGNoLiBXZSBzaG91bGQgYXNzdW1lIHRoZSBsYW5ndWFnZSBpcyBuZXh0IHRvIHRoZSBiYWNrdGlja3MgYW5kIHRoYXQgY29kZSB3aWxsIGJlIHR5cGVkIG9uIHRoZSBuZXh0IGxpbmUgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAgIGNvZGVCbG9ja05vZGUgPSAkY3JlYXRlQ29kZU5vZGUoc3RhcnRNYXRjaFsxXSk7XG4gICAgICAgICAgY29kZSA9IGxpbmVzSW5CZXR3ZWVuWzBdLnN0YXJ0c1dpdGgoJyAnKSA/IGxpbmVzSW5CZXR3ZWVuWzBdLnNsaWNlKDEpIDogbGluZXNJbkJldHdlZW5bMF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRyZWF0IG11bHRpLWxpbmUgY29kZSBibG9ja3MgYXMgaWYgdGhleSBhbHdheXMgaGF2ZSBhbiBlbmQgbWF0Y2hcbiAgICAgICAgY29kZUJsb2NrTm9kZSA9ICRjcmVhdGVDb2RlTm9kZShzdGFydE1hdGNoWzFdKTtcbiAgICAgICAgaWYgKGxpbmVzSW5CZXR3ZWVuWzBdLnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGFsbCBzdGFydCBhbmQgZW5kIGxpbmVzIHRoYXQgYXJlIGxlbmd0aCAwIHVudGlsIHdlIGZpbmQgdGhlIGZpcnN0IGxpbmUgd2l0aCBjb250ZW50XG4gICAgICAgICAgd2hpbGUgKGxpbmVzSW5CZXR3ZWVuLmxlbmd0aCA+IDAgJiYgIWxpbmVzSW5CZXR3ZWVuWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgbGluZXNJbkJldHdlZW4uc2hpZnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlIGZpcnN0IGxpbmUgYWxyZWFkeSBoYXMgY29udGVudCA9PiBSZW1vdmUgdGhlIGZpcnN0IHNwYWNlIG9mIHRoZSBsaW5lIGlmIGl0IGV4aXN0c1xuICAgICAgICAgIGxpbmVzSW5CZXR3ZWVuWzBdID0gbGluZXNJbkJldHdlZW5bMF0uc3RhcnRzV2l0aCgnICcpID8gbGluZXNJbkJldHdlZW5bMF0uc2xpY2UoMSkgOiBsaW5lc0luQmV0d2VlblswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbHRlciBvdXQgYWxsIGVuZCBsaW5lcyB0aGF0IGFyZSBsZW5ndGggMCB1bnRpbCB3ZSBmaW5kIHRoZSBsYXN0IGxpbmUgd2l0aCBjb250ZW50XG4gICAgICAgIHdoaWxlIChsaW5lc0luQmV0d2Vlbi5sZW5ndGggPiAwICYmICFsaW5lc0luQmV0d2VlbltsaW5lc0luQmV0d2Vlbi5sZW5ndGggLSAxXS5sZW5ndGgpIHtcbiAgICAgICAgICBsaW5lc0luQmV0d2Vlbi5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlID0gbGluZXNJbkJldHdlZW4uam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShjb2RlKTtcbiAgICAgIGNvZGVCbG9ja05vZGUuYXBwZW5kKHRleHROb2RlKTtcbiAgICAgIHJvb3ROb2RlLmFwcGVuZChjb2RlQmxvY2tOb2RlKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBjcmVhdGVCbG9ja05vZGUobWF0Y2ggPT4ge1xuICAgICAgICByZXR1cm4gJGNyZWF0ZUNvZGVOb2RlKG1hdGNoID8gbWF0Y2hbMV0gOiB1bmRlZmluZWQpO1xuICAgICAgfSkocm9vdE5vZGUsIGNoaWxkcmVuLCBzdGFydE1hdGNoLCBpc0ltcG9ydCk7XG4gICAgfVxuICB9LFxuICB0eXBlOiAnbXVsdGlsaW5lLWVsZW1lbnQnXG59O1xuY29uc3QgVU5PUkRFUkVEX0xJU1QgPSB7XG4gIGRlcGVuZGVuY2llczogW0xpc3ROb2RlLCBMaXN0SXRlbU5vZGVdLFxuICBleHBvcnQ6IChub2RlLCBleHBvcnRDaGlsZHJlbikgPT4ge1xuICAgIHJldHVybiAkaXNMaXN0Tm9kZShub2RlKSA/IGxpc3RFeHBvcnQobm9kZSwgZXhwb3J0Q2hpbGRyZW4sIDApIDogbnVsbDtcbiAgfSxcbiAgcmVnRXhwOiBVTk9SREVSRURfTElTVF9SRUdFWCxcbiAgcmVwbGFjZTogbGlzdFJlcGxhY2UoJ2J1bGxldCcpLFxuICB0eXBlOiAnZWxlbWVudCdcbn07XG5jb25zdCBDSEVDS19MSVNUID0ge1xuICBkZXBlbmRlbmNpZXM6IFtMaXN0Tm9kZSwgTGlzdEl0ZW1Ob2RlXSxcbiAgZXhwb3J0OiAobm9kZSwgZXhwb3J0Q2hpbGRyZW4pID0+IHtcbiAgICByZXR1cm4gJGlzTGlzdE5vZGUobm9kZSkgPyBsaXN0RXhwb3J0KG5vZGUsIGV4cG9ydENoaWxkcmVuLCAwKSA6IG51bGw7XG4gIH0sXG4gIHJlZ0V4cDogQ0hFQ0tfTElTVF9SRUdFWCxcbiAgcmVwbGFjZTogbGlzdFJlcGxhY2UoJ2NoZWNrJyksXG4gIHR5cGU6ICdlbGVtZW50J1xufTtcbmNvbnN0IE9SREVSRURfTElTVCA9IHtcbiAgZGVwZW5kZW5jaWVzOiBbTGlzdE5vZGUsIExpc3RJdGVtTm9kZV0sXG4gIGV4cG9ydDogKG5vZGUsIGV4cG9ydENoaWxkcmVuKSA9PiB7XG4gICAgcmV0dXJuICRpc0xpc3ROb2RlKG5vZGUpID8gbGlzdEV4cG9ydChub2RlLCBleHBvcnRDaGlsZHJlbiwgMCkgOiBudWxsO1xuICB9LFxuICByZWdFeHA6IE9SREVSRURfTElTVF9SRUdFWCxcbiAgcmVwbGFjZTogbGlzdFJlcGxhY2UoJ251bWJlcicpLFxuICB0eXBlOiAnZWxlbWVudCdcbn07XG5jb25zdCBJTkxJTkVfQ09ERSA9IHtcbiAgZm9ybWF0OiBbJ2NvZGUnXSxcbiAgdGFnOiAnYCcsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBISUdITElHSFQgPSB7XG4gIGZvcm1hdDogWydoaWdobGlnaHQnXSxcbiAgdGFnOiAnPT0nLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59O1xuY29uc3QgQk9MRF9JVEFMSUNfU1RBUiA9IHtcbiAgZm9ybWF0OiBbJ2JvbGQnLCAnaXRhbGljJ10sXG4gIHRhZzogJyoqKicsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBCT0xEX0lUQUxJQ19VTkRFUlNDT1JFID0ge1xuICBmb3JtYXQ6IFsnYm9sZCcsICdpdGFsaWMnXSxcbiAgaW50cmF3b3JkOiBmYWxzZSxcbiAgdGFnOiAnX19fJyxcbiAgdHlwZTogJ3RleHQtZm9ybWF0J1xufTtcbmNvbnN0IEJPTERfU1RBUiA9IHtcbiAgZm9ybWF0OiBbJ2JvbGQnXSxcbiAgdGFnOiAnKionLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59O1xuY29uc3QgQk9MRF9VTkRFUlNDT1JFID0ge1xuICBmb3JtYXQ6IFsnYm9sZCddLFxuICBpbnRyYXdvcmQ6IGZhbHNlLFxuICB0YWc6ICdfXycsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBTVFJJS0VUSFJPVUdIID0ge1xuICBmb3JtYXQ6IFsnc3RyaWtldGhyb3VnaCddLFxuICB0YWc6ICd+ficsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBJVEFMSUNfU1RBUiA9IHtcbiAgZm9ybWF0OiBbJ2l0YWxpYyddLFxuICB0YWc6ICcqJyxcbiAgdHlwZTogJ3RleHQtZm9ybWF0J1xufTtcbmNvbnN0IElUQUxJQ19VTkRFUlNDT1JFID0ge1xuICBmb3JtYXQ6IFsnaXRhbGljJ10sXG4gIGludHJhd29yZDogZmFsc2UsXG4gIHRhZzogJ18nLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59O1xuXG4vLyBPcmRlciBvZiB0ZXh0IHRyYW5zZm9ybWVycyBtYXR0ZXJzOlxuLy9cbi8vIC0gY29kZSBzaG91bGQgZ28gZmlyc3QgYXMgaXQgcHJldmVudHMgYW55IHRyYW5zZm9ybWF0aW9ucyBpbnNpZGVcbi8vIC0gdGhlbiBsb25nZXIgdGFncyBtYXRjaCAoZS5nLiAqKiBvciBfXyBzaG91bGQgZ28gYmVmb3JlICogb3IgXylcbmNvbnN0IExJTksgPSB7XG4gIGRlcGVuZGVuY2llczogW0xpbmtOb2RlXSxcbiAgZXhwb3J0OiAobm9kZSwgZXhwb3J0Q2hpbGRyZW4sIGV4cG9ydEZvcm1hdCkgPT4ge1xuICAgIGlmICghJGlzTGlua05vZGUobm9kZSkgfHwgJGlzQXV0b0xpbmtOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdGl0bGUgPSBub2RlLmdldFRpdGxlKCk7XG4gICAgY29uc3QgdGV4dENvbnRlbnQgPSBleHBvcnRDaGlsZHJlbihub2RlKTtcbiAgICBjb25zdCBsaW5rQ29udGVudCA9IHRpdGxlID8gYFske3RleHRDb250ZW50fV0oJHtub2RlLmdldFVSTCgpfSBcIiR7dGl0bGV9XCIpYCA6IGBbJHt0ZXh0Q29udGVudH1dKCR7bm9kZS5nZXRVUkwoKX0pYDtcbiAgICByZXR1cm4gbGlua0NvbnRlbnQ7XG4gIH0sXG4gIGltcG9ydFJlZ0V4cDogLyg/OlxcWyhbXltdKylcXF0pKD86XFwoKD86KFteKClcXHNdKykoPzpcXHNcIigoPzpbXlwiXSpcXFxcXCIpKlteXCJdKilcIlxccyopPylcXCkpLyxcbiAgcmVnRXhwOiAvKD86XFxbKFteW10rKVxcXSkoPzpcXCgoPzooW14oKVxcc10rKSg/Olxcc1wiKCg/OlteXCJdKlxcXFxcIikqW15cIl0qKVwiXFxzKik/KVxcKSkkLyxcbiAgcmVwbGFjZTogKHRleHROb2RlLCBtYXRjaCkgPT4ge1xuICAgIGNvbnN0IFssIGxpbmtUZXh0LCBsaW5rVXJsLCBsaW5rVGl0bGVdID0gbWF0Y2g7XG4gICAgY29uc3QgbGlua05vZGUgPSAkY3JlYXRlTGlua05vZGUobGlua1VybCwge1xuICAgICAgdGl0bGU6IGxpbmtUaXRsZVxuICAgIH0pO1xuICAgIGNvbnN0IGxpbmtUZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShsaW5rVGV4dCk7XG4gICAgbGlua1RleHROb2RlLnNldEZvcm1hdCh0ZXh0Tm9kZS5nZXRGb3JtYXQoKSk7XG4gICAgbGlua05vZGUuYXBwZW5kKGxpbmtUZXh0Tm9kZSk7XG4gICAgdGV4dE5vZGUucmVwbGFjZShsaW5rTm9kZSk7XG4gICAgcmV0dXJuIGxpbmtUZXh0Tm9kZTtcbiAgfSxcbiAgdHJpZ2dlcjogJyknLFxuICB0eXBlOiAndGV4dC1tYXRjaCdcbn07XG5mdW5jdGlvbiBub3JtYWxpemVNYXJrZG93bihpbnB1dCwgc2hvdWxkTWVyZ2VBZGphY2VudExpbmVzID0gZmFsc2UpIHtcbiAgY29uc3QgbGluZXMgPSBpbnB1dC5zcGxpdCgnXFxuJyk7XG4gIGxldCBpbkNvZGVCbG9jayA9IGZhbHNlO1xuICBjb25zdCBzYW5pdGl6ZWRMaW5lcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgIGNvbnN0IGxhc3RMaW5lID0gc2FuaXRpemVkTGluZXNbc2FuaXRpemVkTGluZXMubGVuZ3RoIC0gMV07XG5cbiAgICAvLyBDb2RlIGJsb2NrcyBvZiBgYGBzaW5nbGUgbGluZWBgYCBkb24ndCB0b2dnbGUgdGhlIGluQ29kZUJsb2NrIGZsYWdcbiAgICBpZiAoQ09ERV9TSU5HTEVfTElORV9SRUdFWC50ZXN0KGxpbmUpKSB7XG4gICAgICBzYW5pdGl6ZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gRGV0ZWN0IHRoZSBzdGFydCBvciBlbmQgb2YgYSBjb2RlIGJsb2NrXG4gICAgaWYgKENPREVfU1RBUlRfUkVHRVgudGVzdChsaW5lKSB8fCBDT0RFX0VORF9SRUdFWC50ZXN0KGxpbmUpKSB7XG4gICAgICBpbkNvZGVCbG9jayA9ICFpbkNvZGVCbG9jaztcbiAgICAgIHNhbml0aXplZExpbmVzLnB1c2gobGluZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBhcmUgaW5zaWRlIGEgY29kZSBibG9jaywga2VlcCB0aGUgbGluZSB1bmNoYW5nZWRcbiAgICBpZiAoaW5Db2RlQmxvY2spIHtcbiAgICAgIHNhbml0aXplZExpbmVzLnB1c2gobGluZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBJbiBtYXJrZG93biB0aGUgY29uY2VwdCBvZiBcImVtcHR5IHBhcmFncmFwaHNcIiBkb2VzIG5vdCBleGlzdC5cbiAgICAvLyBCbG9ja3MgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgYW4gZW1wdHkgbGluZS4gTm9uLWVtcHR5IGFkamFjZW50IGxpbmVzIG11c3QgYmUgbWVyZ2VkLlxuICAgIGlmIChsaW5lID09PSAnJyB8fCBsYXN0TGluZSA9PT0gJycgfHwgIWxhc3RMaW5lIHx8IEhFQURJTkdfUkVHRVgudGVzdChsYXN0TGluZSkgfHwgSEVBRElOR19SRUdFWC50ZXN0KGxpbmUpIHx8IFFVT1RFX1JFR0VYLnRlc3QobGluZSkgfHwgT1JERVJFRF9MSVNUX1JFR0VYLnRlc3QobGluZSkgfHwgVU5PUkRFUkVEX0xJU1RfUkVHRVgudGVzdChsaW5lKSB8fCBDSEVDS19MSVNUX1JFR0VYLnRlc3QobGluZSkgfHwgVEFCTEVfUk9XX1JFR19FWFAudGVzdChsaW5lKSB8fCBUQUJMRV9ST1dfRElWSURFUl9SRUdfRVhQLnRlc3QobGluZSkgfHwgIXNob3VsZE1lcmdlQWRqYWNlbnRMaW5lcykge1xuICAgICAgc2FuaXRpemVkTGluZXMucHVzaChsaW5lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2FuaXRpemVkTGluZXNbc2FuaXRpemVkTGluZXMubGVuZ3RoIC0gMV0gPSBsYXN0TGluZSArIGxpbmU7XG4gICAgfVxuICB9XG4gIHJldHVybiBzYW5pdGl6ZWRMaW5lcy5qb2luKCdcXG4nKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBFTEVNRU5UX1RSQU5TRk9STUVSUyA9IFtIRUFESU5HLCBRVU9URSwgVU5PUkRFUkVEX0xJU1QsIE9SREVSRURfTElTVF07XG5jb25zdCBNVUxUSUxJTkVfRUxFTUVOVF9UUkFOU0ZPUk1FUlMgPSBbQ09ERV07XG5cbi8vIE9yZGVyIG9mIHRleHQgZm9ybWF0IHRyYW5zZm9ybWVycyBtYXR0ZXJzOlxuLy9cbi8vIC0gY29kZSBzaG91bGQgZ28gZmlyc3QgYXMgaXQgcHJldmVudHMgYW55IHRyYW5zZm9ybWF0aW9ucyBpbnNpZGVcbi8vIC0gdGhlbiBsb25nZXIgdGFncyBtYXRjaCAoZS5nLiAqKiBvciBfXyBzaG91bGQgZ28gYmVmb3JlICogb3IgXylcbmNvbnN0IFRFWFRfRk9STUFUX1RSQU5TRk9STUVSUyA9IFtJTkxJTkVfQ09ERSwgQk9MRF9JVEFMSUNfU1RBUiwgQk9MRF9JVEFMSUNfVU5ERVJTQ09SRSwgQk9MRF9TVEFSLCBCT0xEX1VOREVSU0NPUkUsIEhJR0hMSUdIVCwgSVRBTElDX1NUQVIsIElUQUxJQ19VTkRFUlNDT1JFLCBTVFJJS0VUSFJPVUdIXTtcbmNvbnN0IFRFWFRfTUFUQ0hfVFJBTlNGT1JNRVJTID0gW0xJTktdO1xuY29uc3QgVFJBTlNGT1JNRVJTID0gWy4uLkVMRU1FTlRfVFJBTlNGT1JNRVJTLCAuLi5NVUxUSUxJTkVfRUxFTUVOVF9UUkFOU0ZPUk1FUlMsIC4uLlRFWFRfRk9STUFUX1RSQU5TRk9STUVSUywgLi4uVEVYVF9NQVRDSF9UUkFOU0ZPUk1FUlNdO1xuXG4vKipcbiAqIFJlbmRlcnMgbWFya2Rvd24gZnJvbSBhIHN0cmluZy4gVGhlIHNlbGVjdGlvbiBpcyBtb3ZlZCB0byB0aGUgc3RhcnQgYWZ0ZXIgdGhlIG9wZXJhdGlvbi5cbiAqXG4gKiAgQHBhcmFtIHtib29sZWFufSBbc2hvdWxkUHJlc2VydmVOZXdMaW5lc10gQnkgc2V0dGluZyB0aGlzIHRvIHRydWUsIG5ldyBsaW5lcyB3aWxsIGJlIHByZXNlcnZlZCBiZXR3ZWVuIGNvbnZlcnNpb25zXG4gKiAgQHBhcmFtIHtib29sZWFufSBbc2hvdWxkTWVyZ2VBZGphY2VudExpbmVzXSBCeSBzZXR0aW5nIHRoaXMgdG8gdHJ1ZSwgYWRqYWNlbnQgbm9uIGVtcHR5IGxpbmVzIHdpbGwgYmUgbWVyZ2VkIGFjY29yZGluZyB0byBjb21tb25tYXJrIHNwZWM6IGh0dHBzOi8vc3BlYy5jb21tb25tYXJrLm9yZy8wLjI0LyNleGFtcGxlLTE3Ny4gTm90IGFwcGxpY2FibGUgaWYgc2hvdWxkUHJlc2VydmVOZXdMaW5lcyA9IHRydWUuXG4gKi9cbmZ1bmN0aW9uICRjb252ZXJ0RnJvbU1hcmtkb3duU3RyaW5nKG1hcmtkb3duLCB0cmFuc2Zvcm1lcnMgPSBUUkFOU0ZPUk1FUlMsIG5vZGUsIHNob3VsZFByZXNlcnZlTmV3TGluZXMgPSBmYWxzZSwgc2hvdWxkTWVyZ2VBZGphY2VudExpbmVzID0gZmFsc2UpIHtcbiAgY29uc3Qgc2FuaXRpemVkTWFya2Rvd24gPSBzaG91bGRQcmVzZXJ2ZU5ld0xpbmVzID8gbWFya2Rvd24gOiBub3JtYWxpemVNYXJrZG93bihtYXJrZG93biwgc2hvdWxkTWVyZ2VBZGphY2VudExpbmVzKTtcbiAgY29uc3QgaW1wb3J0TWFya2Rvd24gPSBjcmVhdGVNYXJrZG93bkltcG9ydCh0cmFuc2Zvcm1lcnMsIHNob3VsZFByZXNlcnZlTmV3TGluZXMpO1xuICByZXR1cm4gaW1wb3J0TWFya2Rvd24oc2FuaXRpemVkTWFya2Rvd24sIG5vZGUpO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgc3RyaW5nIGZyb20gbWFya2Rvd24uIFRoZSBzZWxlY3Rpb24gaXMgbW92ZWQgdG8gdGhlIHN0YXJ0IGFmdGVyIHRoZSBvcGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uICRjb252ZXJ0VG9NYXJrZG93blN0cmluZyh0cmFuc2Zvcm1lcnMgPSBUUkFOU0ZPUk1FUlMsIG5vZGUsIHNob3VsZFByZXNlcnZlTmV3TGluZXMgPSBmYWxzZSkge1xuICBjb25zdCBleHBvcnRNYXJrZG93biA9IGNyZWF0ZU1hcmtkb3duRXhwb3J0KHRyYW5zZm9ybWVycywgc2hvdWxkUHJlc2VydmVOZXdMaW5lcyk7XG4gIHJldHVybiBleHBvcnRNYXJrZG93bihub2RlKTtcbn1cblxuZXhwb3J0IHsgJGNvbnZlcnRGcm9tTWFya2Rvd25TdHJpbmcsICRjb252ZXJ0VG9NYXJrZG93blN0cmluZywgQk9MRF9JVEFMSUNfU1RBUiwgQk9MRF9JVEFMSUNfVU5ERVJTQ09SRSwgQk9MRF9TVEFSLCBCT0xEX1VOREVSU0NPUkUsIENIRUNLX0xJU1QsIENPREUsIEVMRU1FTlRfVFJBTlNGT1JNRVJTLCBIRUFESU5HLCBISUdITElHSFQsIElOTElORV9DT0RFLCBJVEFMSUNfU1RBUiwgSVRBTElDX1VOREVSU0NPUkUsIExJTkssIE1VTFRJTElORV9FTEVNRU5UX1RSQU5TRk9STUVSUywgT1JERVJFRF9MSVNULCBRVU9URSwgU1RSSUtFVEhST1VHSCwgVEVYVF9GT1JNQVRfVFJBTlNGT1JNRVJTLCBURVhUX01BVENIX1RSQU5TRk9STUVSUywgVFJBTlNGT1JNRVJTLCBVTk9SREVSRURfTElTVCwgcmVnaXN0ZXJNYXJrZG93blNob3J0Y3V0cyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lexical+markdown@0.33.1/node_modules/@lexical/markdown/LexicalMarkdown.dev.mjs\n");

/***/ })

};
;