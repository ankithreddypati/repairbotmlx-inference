"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@mdxeditor+gurx@1.2.3_react-dom@19.1.1_react@19.1.1__react@19.1.1";
exports.ids = ["vendor-chunks/@mdxeditor+gurx@1.2.3_react-dom@19.1.1_react@19.1.1__react@19.1.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@mdxeditor+gurx@1.2.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@mdxeditor/gurx/dist/index.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@mdxeditor+gurx@1.2.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@mdxeditor/gurx/dist/index.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Action: () => (/* binding */ q),\n/* harmony export */   Cell: () => (/* binding */ $),\n/* harmony export */   DerivedCell: () => (/* binding */ D),\n/* harmony export */   Realm: () => (/* binding */ T),\n/* harmony export */   RealmContext: () => (/* binding */ V),\n/* harmony export */   RealmProvider: () => (/* binding */ U),\n/* harmony export */   Signal: () => (/* binding */ K),\n/* harmony export */   changeWith: () => (/* binding */ H),\n/* harmony export */   combine: () => (/* binding */ J),\n/* harmony export */   debounceTime: () => (/* binding */ ot),\n/* harmony export */   defaultComparator: () => (/* binding */ O),\n/* harmony export */   delayWithMicrotask: () => (/* binding */ ct),\n/* harmony export */   filter: () => (/* binding */ nt),\n/* harmony export */   getValue: () => (/* binding */ Q),\n/* harmony export */   handlePromise: () => (/* binding */ at),\n/* harmony export */   link: () => (/* binding */ F),\n/* harmony export */   map: () => (/* binding */ _),\n/* harmony export */   mapTo: () => (/* binding */ et),\n/* harmony export */   onNext: () => (/* binding */ ut),\n/* harmony export */   once: () => (/* binding */ st),\n/* harmony export */   pipe: () => (/* binding */ G),\n/* harmony export */   pub: () => (/* binding */ Y),\n/* harmony export */   pubIn: () => (/* binding */ B),\n/* harmony export */   scan: () => (/* binding */ it),\n/* harmony export */   sub: () => (/* binding */ z),\n/* harmony export */   throttleTime: () => (/* binding */ rt),\n/* harmony export */   useCell: () => (/* binding */ Z),\n/* harmony export */   useCellValue: () => (/* binding */ E),\n/* harmony export */   useCellValues: () => (/* binding */ X),\n/* harmony export */   usePublisher: () => (/* binding */ A),\n/* harmony export */   useRealm: () => (/* binding */ R),\n/* harmony export */   withLatestFrom: () => (/* binding */ tt)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@15.4.5_@opentelemetry+api@1.9.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/.pnpm/next@15.4.5_@opentelemetry+api@1.9.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nvar v = Object.defineProperty;\nvar P = (s, t, e) => t in s ? v(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;\nvar f = (s, t, e) => P(s, typeof t != \"symbol\" ? t + \"\" : t, e);\n\n\nclass M {\n  constructor(t = /* @__PURE__ */ new Map()) {\n    this.map = t;\n  }\n  clone() {\n    return new M(new Map(this.map));\n  }\n  increment(t) {\n    const e = this.map.get(t) ?? 0;\n    this.map.set(t, e + 1);\n  }\n  decrement(t, e) {\n    let n = this.map.get(t);\n    n !== void 0 && (n -= 1, this.map.set(t, n), n === 0 && e());\n  }\n}\nclass C {\n  constructor() {\n    f(this, \"map\", /* @__PURE__ */ new Map());\n  }\n  getOrCreate(t) {\n    let e = this.map.get(t);\n    return e === void 0 && (e = /* @__PURE__ */ new Set(), this.map.set(t, e)), e;\n  }\n  get(t) {\n    return this.map.get(t);\n  }\n  use(t, e) {\n    const n = this.get(t);\n    n !== void 0 && e(n);\n  }\n  delete(t) {\n    return this.map.delete(t);\n  }\n}\nfunction g(s, t) {\n  return t(s), s;\n}\nfunction x() {\n}\nconst I = \"cell\";\nfunction O(s, t) {\n  return s === t;\n}\nconst k = /* @__PURE__ */ new Map();\nlet w;\nclass T {\n  /**\n   * Creates a new realm.\n   * @param initialValues - the initial cell values that will populate the realm.\n   * Those values will not trigger a recomputation cycle, and will overwrite the initial values specified for each cell.\n   */\n  constructor(t = {}) {\n    f(this, \"subscriptions\", new C());\n    f(this, \"singletonSubscriptions\", /* @__PURE__ */ new Map());\n    f(this, \"graph\", new C());\n    f(this, \"state\", /* @__PURE__ */ new Map());\n    f(this, \"distinctNodes\", /* @__PURE__ */ new Map());\n    f(this, \"executionMaps\", /* @__PURE__ */ new Map());\n    f(this, \"definitionRegistry\", /* @__PURE__ */ new Set());\n    for (const e of Object.getOwnPropertySymbols(t))\n      this.state.set(e, t[e]);\n  }\n  /**\n   * Creates or resolves an existing cell instance in the realm. Useful as a joint point when building your own operators.\n   * @returns a reference to the cell.\n   * @param value - the initial value of the cell\n   * @param distinct - true by default. Pass false to mark the signal as a non-distinct one, meaning that publishing the same value multiple times will re-trigger a recomputation cycle.\n   * @param node - optional, a reference to a cell. If the cell has not been touched in the realm before, the realm will instantiate a reference to it. If it's registered already, the function will return the reference.\n   */\n  cellInstance(t, e = !0, n = Symbol()) {\n    return this.state.has(n) || this.state.set(n, t), e !== !1 && !this.distinctNodes.has(n) && this.distinctNodes.set(n, e === !0 ? O : e), n;\n  }\n  /**\n   * Creates or resolves an existing signal instance in the realm. Useful as a joint point when building your own operators.\n   * @returns a reference to the signal.\n   * @param distinct - true by default. Pass false to mark the signal as a non-distinct one, meaning that publishing the same value multiple times will re-trigger a recomputation cycle.\n   * @param node - optional, a reference to a signal. If the signal has not been touched in the realm before, the realm will instantiate a reference to it. If it's registered already, the function will return the reference.\n   */\n  signalInstance(t = !0, e = Symbol()) {\n    return t !== !1 && this.distinctNodes.set(e, t === !0 ? O : t), e;\n  }\n  /**\n   * Subscribes to the values published in the referred node.\n   * @param node - the cell/signal to subscribe to.\n   * @param subscription - the callback to execute when the node receives a new value.\n   * @returns a function that, when called, will cancel the subscription.\n   *\n   * @example\n   * ```ts\n   * const signal$ = Signal<number>()\n   * const r = new Realm()\n   * const unsub = r.sub(signal$, console.log)\n   * r.pub(signal$, 2)\n   * unsub()\n   * r.pub(signal$, 3)\n   * ```\n   */\n  sub(t, e) {\n    this.register(t);\n    const n = this.subscriptions.getOrCreate(t);\n    return n.add(e), () => n.delete(e);\n  }\n  /**\n   * Subscribes exclusively to values in the referred node.\n   * Calling this multiple times on a single node will remove the previous subscription created through `singletonSub`.\n   * Subscriptions created through `sub` are not affected.\n   * @returns a function that, when called, will cancel the subscription.\n   *\n   * @example\n   * ```ts\n   * const signal$ = Signal<number>()\n   * const r = new Realm()\n   * // console.log will run only once.\n   * r.singletonSub(signal$, console.log)\n   * r.singletonSub(signal$, console.log)\n   * r.singletonSub(signal$, console.log)\n   * r.pub(signal$, 2)\n   * ```\n   */\n  singletonSub(t, e) {\n    return this.register(t), e === void 0 ? this.singletonSubscriptions.delete(t) : this.singletonSubscriptions.set(t, e), () => this.singletonSubscriptions.delete(t);\n  }\n  /**\n   * Clears all exclusive subscriptions.\n   */\n  resetSingletonSubs() {\n    this.singletonSubscriptions.clear();\n  }\n  // biome-ignore lint/suspicious/noExplicitAny: I know why we need any here\n  subMultiple(t, e) {\n    const n = this.signalInstance();\n    return this.connect({\n      map: (i) => (...r) => {\n        i(r);\n      },\n      sink: n,\n      sources: t\n    }), this.sub(n, e);\n  }\n  /**\n   * Publishes into multiple nodes simultaneously, triggering a single re-computation cycle.\n   * @param values - a record of node references and their values.\n   *\n   * @example\n   * ```ts\n   * const foo$ = Cell('foo')\n   * const bar$ = Cell('bar')\n   *\n   * const r = new Realm()\n   * r.pubIn({[foo$]: 'foo1', [bar$]: 'bar1'})\n   * ```\n   */\n  pubIn(t) {\n    var a;\n    const e = Reflect.ownKeys(t), n = this.getExecutionMap(e), i = n.refCount.clone(), r = n.participatingNodes.slice(), o = new Map(this.state), l = (p) => {\n      this.graph.use(p, (c) => {\n        for (const { sources: u, sink: y } of c)\n          u.has(p) && i.decrement(y, () => {\n            r.splice(r.indexOf(y), 1), l(y);\n          });\n      });\n    };\n    for (; ; ) {\n      const p = r.shift();\n      if (p === void 0)\n        break;\n      const c = p;\n      let u = !1;\n      const y = (m) => {\n        const h = this.distinctNodes.get(c);\n        if (h != null && h(o.get(c), m)) {\n          u = !1;\n          return;\n        }\n        u = !0, o.set(c, m), this.state.has(c) && this.state.set(c, m);\n      };\n      if (Object.prototype.hasOwnProperty.call(t, c) ? y(t[c]) : n.projections.use(c, (m) => {\n        for (const h of m) {\n          const S = [...Array.from(h.sources), ...Array.from(h.pulls)].map((N) => o.get(N));\n          h.map(y)(...S);\n        }\n      }), u) {\n        const m = o.get(c);\n        this.inContext(() => {\n          this.subscriptions.use(c, (h) => {\n            for (const S of h)\n              S(m);\n          });\n        }), (a = this.singletonSubscriptions.get(c)) == null || a(m);\n      } else\n        l(c);\n    }\n  }\n  /**\n   * A low-level utility that connects multiple nodes to a sink node with a map function. Used as a foundation for the higher-level operators.\n   * The nodes can be active (sources) or passive (pulls).\n   */\n  connect({\n    sources: t,\n    pulls: e = [],\n    map: n,\n    sink: i\n  }) {\n    const r = {\n      map: n,\n      pulls: new Set(e),\n      sink: this.register(i),\n      sources: new Set(t)\n    };\n    for (const o of [...t, ...e])\n      this.register(o), this.graph.getOrCreate(o).add(r);\n    this.executionMaps.clear();\n  }\n  pub(t, e) {\n    this.pubIn({ [t]: e });\n  }\n  pipe(t, ...e) {\n    return this.combineOperators(...e)(t);\n  }\n  transformer(...t) {\n    return (e) => g(this.signalInstance(), (n) => (this.link(this.pipe(n, ...t), e), n));\n  }\n  /**\n   * Links the output of a node to the input of another node.\n   */\n  link(t, e) {\n    this.connect({\n      map: (n) => (i) => {\n        n(i);\n      },\n      sink: e,\n      sources: [t]\n    });\n  }\n  // prettier-ignore\n  combine(...t) {\n    return g(this.signalInstance(), (e) => {\n      this.connect({\n        map: (n) => (...i) => {\n          n(i);\n        },\n        sink: e,\n        sources: t\n      });\n    });\n  }\n  // prettier-ignore\n  combineCells(...t) {\n    return g(\n      this.cellInstance(\n        t.map((e) => this.getValue(e)),\n        !0\n      ),\n      (e) => {\n        this.connect({\n          map: (n) => (...i) => {\n            n(i);\n          },\n          sink: e,\n          sources: t\n        });\n      }\n    );\n  }\n  /**\n   * Gets the current value of a node. The node must be stateful.\n   * @remark if possible, use {@link withLatestFrom} or {@link combine}, as getValue will not create a dependency to the passed node,\n   * which means that if you call it within a computational cycle, you may not get the correct value.\n   * @param node - the node instance.\n   * @example\n   * ```ts\n   * const foo$ = Cell('foo')\n   *\n   * const r = new Realm()\n   * r.getValue(foo$) // 'foo'\n   * r.pub(foo$, 'bar')\n   * //...\n   * r.getValue(foo$) // 'bar'\n   * ```\n   */\n  getValue(t) {\n    return this.register(t), this.state.get(t);\n  }\n  getValues(t) {\n    return t.map((e) => this.getValue(e));\n  }\n  /**\n   * Explicitly includes the specified cell/signal reference in the realm.\n   * Most of the time you don't need to do that, since any interaction with the node through a realm will register it.\n   * The only exception of that rule should be when the interaction is conditional, and the node definition includes an init function that needs to be eagerly evaluated.\n   */\n  register(t) {\n    const e = k.get(t);\n    return e === void 0 || this.definitionRegistry.has(t) ? t : (this.definitionRegistry.add(t), g(\n      e.type === I ? this.cellInstance(e.initial, e.distinct, t) : this.signalInstance(e.distinct, t),\n      (n) => {\n        this.inContext(() => {\n          e.init(this, n);\n        });\n      }\n    ));\n  }\n  inContext(t) {\n    const e = w;\n    w = this;\n    const n = t();\n    return w = e, n;\n  }\n  /**\n   * Convenient for mutation of cells that contian non-primitive values (e.g. arrays, or objects).\n   * Specifies that the cell value should be changed when source emits, with the result of the map callback parameter.\n   * the map parameter gets called with the current value of the cell and the value published through the source.\n   * @typeParam T - the type of the cell value.\n   * @typeParam K - the type of the value published through the source.\n   * @example\n   * ```ts\n   * const items$ = Cell<string[]([])\n   * const addItem$ = Signal<string>(false, (r) => {\n   *   r.changeWith(items$, addItem$, (items, item) => [...items, item])\n   * })\n   * const r = new Realm()\n   * r.pub(addItem$, 'foo')\n   * r.pub(addItem$, 'bar')\n   * r.getValue(items$) // ['foo', 'bar']\n   * ```\n   */\n  changeWith(t, e, n) {\n    this.connect({\n      sources: [e],\n      pulls: [t],\n      sink: t,\n      map: (i) => (r, o) => {\n        i(n(o, r));\n      }\n    });\n  }\n  calculateExecutionMap(t) {\n    const e = [], n = /* @__PURE__ */ new Set(), i = new C(), r = new M(), o = new C(), l = (a, p = 0) => {\n      r.increment(a), !n.has(a) && (this.register(a), i.use(a, (c) => {\n        p = Math.max(...Array.from(c).map((u) => e.indexOf(u))) + 1;\n      }), this.graph.use(a, (c) => {\n        for (const u of c)\n          u.sources.has(a) ? (o.getOrCreate(u.sink).add(u), l(u.sink, p)) : i.getOrCreate(u.sink).add(a);\n      }), n.add(a), e.splice(p, 0, a));\n    };\n    return t.forEach(l), { participatingNodes: e, pendingPulls: i, projections: o, refCount: r };\n  }\n  getExecutionMap(t) {\n    let e = t;\n    if (t.length === 1) {\n      e = t[0];\n      const i = this.executionMaps.get(e);\n      if (i !== void 0)\n        return i;\n    } else\n      for (const [i, r] of this.executionMaps.entries())\n        if (Array.isArray(i) && i.length === t.length && i.every((o) => t.includes(o)))\n          return r;\n    const n = this.calculateExecutionMap(t);\n    return this.executionMaps.set(e, n), n;\n  }\n  combineOperators(...t) {\n    return (e) => {\n      for (const n of t)\n        e = n(e, this);\n      return e;\n    };\n  }\n}\nfunction $(s, t = x, e = !0) {\n  return g(Symbol(), (n) => {\n    k.set(n, { type: I, distinct: e, initial: s, init: t });\n  });\n}\nfunction D(s, t, e = !0) {\n  return g(Symbol(), (n) => {\n    k.set(n, {\n      type: I,\n      distinct: e,\n      initial: s,\n      init: (i, r) => {\n        i.link(t(i, r), r);\n      }\n    });\n  });\n}\nfunction K(s = x, t = !1) {\n  return g(Symbol(), (e) => {\n    k.set(e, { type: \"signal\", distinct: t, init: s });\n  });\n}\nfunction q(s = x) {\n  return g(Symbol(), (t) => {\n    k.set(t, { type: \"signal\", distinct: !1, init: s });\n  });\n}\nfunction b() {\n  if (!w)\n    throw new Error(\"This function must be called within a realm instance\");\n  return w;\n}\nconst F = (s, t) => {\n  b().link(s, t);\n}, Y = (...s) => {\n  b().pub(...s);\n}, z = (...s) => b().sub(...s), B = (...s) => {\n  b().pubIn(...s);\n}, G = (...s) => b().pipe(...s), H = (...s) => {\n  b().changeWith(...s);\n}, J = (...s) => b().combine(...s), Q = (s) => b().getValue(s), V = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction U({\n  children: s,\n  initWith: t,\n  updateWith: e = {}\n}) {\n  const n = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => new T(t), []);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    n.pubIn(e);\n  }, [e, n]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(V.Provider, { value: n, children: s });\n}\nfunction R() {\n  const s = react__WEBPACK_IMPORTED_MODULE_0__.useContext(V);\n  if (s === null)\n    throw new Error(\"useRealm must be used within a RealmContextProvider\");\n  return s;\n}\nfunction E(s) {\n  const t = R();\n  t.register(s);\n  const e = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((n) => t.sub(s, n), [t, s]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore(\n    e,\n    () => t.getValue(s),\n    () => t.getValue(s)\n  );\n}\nfunction X(...s) {\n  const t = R();\n  return E(t.combineCells.apply(t, s));\n}\nfunction A(s) {\n  const t = R();\n  return t.register(s), react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (e) => {\n      t.pub(s, e);\n    },\n    [t, s]\n  );\n}\nfunction Z(s) {\n  return [E(s), A(s)];\n}\nfunction _(s) {\n  return (t, e) => {\n    const n = e.signalInstance();\n    return e.connect({\n      map: (i) => (r) => {\n        i(s(r));\n      },\n      sink: n,\n      sources: [t]\n    }), n;\n  };\n}\nfunction tt(...s) {\n  return (t, e) => {\n    const n = e.signalInstance();\n    return e.connect({\n      map: (i) => (...r) => {\n        i(r);\n      },\n      pulls: s,\n      sink: n,\n      sources: [t]\n    }), n;\n  };\n}\nfunction et(s) {\n  return (t, e) => {\n    const n = e.signalInstance();\n    return e.connect({\n      map: (i) => () => {\n        i(s);\n      },\n      sink: n,\n      sources: [t]\n    }), n;\n  };\n}\nfunction nt(s) {\n  return (t, e) => {\n    const n = e.signalInstance();\n    return e.connect({\n      map: (i) => (r) => {\n        s(r) && i(r);\n      },\n      sink: n,\n      sources: [t]\n    }), n;\n  };\n}\nfunction st() {\n  return (s, t) => {\n    const e = t.signalInstance();\n    let n = !1;\n    return t.connect({\n      map: (i) => (r) => {\n        n || (n = !0, i(r));\n      },\n      sink: e,\n      sources: [s]\n    }), e;\n  };\n}\nfunction it(s, t) {\n  return (e, n) => {\n    const i = n.signalInstance();\n    return n.connect({\n      map: (r) => (o) => {\n        r(t = s(t, o));\n      },\n      sink: i,\n      sources: [e]\n    }), i;\n  };\n}\nfunction rt(s) {\n  return (t, e) => {\n    const n = e.signalInstance();\n    let i, r = null;\n    return e.sub(t, (o) => {\n      i = o, r === null && (r = setTimeout(() => {\n        r = null, e.pub(n, i);\n      }, s));\n    }), n;\n  };\n}\nfunction ot(s) {\n  return (t, e) => {\n    const n = e.signalInstance();\n    let i, r = null;\n    return e.sub(t, (o) => {\n      i = o, r !== null && clearTimeout(r), r = setTimeout(() => {\n        e.pub(n, i);\n      }, s);\n    }), n;\n  };\n}\nfunction ct() {\n  return (s, t) => {\n    const e = t.signalInstance();\n    return t.sub(s, (n) => {\n      queueMicrotask(() => {\n        t.pub(e, n);\n      });\n    }), e;\n  };\n}\nfunction ut(s) {\n  return (t, e) => {\n    const n = e.signalInstance(), i = Symbol();\n    let r = i;\n    return e.connect({\n      map: (o) => (l) => {\n        r !== i && (o([r, l]), r = i);\n      },\n      sink: n,\n      sources: [s]\n    }), e.sub(t, (o) => {\n      r = o;\n    }), n;\n  };\n}\nfunction at(s, t, e) {\n  return (n, i) => {\n    const r = i.signalInstance();\n    return i.sub(n, (o) => {\n      o !== null && typeof o == \"object\" && \"then\" in o ? (i.pub(r, s()), o.then((l) => {\n        i.pub(r, t(l));\n      }).catch((l) => {\n        i.pub(r, e(l));\n      })) : i.pub(r, t(o));\n    }), r;\n  };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG1keGVkaXRvcitndXJ4QDEuMi4zX3JlYWN0LWRvbUAxOS4xLjFfcmVhY3RAMTkuMS4xX19yZWFjdEAxOS4xLjEvbm9kZV9tb2R1bGVzL0BtZHhlZGl0b3IvZ3VyeC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLHdDQUF3QywwREFBMEQ7QUFDbEc7QUFDMkI7QUFDa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFrQ0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbmtpdGhyZWRkeS9EZXNrdG9wL2hhY2thdGhvbnMva2FnZ2xlZ2VtbWEvbGVyZXBhaXJib3RpbmZlcmVuY2UvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BtZHhlZGl0b3IrZ3VyeEAxLjIuM19yZWFjdC1kb21AMTkuMS4xX3JlYWN0QDE5LjEuMV9fcmVhY3RAMTkuMS4xL25vZGVfbW9kdWxlcy9AbWR4ZWRpdG9yL2d1cngvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBQID0gKHMsIHQsIGUpID0+IHQgaW4gcyA/IHYocywgdCwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogZSB9KSA6IHNbdF0gPSBlO1xudmFyIGYgPSAocywgdCwgZSkgPT4gUChzLCB0eXBlb2YgdCAhPSBcInN5bWJvbFwiID8gdCArIFwiXCIgOiB0LCBlKTtcbmltcG9ydCAqIGFzIGQgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMgaiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuY2xhc3MgTSB7XG4gIGNvbnN0cnVjdG9yKHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKSB7XG4gICAgdGhpcy5tYXAgPSB0O1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgTShuZXcgTWFwKHRoaXMubWFwKSk7XG4gIH1cbiAgaW5jcmVtZW50KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5tYXAuZ2V0KHQpID8/IDA7XG4gICAgdGhpcy5tYXAuc2V0KHQsIGUgKyAxKTtcbiAgfVxuICBkZWNyZW1lbnQodCwgZSkge1xuICAgIGxldCBuID0gdGhpcy5tYXAuZ2V0KHQpO1xuICAgIG4gIT09IHZvaWQgMCAmJiAobiAtPSAxLCB0aGlzLm1hcC5zZXQodCwgbiksIG4gPT09IDAgJiYgZSgpKTtcbiAgfVxufVxuY2xhc3MgQyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGYodGhpcywgXCJtYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIH1cbiAgZ2V0T3JDcmVhdGUodCkge1xuICAgIGxldCBlID0gdGhpcy5tYXAuZ2V0KHQpO1xuICAgIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCB0aGlzLm1hcC5zZXQodCwgZSkpLCBlO1xuICB9XG4gIGdldCh0KSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmdldCh0KTtcbiAgfVxuICB1c2UodCwgZSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldCh0KTtcbiAgICBuICE9PSB2b2lkIDAgJiYgZShuKTtcbiAgfVxuICBkZWxldGUodCkge1xuICAgIHJldHVybiB0aGlzLm1hcC5kZWxldGUodCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGcocywgdCkge1xuICByZXR1cm4gdChzKSwgcztcbn1cbmZ1bmN0aW9uIHgoKSB7XG59XG5jb25zdCBJID0gXCJjZWxsXCI7XG5mdW5jdGlvbiBPKHMsIHQpIHtcbiAgcmV0dXJuIHMgPT09IHQ7XG59XG5jb25zdCBrID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmxldCB3O1xuY2xhc3MgVCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHJlYWxtLlxuICAgKiBAcGFyYW0gaW5pdGlhbFZhbHVlcyAtIHRoZSBpbml0aWFsIGNlbGwgdmFsdWVzIHRoYXQgd2lsbCBwb3B1bGF0ZSB0aGUgcmVhbG0uXG4gICAqIFRob3NlIHZhbHVlcyB3aWxsIG5vdCB0cmlnZ2VyIGEgcmVjb21wdXRhdGlvbiBjeWNsZSwgYW5kIHdpbGwgb3ZlcndyaXRlIHRoZSBpbml0aWFsIHZhbHVlcyBzcGVjaWZpZWQgZm9yIGVhY2ggY2VsbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHQgPSB7fSkge1xuICAgIGYodGhpcywgXCJzdWJzY3JpcHRpb25zXCIsIG5ldyBDKCkpO1xuICAgIGYodGhpcywgXCJzaW5nbGV0b25TdWJzY3JpcHRpb25zXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIGYodGhpcywgXCJncmFwaFwiLCBuZXcgQygpKTtcbiAgICBmKHRoaXMsIFwic3RhdGVcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgZih0aGlzLCBcImRpc3RpbmN0Tm9kZXNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgZih0aGlzLCBcImV4ZWN1dGlvbk1hcHNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgZih0aGlzLCBcImRlZmluaXRpb25SZWdpc3RyeVwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBmb3IgKGNvbnN0IGUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0KSlcbiAgICAgIHRoaXMuc3RhdGUuc2V0KGUsIHRbZV0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIG9yIHJlc29sdmVzIGFuIGV4aXN0aW5nIGNlbGwgaW5zdGFuY2UgaW4gdGhlIHJlYWxtLiBVc2VmdWwgYXMgYSBqb2ludCBwb2ludCB3aGVuIGJ1aWxkaW5nIHlvdXIgb3duIG9wZXJhdG9ycy5cbiAgICogQHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGNlbGwuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBjZWxsXG4gICAqIEBwYXJhbSBkaXN0aW5jdCAtIHRydWUgYnkgZGVmYXVsdC4gUGFzcyBmYWxzZSB0byBtYXJrIHRoZSBzaWduYWwgYXMgYSBub24tZGlzdGluY3Qgb25lLCBtZWFuaW5nIHRoYXQgcHVibGlzaGluZyB0aGUgc2FtZSB2YWx1ZSBtdWx0aXBsZSB0aW1lcyB3aWxsIHJlLXRyaWdnZXIgYSByZWNvbXB1dGF0aW9uIGN5Y2xlLlxuICAgKiBAcGFyYW0gbm9kZSAtIG9wdGlvbmFsLCBhIHJlZmVyZW5jZSB0byBhIGNlbGwuIElmIHRoZSBjZWxsIGhhcyBub3QgYmVlbiB0b3VjaGVkIGluIHRoZSByZWFsbSBiZWZvcmUsIHRoZSByZWFsbSB3aWxsIGluc3RhbnRpYXRlIGEgcmVmZXJlbmNlIHRvIGl0LiBJZiBpdCdzIHJlZ2lzdGVyZWQgYWxyZWFkeSwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZWZlcmVuY2UuXG4gICAqL1xuICBjZWxsSW5zdGFuY2UodCwgZSA9ICEwLCBuID0gU3ltYm9sKCkpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5oYXMobikgfHwgdGhpcy5zdGF0ZS5zZXQobiwgdCksIGUgIT09ICExICYmICF0aGlzLmRpc3RpbmN0Tm9kZXMuaGFzKG4pICYmIHRoaXMuZGlzdGluY3ROb2Rlcy5zZXQobiwgZSA9PT0gITAgPyBPIDogZSksIG47XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgb3IgcmVzb2x2ZXMgYW4gZXhpc3Rpbmcgc2lnbmFsIGluc3RhbmNlIGluIHRoZSByZWFsbS4gVXNlZnVsIGFzIGEgam9pbnQgcG9pbnQgd2hlbiBidWlsZGluZyB5b3VyIG93biBvcGVyYXRvcnMuXG4gICAqIEByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBzaWduYWwuXG4gICAqIEBwYXJhbSBkaXN0aW5jdCAtIHRydWUgYnkgZGVmYXVsdC4gUGFzcyBmYWxzZSB0byBtYXJrIHRoZSBzaWduYWwgYXMgYSBub24tZGlzdGluY3Qgb25lLCBtZWFuaW5nIHRoYXQgcHVibGlzaGluZyB0aGUgc2FtZSB2YWx1ZSBtdWx0aXBsZSB0aW1lcyB3aWxsIHJlLXRyaWdnZXIgYSByZWNvbXB1dGF0aW9uIGN5Y2xlLlxuICAgKiBAcGFyYW0gbm9kZSAtIG9wdGlvbmFsLCBhIHJlZmVyZW5jZSB0byBhIHNpZ25hbC4gSWYgdGhlIHNpZ25hbCBoYXMgbm90IGJlZW4gdG91Y2hlZCBpbiB0aGUgcmVhbG0gYmVmb3JlLCB0aGUgcmVhbG0gd2lsbCBpbnN0YW50aWF0ZSBhIHJlZmVyZW5jZSB0byBpdC4gSWYgaXQncyByZWdpc3RlcmVkIGFscmVhZHksIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVmZXJlbmNlLlxuICAgKi9cbiAgc2lnbmFsSW5zdGFuY2UodCA9ICEwLCBlID0gU3ltYm9sKCkpIHtcbiAgICByZXR1cm4gdCAhPT0gITEgJiYgdGhpcy5kaXN0aW5jdE5vZGVzLnNldChlLCB0ID09PSAhMCA/IE8gOiB0KSwgZTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlcyB0byB0aGUgdmFsdWVzIHB1Ymxpc2hlZCBpbiB0aGUgcmVmZXJyZWQgbm9kZS5cbiAgICogQHBhcmFtIG5vZGUgLSB0aGUgY2VsbC9zaWduYWwgdG8gc3Vic2NyaWJlIHRvLlxuICAgKiBAcGFyYW0gc3Vic2NyaXB0aW9uIC0gdGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgbm9kZSByZWNlaXZlcyBhIG5ldyB2YWx1ZS5cbiAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgd2lsbCBjYW5jZWwgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3Qgc2lnbmFsJCA9IFNpZ25hbDxudW1iZXI+KClcbiAgICogY29uc3QgciA9IG5ldyBSZWFsbSgpXG4gICAqIGNvbnN0IHVuc3ViID0gci5zdWIoc2lnbmFsJCwgY29uc29sZS5sb2cpXG4gICAqIHIucHViKHNpZ25hbCQsIDIpXG4gICAqIHVuc3ViKClcbiAgICogci5wdWIoc2lnbmFsJCwgMylcbiAgICogYGBgXG4gICAqL1xuICBzdWIodCwgZSkge1xuICAgIHRoaXMucmVnaXN0ZXIodCk7XG4gICAgY29uc3QgbiA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXRPckNyZWF0ZSh0KTtcbiAgICByZXR1cm4gbi5hZGQoZSksICgpID0+IG4uZGVsZXRlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIGV4Y2x1c2l2ZWx5IHRvIHZhbHVlcyBpbiB0aGUgcmVmZXJyZWQgbm9kZS5cbiAgICogQ2FsbGluZyB0aGlzIG11bHRpcGxlIHRpbWVzIG9uIGEgc2luZ2xlIG5vZGUgd2lsbCByZW1vdmUgdGhlIHByZXZpb3VzIHN1YnNjcmlwdGlvbiBjcmVhdGVkIHRocm91Z2ggYHNpbmdsZXRvblN1YmAuXG4gICAqIFN1YnNjcmlwdGlvbnMgY3JlYXRlZCB0aHJvdWdoIGBzdWJgIGFyZSBub3QgYWZmZWN0ZWQuXG4gICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIHdpbGwgY2FuY2VsIHRoZSBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHNpZ25hbCQgPSBTaWduYWw8bnVtYmVyPigpXG4gICAqIGNvbnN0IHIgPSBuZXcgUmVhbG0oKVxuICAgKiAvLyBjb25zb2xlLmxvZyB3aWxsIHJ1biBvbmx5IG9uY2UuXG4gICAqIHIuc2luZ2xldG9uU3ViKHNpZ25hbCQsIGNvbnNvbGUubG9nKVxuICAgKiByLnNpbmdsZXRvblN1YihzaWduYWwkLCBjb25zb2xlLmxvZylcbiAgICogci5zaW5nbGV0b25TdWIoc2lnbmFsJCwgY29uc29sZS5sb2cpXG4gICAqIHIucHViKHNpZ25hbCQsIDIpXG4gICAqIGBgYFxuICAgKi9cbiAgc2luZ2xldG9uU3ViKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3Rlcih0KSwgZSA9PT0gdm9pZCAwID8gdGhpcy5zaW5nbGV0b25TdWJzY3JpcHRpb25zLmRlbGV0ZSh0KSA6IHRoaXMuc2luZ2xldG9uU3Vic2NyaXB0aW9ucy5zZXQodCwgZSksICgpID0+IHRoaXMuc2luZ2xldG9uU3Vic2NyaXB0aW9ucy5kZWxldGUodCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgZXhjbHVzaXZlIHN1YnNjcmlwdGlvbnMuXG4gICAqL1xuICByZXNldFNpbmdsZXRvblN1YnMoKSB7XG4gICAgdGhpcy5zaW5nbGV0b25TdWJzY3JpcHRpb25zLmNsZWFyKCk7XG4gIH1cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0V4cGxpY2l0QW55OiBJIGtub3cgd2h5IHdlIG5lZWQgYW55IGhlcmVcbiAgc3ViTXVsdGlwbGUodCwgZSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLnNpZ25hbEluc3RhbmNlKCk7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdCh7XG4gICAgICBtYXA6IChpKSA9PiAoLi4ucikgPT4ge1xuICAgICAgICBpKHIpO1xuICAgICAgfSxcbiAgICAgIHNpbms6IG4sXG4gICAgICBzb3VyY2VzOiB0XG4gICAgfSksIHRoaXMuc3ViKG4sIGUpO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoZXMgaW50byBtdWx0aXBsZSBub2RlcyBzaW11bHRhbmVvdXNseSwgdHJpZ2dlcmluZyBhIHNpbmdsZSByZS1jb21wdXRhdGlvbiBjeWNsZS5cbiAgICogQHBhcmFtIHZhbHVlcyAtIGEgcmVjb3JkIG9mIG5vZGUgcmVmZXJlbmNlcyBhbmQgdGhlaXIgdmFsdWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBmb28kID0gQ2VsbCgnZm9vJylcbiAgICogY29uc3QgYmFyJCA9IENlbGwoJ2JhcicpXG4gICAqXG4gICAqIGNvbnN0IHIgPSBuZXcgUmVhbG0oKVxuICAgKiByLnB1YkluKHtbZm9vJF06ICdmb28xJywgW2JhciRdOiAnYmFyMSd9KVxuICAgKiBgYGBcbiAgICovXG4gIHB1YkluKHQpIHtcbiAgICB2YXIgYTtcbiAgICBjb25zdCBlID0gUmVmbGVjdC5vd25LZXlzKHQpLCBuID0gdGhpcy5nZXRFeGVjdXRpb25NYXAoZSksIGkgPSBuLnJlZkNvdW50LmNsb25lKCksIHIgPSBuLnBhcnRpY2lwYXRpbmdOb2Rlcy5zbGljZSgpLCBvID0gbmV3IE1hcCh0aGlzLnN0YXRlKSwgbCA9IChwKSA9PiB7XG4gICAgICB0aGlzLmdyYXBoLnVzZShwLCAoYykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHsgc291cmNlczogdSwgc2luazogeSB9IG9mIGMpXG4gICAgICAgICAgdS5oYXMocCkgJiYgaS5kZWNyZW1lbnQoeSwgKCkgPT4ge1xuICAgICAgICAgICAgci5zcGxpY2Uoci5pbmRleE9mKHkpLCAxKSwgbCh5KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZm9yICg7IDsgKSB7XG4gICAgICBjb25zdCBwID0gci5zaGlmdCgpO1xuICAgICAgaWYgKHAgPT09IHZvaWQgMClcbiAgICAgICAgYnJlYWs7XG4gICAgICBjb25zdCBjID0gcDtcbiAgICAgIGxldCB1ID0gITE7XG4gICAgICBjb25zdCB5ID0gKG0pID0+IHtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuZGlzdGluY3ROb2Rlcy5nZXQoYyk7XG4gICAgICAgIGlmIChoICE9IG51bGwgJiYgaChvLmdldChjKSwgbSkpIHtcbiAgICAgICAgICB1ID0gITE7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHUgPSAhMCwgby5zZXQoYywgbSksIHRoaXMuc3RhdGUuaGFzKGMpICYmIHRoaXMuc3RhdGUuc2V0KGMsIG0pO1xuICAgICAgfTtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCwgYykgPyB5KHRbY10pIDogbi5wcm9qZWN0aW9ucy51c2UoYywgKG0pID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBoIG9mIG0pIHtcbiAgICAgICAgICBjb25zdCBTID0gWy4uLkFycmF5LmZyb20oaC5zb3VyY2VzKSwgLi4uQXJyYXkuZnJvbShoLnB1bGxzKV0ubWFwKChOKSA9PiBvLmdldChOKSk7XG4gICAgICAgICAgaC5tYXAoeSkoLi4uUyk7XG4gICAgICAgIH1cbiAgICAgIH0pLCB1KSB7XG4gICAgICAgIGNvbnN0IG0gPSBvLmdldChjKTtcbiAgICAgICAgdGhpcy5pbkNvbnRleHQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51c2UoYywgKGgpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgUyBvZiBoKVxuICAgICAgICAgICAgICBTKG0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgKGEgPSB0aGlzLnNpbmdsZXRvblN1YnNjcmlwdGlvbnMuZ2V0KGMpKSA9PSBudWxsIHx8IGEobSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgbChjKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEEgbG93LWxldmVsIHV0aWxpdHkgdGhhdCBjb25uZWN0cyBtdWx0aXBsZSBub2RlcyB0byBhIHNpbmsgbm9kZSB3aXRoIGEgbWFwIGZ1bmN0aW9uLiBVc2VkIGFzIGEgZm91bmRhdGlvbiBmb3IgdGhlIGhpZ2hlci1sZXZlbCBvcGVyYXRvcnMuXG4gICAqIFRoZSBub2RlcyBjYW4gYmUgYWN0aXZlIChzb3VyY2VzKSBvciBwYXNzaXZlIChwdWxscykuXG4gICAqL1xuICBjb25uZWN0KHtcbiAgICBzb3VyY2VzOiB0LFxuICAgIHB1bGxzOiBlID0gW10sXG4gICAgbWFwOiBuLFxuICAgIHNpbms6IGlcbiAgfSkge1xuICAgIGNvbnN0IHIgPSB7XG4gICAgICBtYXA6IG4sXG4gICAgICBwdWxsczogbmV3IFNldChlKSxcbiAgICAgIHNpbms6IHRoaXMucmVnaXN0ZXIoaSksXG4gICAgICBzb3VyY2VzOiBuZXcgU2V0KHQpXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IG8gb2YgWy4uLnQsIC4uLmVdKVxuICAgICAgdGhpcy5yZWdpc3RlcihvKSwgdGhpcy5ncmFwaC5nZXRPckNyZWF0ZShvKS5hZGQocik7XG4gICAgdGhpcy5leGVjdXRpb25NYXBzLmNsZWFyKCk7XG4gIH1cbiAgcHViKHQsIGUpIHtcbiAgICB0aGlzLnB1YkluKHsgW3RdOiBlIH0pO1xuICB9XG4gIHBpcGUodCwgLi4uZSkge1xuICAgIHJldHVybiB0aGlzLmNvbWJpbmVPcGVyYXRvcnMoLi4uZSkodCk7XG4gIH1cbiAgdHJhbnNmb3JtZXIoLi4udCkge1xuICAgIHJldHVybiAoZSkgPT4gZyh0aGlzLnNpZ25hbEluc3RhbmNlKCksIChuKSA9PiAodGhpcy5saW5rKHRoaXMucGlwZShuLCAuLi50KSwgZSksIG4pKTtcbiAgfVxuICAvKipcbiAgICogTGlua3MgdGhlIG91dHB1dCBvZiBhIG5vZGUgdG8gdGhlIGlucHV0IG9mIGFub3RoZXIgbm9kZS5cbiAgICovXG4gIGxpbmsodCwgZSkge1xuICAgIHRoaXMuY29ubmVjdCh7XG4gICAgICBtYXA6IChuKSA9PiAoaSkgPT4ge1xuICAgICAgICBuKGkpO1xuICAgICAgfSxcbiAgICAgIHNpbms6IGUsXG4gICAgICBzb3VyY2VzOiBbdF1cbiAgICB9KTtcbiAgfVxuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgY29tYmluZSguLi50KSB7XG4gICAgcmV0dXJuIGcodGhpcy5zaWduYWxJbnN0YW5jZSgpLCAoZSkgPT4ge1xuICAgICAgdGhpcy5jb25uZWN0KHtcbiAgICAgICAgbWFwOiAobikgPT4gKC4uLmkpID0+IHtcbiAgICAgICAgICBuKGkpO1xuICAgICAgICB9LFxuICAgICAgICBzaW5rOiBlLFxuICAgICAgICBzb3VyY2VzOiB0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgY29tYmluZUNlbGxzKC4uLnQpIHtcbiAgICByZXR1cm4gZyhcbiAgICAgIHRoaXMuY2VsbEluc3RhbmNlKFxuICAgICAgICB0Lm1hcCgoZSkgPT4gdGhpcy5nZXRWYWx1ZShlKSksXG4gICAgICAgICEwXG4gICAgICApLFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgdGhpcy5jb25uZWN0KHtcbiAgICAgICAgICBtYXA6IChuKSA9PiAoLi4uaSkgPT4ge1xuICAgICAgICAgICAgbihpKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNpbms6IGUsXG4gICAgICAgICAgc291cmNlczogdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgbm9kZS4gVGhlIG5vZGUgbXVzdCBiZSBzdGF0ZWZ1bC5cbiAgICogQHJlbWFyayBpZiBwb3NzaWJsZSwgdXNlIHtAbGluayB3aXRoTGF0ZXN0RnJvbX0gb3Ige0BsaW5rIGNvbWJpbmV9LCBhcyBnZXRWYWx1ZSB3aWxsIG5vdCBjcmVhdGUgYSBkZXBlbmRlbmN5IHRvIHRoZSBwYXNzZWQgbm9kZSxcbiAgICogd2hpY2ggbWVhbnMgdGhhdCBpZiB5b3UgY2FsbCBpdCB3aXRoaW4gYSBjb21wdXRhdGlvbmFsIGN5Y2xlLCB5b3UgbWF5IG5vdCBnZXQgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAqIEBwYXJhbSBub2RlIC0gdGhlIG5vZGUgaW5zdGFuY2UuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IGZvbyQgPSBDZWxsKCdmb28nKVxuICAgKlxuICAgKiBjb25zdCByID0gbmV3IFJlYWxtKClcbiAgICogci5nZXRWYWx1ZShmb28kKSAvLyAnZm9vJ1xuICAgKiByLnB1Yihmb28kLCAnYmFyJylcbiAgICogLy8uLi5cbiAgICogci5nZXRWYWx1ZShmb28kKSAvLyAnYmFyJ1xuICAgKiBgYGBcbiAgICovXG4gIGdldFZhbHVlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3Rlcih0KSwgdGhpcy5zdGF0ZS5nZXQodCk7XG4gIH1cbiAgZ2V0VmFsdWVzKHQpIHtcbiAgICByZXR1cm4gdC5tYXAoKGUpID0+IHRoaXMuZ2V0VmFsdWUoZSkpO1xuICB9XG4gIC8qKlxuICAgKiBFeHBsaWNpdGx5IGluY2x1ZGVzIHRoZSBzcGVjaWZpZWQgY2VsbC9zaWduYWwgcmVmZXJlbmNlIGluIHRoZSByZWFsbS5cbiAgICogTW9zdCBvZiB0aGUgdGltZSB5b3UgZG9uJ3QgbmVlZCB0byBkbyB0aGF0LCBzaW5jZSBhbnkgaW50ZXJhY3Rpb24gd2l0aCB0aGUgbm9kZSB0aHJvdWdoIGEgcmVhbG0gd2lsbCByZWdpc3RlciBpdC5cbiAgICogVGhlIG9ubHkgZXhjZXB0aW9uIG9mIHRoYXQgcnVsZSBzaG91bGQgYmUgd2hlbiB0aGUgaW50ZXJhY3Rpb24gaXMgY29uZGl0aW9uYWwsIGFuZCB0aGUgbm9kZSBkZWZpbml0aW9uIGluY2x1ZGVzIGFuIGluaXQgZnVuY3Rpb24gdGhhdCBuZWVkcyB0byBiZSBlYWdlcmx5IGV2YWx1YXRlZC5cbiAgICovXG4gIHJlZ2lzdGVyKHQpIHtcbiAgICBjb25zdCBlID0gay5nZXQodCk7XG4gICAgcmV0dXJuIGUgPT09IHZvaWQgMCB8fCB0aGlzLmRlZmluaXRpb25SZWdpc3RyeS5oYXModCkgPyB0IDogKHRoaXMuZGVmaW5pdGlvblJlZ2lzdHJ5LmFkZCh0KSwgZyhcbiAgICAgIGUudHlwZSA9PT0gSSA/IHRoaXMuY2VsbEluc3RhbmNlKGUuaW5pdGlhbCwgZS5kaXN0aW5jdCwgdCkgOiB0aGlzLnNpZ25hbEluc3RhbmNlKGUuZGlzdGluY3QsIHQpLFxuICAgICAgKG4pID0+IHtcbiAgICAgICAgdGhpcy5pbkNvbnRleHQoKCkgPT4ge1xuICAgICAgICAgIGUuaW5pdCh0aGlzLCBuKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKSk7XG4gIH1cbiAgaW5Db250ZXh0KHQpIHtcbiAgICBjb25zdCBlID0gdztcbiAgICB3ID0gdGhpcztcbiAgICBjb25zdCBuID0gdCgpO1xuICAgIHJldHVybiB3ID0gZSwgbjtcbiAgfVxuICAvKipcbiAgICogQ29udmVuaWVudCBmb3IgbXV0YXRpb24gb2YgY2VsbHMgdGhhdCBjb250aWFuIG5vbi1wcmltaXRpdmUgdmFsdWVzIChlLmcuIGFycmF5cywgb3Igb2JqZWN0cykuXG4gICAqIFNwZWNpZmllcyB0aGF0IHRoZSBjZWxsIHZhbHVlIHNob3VsZCBiZSBjaGFuZ2VkIHdoZW4gc291cmNlIGVtaXRzLCB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIG1hcCBjYWxsYmFjayBwYXJhbWV0ZXIuXG4gICAqIHRoZSBtYXAgcGFyYW1ldGVyIGdldHMgY2FsbGVkIHdpdGggdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGNlbGwgYW5kIHRoZSB2YWx1ZSBwdWJsaXNoZWQgdGhyb3VnaCB0aGUgc291cmNlLlxuICAgKiBAdHlwZVBhcmFtIFQgLSB0aGUgdHlwZSBvZiB0aGUgY2VsbCB2YWx1ZS5cbiAgICogQHR5cGVQYXJhbSBLIC0gdGhlIHR5cGUgb2YgdGhlIHZhbHVlIHB1Ymxpc2hlZCB0aHJvdWdoIHRoZSBzb3VyY2UuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IGl0ZW1zJCA9IENlbGw8c3RyaW5nW10oW10pXG4gICAqIGNvbnN0IGFkZEl0ZW0kID0gU2lnbmFsPHN0cmluZz4oZmFsc2UsIChyKSA9PiB7XG4gICAqICAgci5jaGFuZ2VXaXRoKGl0ZW1zJCwgYWRkSXRlbSQsIChpdGVtcywgaXRlbSkgPT4gWy4uLml0ZW1zLCBpdGVtXSlcbiAgICogfSlcbiAgICogY29uc3QgciA9IG5ldyBSZWFsbSgpXG4gICAqIHIucHViKGFkZEl0ZW0kLCAnZm9vJylcbiAgICogci5wdWIoYWRkSXRlbSQsICdiYXInKVxuICAgKiByLmdldFZhbHVlKGl0ZW1zJCkgLy8gWydmb28nLCAnYmFyJ11cbiAgICogYGBgXG4gICAqL1xuICBjaGFuZ2VXaXRoKHQsIGUsIG4pIHtcbiAgICB0aGlzLmNvbm5lY3Qoe1xuICAgICAgc291cmNlczogW2VdLFxuICAgICAgcHVsbHM6IFt0XSxcbiAgICAgIHNpbms6IHQsXG4gICAgICBtYXA6IChpKSA9PiAociwgbykgPT4ge1xuICAgICAgICBpKG4obywgcikpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNhbGN1bGF0ZUV4ZWN1dGlvbk1hcCh0KSB7XG4gICAgY29uc3QgZSA9IFtdLCBuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgaSA9IG5ldyBDKCksIHIgPSBuZXcgTSgpLCBvID0gbmV3IEMoKSwgbCA9IChhLCBwID0gMCkgPT4ge1xuICAgICAgci5pbmNyZW1lbnQoYSksICFuLmhhcyhhKSAmJiAodGhpcy5yZWdpc3RlcihhKSwgaS51c2UoYSwgKGMpID0+IHtcbiAgICAgICAgcCA9IE1hdGgubWF4KC4uLkFycmF5LmZyb20oYykubWFwKCh1KSA9PiBlLmluZGV4T2YodSkpKSArIDE7XG4gICAgICB9KSwgdGhpcy5ncmFwaC51c2UoYSwgKGMpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB1IG9mIGMpXG4gICAgICAgICAgdS5zb3VyY2VzLmhhcyhhKSA/IChvLmdldE9yQ3JlYXRlKHUuc2luaykuYWRkKHUpLCBsKHUuc2luaywgcCkpIDogaS5nZXRPckNyZWF0ZSh1LnNpbmspLmFkZChhKTtcbiAgICAgIH0pLCBuLmFkZChhKSwgZS5zcGxpY2UocCwgMCwgYSkpO1xuICAgIH07XG4gICAgcmV0dXJuIHQuZm9yRWFjaChsKSwgeyBwYXJ0aWNpcGF0aW5nTm9kZXM6IGUsIHBlbmRpbmdQdWxsczogaSwgcHJvamVjdGlvbnM6IG8sIHJlZkNvdW50OiByIH07XG4gIH1cbiAgZ2V0RXhlY3V0aW9uTWFwKHQpIHtcbiAgICBsZXQgZSA9IHQ7XG4gICAgaWYgKHQubGVuZ3RoID09PSAxKSB7XG4gICAgICBlID0gdFswXTtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLmV4ZWN1dGlvbk1hcHMuZ2V0KGUpO1xuICAgICAgaWYgKGkgIT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfSBlbHNlXG4gICAgICBmb3IgKGNvbnN0IFtpLCByXSBvZiB0aGlzLmV4ZWN1dGlvbk1hcHMuZW50cmllcygpKVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpKSAmJiBpLmxlbmd0aCA9PT0gdC5sZW5ndGggJiYgaS5ldmVyeSgobykgPT4gdC5pbmNsdWRlcyhvKSkpXG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgY29uc3QgbiA9IHRoaXMuY2FsY3VsYXRlRXhlY3V0aW9uTWFwKHQpO1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGlvbk1hcHMuc2V0KGUsIG4pLCBuO1xuICB9XG4gIGNvbWJpbmVPcGVyYXRvcnMoLi4udCkge1xuICAgIHJldHVybiAoZSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBuIG9mIHQpXG4gICAgICAgIGUgPSBuKGUsIHRoaXMpO1xuICAgICAgcmV0dXJuIGU7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gJChzLCB0ID0geCwgZSA9ICEwKSB7XG4gIHJldHVybiBnKFN5bWJvbCgpLCAobikgPT4ge1xuICAgIGsuc2V0KG4sIHsgdHlwZTogSSwgZGlzdGluY3Q6IGUsIGluaXRpYWw6IHMsIGluaXQ6IHQgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gRChzLCB0LCBlID0gITApIHtcbiAgcmV0dXJuIGcoU3ltYm9sKCksIChuKSA9PiB7XG4gICAgay5zZXQobiwge1xuICAgICAgdHlwZTogSSxcbiAgICAgIGRpc3RpbmN0OiBlLFxuICAgICAgaW5pdGlhbDogcyxcbiAgICAgIGluaXQ6IChpLCByKSA9PiB7XG4gICAgICAgIGkubGluayh0KGksIHIpLCByKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBLKHMgPSB4LCB0ID0gITEpIHtcbiAgcmV0dXJuIGcoU3ltYm9sKCksIChlKSA9PiB7XG4gICAgay5zZXQoZSwgeyB0eXBlOiBcInNpZ25hbFwiLCBkaXN0aW5jdDogdCwgaW5pdDogcyB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBxKHMgPSB4KSB7XG4gIHJldHVybiBnKFN5bWJvbCgpLCAodCkgPT4ge1xuICAgIGsuc2V0KHQsIHsgdHlwZTogXCJzaWduYWxcIiwgZGlzdGluY3Q6ICExLCBpbml0OiBzIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGIoKSB7XG4gIGlmICghdylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIHdpdGhpbiBhIHJlYWxtIGluc3RhbmNlXCIpO1xuICByZXR1cm4gdztcbn1cbmNvbnN0IEYgPSAocywgdCkgPT4ge1xuICBiKCkubGluayhzLCB0KTtcbn0sIFkgPSAoLi4ucykgPT4ge1xuICBiKCkucHViKC4uLnMpO1xufSwgeiA9ICguLi5zKSA9PiBiKCkuc3ViKC4uLnMpLCBCID0gKC4uLnMpID0+IHtcbiAgYigpLnB1YkluKC4uLnMpO1xufSwgRyA9ICguLi5zKSA9PiBiKCkucGlwZSguLi5zKSwgSCA9ICguLi5zKSA9PiB7XG4gIGIoKS5jaGFuZ2VXaXRoKC4uLnMpO1xufSwgSiA9ICguLi5zKSA9PiBiKCkuY29tYmluZSguLi5zKSwgUSA9IChzKSA9PiBiKCkuZ2V0VmFsdWUocyksIFYgPSBkLmNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiBVKHtcbiAgY2hpbGRyZW46IHMsXG4gIGluaXRXaXRoOiB0LFxuICB1cGRhdGVXaXRoOiBlID0ge31cbn0pIHtcbiAgY29uc3QgbiA9IGQudXNlTWVtbygoKSA9PiBuZXcgVCh0KSwgW10pO1xuICByZXR1cm4gZC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIG4ucHViSW4oZSk7XG4gIH0sIFtlLCBuXSksIC8qIEBfX1BVUkVfXyAqLyBqKFYuUHJvdmlkZXIsIHsgdmFsdWU6IG4sIGNoaWxkcmVuOiBzIH0pO1xufVxuZnVuY3Rpb24gUigpIHtcbiAgY29uc3QgcyA9IGQudXNlQ29udGV4dChWKTtcbiAgaWYgKHMgPT09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlUmVhbG0gbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFJlYWxtQ29udGV4dFByb3ZpZGVyXCIpO1xuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIEUocykge1xuICBjb25zdCB0ID0gUigpO1xuICB0LnJlZ2lzdGVyKHMpO1xuICBjb25zdCBlID0gZC51c2VDYWxsYmFjaygobikgPT4gdC5zdWIocywgbiksIFt0LCBzXSk7XG4gIHJldHVybiBkLnVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgIGUsXG4gICAgKCkgPT4gdC5nZXRWYWx1ZShzKSxcbiAgICAoKSA9PiB0LmdldFZhbHVlKHMpXG4gICk7XG59XG5mdW5jdGlvbiBYKC4uLnMpIHtcbiAgY29uc3QgdCA9IFIoKTtcbiAgcmV0dXJuIEUodC5jb21iaW5lQ2VsbHMuYXBwbHkodCwgcykpO1xufVxuZnVuY3Rpb24gQShzKSB7XG4gIGNvbnN0IHQgPSBSKCk7XG4gIHJldHVybiB0LnJlZ2lzdGVyKHMpLCBkLnVzZUNhbGxiYWNrKFxuICAgIChlKSA9PiB7XG4gICAgICB0LnB1YihzLCBlKTtcbiAgICB9LFxuICAgIFt0LCBzXVxuICApO1xufVxuZnVuY3Rpb24gWihzKSB7XG4gIHJldHVybiBbRShzKSwgQShzKV07XG59XG5mdW5jdGlvbiBfKHMpIHtcbiAgcmV0dXJuICh0LCBlKSA9PiB7XG4gICAgY29uc3QgbiA9IGUuc2lnbmFsSW5zdGFuY2UoKTtcbiAgICByZXR1cm4gZS5jb25uZWN0KHtcbiAgICAgIG1hcDogKGkpID0+IChyKSA9PiB7XG4gICAgICAgIGkocyhyKSk7XG4gICAgICB9LFxuICAgICAgc2luazogbixcbiAgICAgIHNvdXJjZXM6IFt0XVxuICAgIH0pLCBuO1xuICB9O1xufVxuZnVuY3Rpb24gdHQoLi4ucykge1xuICByZXR1cm4gKHQsIGUpID0+IHtcbiAgICBjb25zdCBuID0gZS5zaWduYWxJbnN0YW5jZSgpO1xuICAgIHJldHVybiBlLmNvbm5lY3Qoe1xuICAgICAgbWFwOiAoaSkgPT4gKC4uLnIpID0+IHtcbiAgICAgICAgaShyKTtcbiAgICAgIH0sXG4gICAgICBwdWxsczogcyxcbiAgICAgIHNpbms6IG4sXG4gICAgICBzb3VyY2VzOiBbdF1cbiAgICB9KSwgbjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGV0KHMpIHtcbiAgcmV0dXJuICh0LCBlKSA9PiB7XG4gICAgY29uc3QgbiA9IGUuc2lnbmFsSW5zdGFuY2UoKTtcbiAgICByZXR1cm4gZS5jb25uZWN0KHtcbiAgICAgIG1hcDogKGkpID0+ICgpID0+IHtcbiAgICAgICAgaShzKTtcbiAgICAgIH0sXG4gICAgICBzaW5rOiBuLFxuICAgICAgc291cmNlczogW3RdXG4gICAgfSksIG47XG4gIH07XG59XG5mdW5jdGlvbiBudChzKSB7XG4gIHJldHVybiAodCwgZSkgPT4ge1xuICAgIGNvbnN0IG4gPSBlLnNpZ25hbEluc3RhbmNlKCk7XG4gICAgcmV0dXJuIGUuY29ubmVjdCh7XG4gICAgICBtYXA6IChpKSA9PiAocikgPT4ge1xuICAgICAgICBzKHIpICYmIGkocik7XG4gICAgICB9LFxuICAgICAgc2luazogbixcbiAgICAgIHNvdXJjZXM6IFt0XVxuICAgIH0pLCBuO1xuICB9O1xufVxuZnVuY3Rpb24gc3QoKSB7XG4gIHJldHVybiAocywgdCkgPT4ge1xuICAgIGNvbnN0IGUgPSB0LnNpZ25hbEluc3RhbmNlKCk7XG4gICAgbGV0IG4gPSAhMTtcbiAgICByZXR1cm4gdC5jb25uZWN0KHtcbiAgICAgIG1hcDogKGkpID0+IChyKSA9PiB7XG4gICAgICAgIG4gfHwgKG4gPSAhMCwgaShyKSk7XG4gICAgICB9LFxuICAgICAgc2luazogZSxcbiAgICAgIHNvdXJjZXM6IFtzXVxuICAgIH0pLCBlO1xuICB9O1xufVxuZnVuY3Rpb24gaXQocywgdCkge1xuICByZXR1cm4gKGUsIG4pID0+IHtcbiAgICBjb25zdCBpID0gbi5zaWduYWxJbnN0YW5jZSgpO1xuICAgIHJldHVybiBuLmNvbm5lY3Qoe1xuICAgICAgbWFwOiAocikgPT4gKG8pID0+IHtcbiAgICAgICAgcih0ID0gcyh0LCBvKSk7XG4gICAgICB9LFxuICAgICAgc2luazogaSxcbiAgICAgIHNvdXJjZXM6IFtlXVxuICAgIH0pLCBpO1xuICB9O1xufVxuZnVuY3Rpb24gcnQocykge1xuICByZXR1cm4gKHQsIGUpID0+IHtcbiAgICBjb25zdCBuID0gZS5zaWduYWxJbnN0YW5jZSgpO1xuICAgIGxldCBpLCByID0gbnVsbDtcbiAgICByZXR1cm4gZS5zdWIodCwgKG8pID0+IHtcbiAgICAgIGkgPSBvLCByID09PSBudWxsICYmIChyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHIgPSBudWxsLCBlLnB1YihuLCBpKTtcbiAgICAgIH0sIHMpKTtcbiAgICB9KSwgbjtcbiAgfTtcbn1cbmZ1bmN0aW9uIG90KHMpIHtcbiAgcmV0dXJuICh0LCBlKSA9PiB7XG4gICAgY29uc3QgbiA9IGUuc2lnbmFsSW5zdGFuY2UoKTtcbiAgICBsZXQgaSwgciA9IG51bGw7XG4gICAgcmV0dXJuIGUuc3ViKHQsIChvKSA9PiB7XG4gICAgICBpID0gbywgciAhPT0gbnVsbCAmJiBjbGVhclRpbWVvdXQociksIHIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZS5wdWIobiwgaSk7XG4gICAgICB9LCBzKTtcbiAgICB9KSwgbjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGN0KCkge1xuICByZXR1cm4gKHMsIHQpID0+IHtcbiAgICBjb25zdCBlID0gdC5zaWduYWxJbnN0YW5jZSgpO1xuICAgIHJldHVybiB0LnN1YihzLCAobikgPT4ge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0LnB1YihlLCBuKTtcbiAgICAgIH0pO1xuICAgIH0pLCBlO1xuICB9O1xufVxuZnVuY3Rpb24gdXQocykge1xuICByZXR1cm4gKHQsIGUpID0+IHtcbiAgICBjb25zdCBuID0gZS5zaWduYWxJbnN0YW5jZSgpLCBpID0gU3ltYm9sKCk7XG4gICAgbGV0IHIgPSBpO1xuICAgIHJldHVybiBlLmNvbm5lY3Qoe1xuICAgICAgbWFwOiAobykgPT4gKGwpID0+IHtcbiAgICAgICAgciAhPT0gaSAmJiAobyhbciwgbF0pLCByID0gaSk7XG4gICAgICB9LFxuICAgICAgc2luazogbixcbiAgICAgIHNvdXJjZXM6IFtzXVxuICAgIH0pLCBlLnN1Yih0LCAobykgPT4ge1xuICAgICAgciA9IG87XG4gICAgfSksIG47XG4gIH07XG59XG5mdW5jdGlvbiBhdChzLCB0LCBlKSB7XG4gIHJldHVybiAobiwgaSkgPT4ge1xuICAgIGNvbnN0IHIgPSBpLnNpZ25hbEluc3RhbmNlKCk7XG4gICAgcmV0dXJuIGkuc3ViKG4sIChvKSA9PiB7XG4gICAgICBvICE9PSBudWxsICYmIHR5cGVvZiBvID09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4gbyA/IChpLnB1YihyLCBzKCkpLCBvLnRoZW4oKGwpID0+IHtcbiAgICAgICAgaS5wdWIociwgdChsKSk7XG4gICAgICB9KS5jYXRjaCgobCkgPT4ge1xuICAgICAgICBpLnB1YihyLCBlKGwpKTtcbiAgICAgIH0pKSA6IGkucHViKHIsIHQobykpO1xuICAgIH0pLCByO1xuICB9O1xufVxuZXhwb3J0IHtcbiAgcSBhcyBBY3Rpb24sXG4gICQgYXMgQ2VsbCxcbiAgRCBhcyBEZXJpdmVkQ2VsbCxcbiAgVCBhcyBSZWFsbSxcbiAgViBhcyBSZWFsbUNvbnRleHQsXG4gIFUgYXMgUmVhbG1Qcm92aWRlcixcbiAgSyBhcyBTaWduYWwsXG4gIEggYXMgY2hhbmdlV2l0aCxcbiAgSiBhcyBjb21iaW5lLFxuICBvdCBhcyBkZWJvdW5jZVRpbWUsXG4gIE8gYXMgZGVmYXVsdENvbXBhcmF0b3IsXG4gIGN0IGFzIGRlbGF5V2l0aE1pY3JvdGFzayxcbiAgbnQgYXMgZmlsdGVyLFxuICBRIGFzIGdldFZhbHVlLFxuICBhdCBhcyBoYW5kbGVQcm9taXNlLFxuICBGIGFzIGxpbmssXG4gIF8gYXMgbWFwLFxuICBldCBhcyBtYXBUbyxcbiAgdXQgYXMgb25OZXh0LFxuICBzdCBhcyBvbmNlLFxuICBHIGFzIHBpcGUsXG4gIFkgYXMgcHViLFxuICBCIGFzIHB1YkluLFxuICBpdCBhcyBzY2FuLFxuICB6IGFzIHN1YixcbiAgcnQgYXMgdGhyb3R0bGVUaW1lLFxuICBaIGFzIHVzZUNlbGwsXG4gIEUgYXMgdXNlQ2VsbFZhbHVlLFxuICBYIGFzIHVzZUNlbGxWYWx1ZXMsXG4gIEEgYXMgdXNlUHVibGlzaGVyLFxuICBSIGFzIHVzZVJlYWxtLFxuICB0dCBhcyB3aXRoTGF0ZXN0RnJvbVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@mdxeditor+gurx@1.2.3_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@mdxeditor/gurx/dist/index.js\n");

/***/ })

};
;