"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@codemirror+lang-python@6.2.1";
exports.ids = ["vendor-chunks/@codemirror+lang-python@6.2.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@codemirror+lang-python@6.2.1/node_modules/@codemirror/lang-python/dist/index.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@codemirror+lang-python@6.2.1/node_modules/@codemirror/lang-python/dist/index.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   globalCompletion: () => (/* binding */ globalCompletion),\n/* harmony export */   localCompletionSource: () => (/* binding */ localCompletionSource),\n/* harmony export */   python: () => (/* binding */ python),\n/* harmony export */   pythonLanguage: () => (/* binding */ pythonLanguage)\n/* harmony export */ });\n/* harmony import */ var _lezer_python__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/python */ \"(ssr)/./node_modules/.pnpm/@lezer+python@1.1.18/node_modules/@lezer/python/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/.pnpm/@codemirror+language@6.11.2/node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/.pnpm/@lezer+common@1.2.3/node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/autocomplete */ \"(ssr)/./node_modules/.pnpm/@codemirror+autocomplete@6.18.6/node_modules/@codemirror/autocomplete/dist/index.js\");\n\n\n\n\n\nconst cache = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_1__.NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\n    \"Script\", \"Body\",\n    \"FunctionDefinition\", \"ClassDefinition\", \"LambdaExpression\",\n    \"ForStatement\", \"MatchClause\"\n]);\nfunction defID(type) {\n    return (node, def, outer) => {\n        if (outer)\n            return false;\n        let id = node.node.getChild(\"VariableName\");\n        if (id)\n            def(id, type);\n        return true;\n    };\n}\nconst gatherCompletions = {\n    FunctionDefinition: /*@__PURE__*/defID(\"function\"),\n    ClassDefinition: /*@__PURE__*/defID(\"class\"),\n    ForStatement(node, def, outer) {\n        if (outer)\n            for (let child = node.node.firstChild; child; child = child.nextSibling) {\n                if (child.name == \"VariableName\")\n                    def(child, \"variable\");\n                else if (child.name == \"in\")\n                    break;\n            }\n    },\n    ImportStatement(_node, def) {\n        var _a, _b;\n        let { node } = _node;\n        let isFrom = ((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"from\";\n        for (let ch = node.getChild(\"import\"); ch; ch = ch.nextSibling) {\n            if (ch.name == \"VariableName\" && ((_b = ch.nextSibling) === null || _b === void 0 ? void 0 : _b.name) != \"as\")\n                def(ch, isFrom ? \"variable\" : \"namespace\");\n        }\n    },\n    AssignStatement(node, def) {\n        for (let child = node.node.firstChild; child; child = child.nextSibling) {\n            if (child.name == \"VariableName\")\n                def(child, \"variable\");\n            else if (child.name == \":\" || child.name == \"AssignOp\")\n                break;\n        }\n    },\n    ParamList(node, def) {\n        for (let prev = null, child = node.node.firstChild; child; child = child.nextSibling) {\n            if (child.name == \"VariableName\" && (!prev || !/\\*|AssignOp/.test(prev.name)))\n                def(child, \"variable\");\n            prev = child;\n        }\n    },\n    CapturePattern: /*@__PURE__*/defID(\"variable\"),\n    AsPattern: /*@__PURE__*/defID(\"variable\"),\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached)\n        return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({ label: name, type });\n    }\n    node.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_1__.IterMode.IncludeAnonymous).iterate(node => {\n        if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def, top) || !top && ScopeNodes.has(node.name))\n                return false;\n            top = false;\n        }\n        else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))\n                completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w\\xa1-\\uffff][\\w\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\"String\", \"FormatString\", \"Comment\", \"PropertyName\"];\n/**\nCompletion source that looks up locally defined names in\nPython code.\n*/\nfunction localCompletionSource(context) {\n    let inner = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxTree)(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1)\n        return null;\n    let isWord = inner.name == \"VariableName\" ||\n        inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit)\n        return null;\n    let options = [];\n    for (let pos = inner; pos; pos = pos.parent) {\n        if (ScopeNodes.has(pos.name))\n            options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nconst globals = /*@__PURE__*/[\n    \"__annotations__\", \"__builtins__\", \"__debug__\", \"__doc__\", \"__import__\", \"__name__\",\n    \"__loader__\", \"__package__\", \"__spec__\",\n    \"False\", \"None\", \"True\"\n].map(n => ({ label: n, type: \"constant\" })).concat(/*@__PURE__*/[\n    \"ArithmeticError\", \"AssertionError\", \"AttributeError\", \"BaseException\", \"BlockingIOError\",\n    \"BrokenPipeError\", \"BufferError\", \"BytesWarning\", \"ChildProcessError\", \"ConnectionAbortedError\",\n    \"ConnectionError\", \"ConnectionRefusedError\", \"ConnectionResetError\", \"DeprecationWarning\",\n    \"EOFError\", \"Ellipsis\", \"EncodingWarning\", \"EnvironmentError\", \"Exception\", \"FileExistsError\",\n    \"FileNotFoundError\", \"FloatingPointError\", \"FutureWarning\", \"GeneratorExit\", \"IOError\",\n    \"ImportError\", \"ImportWarning\", \"IndentationError\", \"IndexError\", \"InterruptedError\",\n    \"IsADirectoryError\", \"KeyError\", \"KeyboardInterrupt\", \"LookupError\", \"MemoryError\",\n    \"ModuleNotFoundError\", \"NameError\", \"NotADirectoryError\", \"NotImplemented\", \"NotImplementedError\",\n    \"OSError\", \"OverflowError\", \"PendingDeprecationWarning\", \"PermissionError\", \"ProcessLookupError\",\n    \"RecursionError\", \"ReferenceError\", \"ResourceWarning\", \"RuntimeError\", \"RuntimeWarning\",\n    \"StopAsyncIteration\", \"StopIteration\", \"SyntaxError\", \"SyntaxWarning\", \"SystemError\",\n    \"SystemExit\", \"TabError\", \"TimeoutError\", \"TypeError\", \"UnboundLocalError\", \"UnicodeDecodeError\",\n    \"UnicodeEncodeError\", \"UnicodeError\", \"UnicodeTranslateError\", \"UnicodeWarning\", \"UserWarning\",\n    \"ValueError\", \"Warning\", \"ZeroDivisionError\"\n].map(n => ({ label: n, type: \"type\" }))).concat(/*@__PURE__*/[\n    \"bool\", \"bytearray\", \"bytes\", \"classmethod\", \"complex\", \"float\", \"frozenset\", \"int\", \"list\",\n    \"map\", \"memoryview\", \"object\", \"range\", \"set\", \"staticmethod\", \"str\", \"super\", \"tuple\", \"type\"\n].map(n => ({ label: n, type: \"class\" }))).concat(/*@__PURE__*/[\n    \"abs\", \"aiter\", \"all\", \"anext\", \"any\", \"ascii\", \"bin\", \"breakpoint\", \"callable\", \"chr\",\n    \"compile\", \"delattr\", \"dict\", \"dir\", \"divmod\", \"enumerate\", \"eval\", \"exec\", \"exit\", \"filter\",\n    \"format\", \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\", \"input\", \"isinstance\",\n    \"issubclass\", \"iter\", \"len\", \"license\", \"locals\", \"max\", \"min\", \"next\", \"oct\", \"open\",\n    \"ord\", \"pow\", \"print\", \"property\", \"quit\", \"repr\", \"reversed\", \"round\", \"setattr\", \"slice\",\n    \"sorted\", \"sum\", \"vars\", \"zip\"\n].map(n => ({ label: n, type: \"function\" })));\nconst snippets = [\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"def ${name}(${params}):\\n\\t${}\", {\n        label: \"def\",\n        detail: \"function\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"for ${name} in ${collection}:\\n\\t${}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"while ${}:\\n\\t${}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"try:\\n\\t${}\\nexcept ${error}:\\n\\t${}\", {\n        label: \"try\",\n        detail: \"/ except block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"if ${}:\\n\\t\\n\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"if ${}:\\n\\t${}\\nelse:\\n\\t${}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"class ${name}:\\n\\tdef __init__(self, ${params}):\\n\\t\\t\\t${}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"import ${module}\", {\n        label: \"import\",\n        detail: \"statement\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.snippetCompletion)(\"from ${module} import ${names}\", {\n        label: \"from\",\n        detail: \"import\",\n        type: \"keyword\"\n    })\n];\n/**\nAutocompletion for built-in Python globals and keywords.\n*/\nconst globalCompletion = /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.ifNotIn)(dontComplete, /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_3__.completeFromList)(/*@__PURE__*/globals.concat(snippets)));\n\nfunction innerBody(context) {\n    let { node, pos } = context;\n    let lineIndent = context.lineIndent(pos, -1);\n    let found = null;\n    for (;;) {\n        let before = node.childBefore(pos);\n        if (!before) {\n            break;\n        }\n        else if (before.name == \"Comment\") {\n            pos = before.from;\n        }\n        else if (before.name == \"Body\" || before.name == \"MatchBody\") {\n            if (context.baseIndentFor(before) + context.unit <= lineIndent)\n                found = before;\n            node = before;\n        }\n        else if (before.name == \"MatchClause\") {\n            node = before;\n        }\n        else if (before.type.is(\"Statement\")) {\n            node = before;\n        }\n        else {\n            break;\n        }\n    }\n    return found;\n}\nfunction indentBody(context, node) {\n    let base = context.baseIndentFor(node);\n    let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;\n    // Don't consider blank, deindented lines at the end of the\n    // block part of the block\n    if (/^\\s*($|#)/.test(line.text) &&\n        context.node.to < to + 100 &&\n        !/\\S/.test(context.state.sliceDoc(to, context.node.to)) &&\n        context.lineIndent(context.pos, -1) <= base)\n        return null;\n    // A normally deindenting keyword that appears at a higher\n    // indentation than the block should probably be handled by the next\n    // level\n    if (/^\\s*(else:|elif |except |finally:|case\\s+[^=:]+:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base)\n        return null;\n    return base + context.unit;\n}\n/**\nA language provider based on the [Lezer Python\nparser](https://github.com/lezer-parser/python), extended with\nhighlighting and indentation information.\n*/\nconst pythonLanguage = /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.LRLanguage.define({\n    name: \"python\",\n    parser: /*@__PURE__*/_lezer_python__WEBPACK_IMPORTED_MODULE_0__.parser.configure({\n        props: [\n            /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.indentNodeProp.add({\n                Body: context => {\n                    var _a;\n                    let body = /^\\s*(#|$)/.test(context.textAfter) && innerBody(context) || context.node;\n                    return (_a = indentBody(context, body)) !== null && _a !== void 0 ? _a : context.continue();\n                },\n                MatchBody: context => {\n                    var _a;\n                    let inner = innerBody(context);\n                    return (_a = indentBody(context, inner || context.node)) !== null && _a !== void 0 ? _a : context.continue();\n                },\n                IfStatement: cx => /^\\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                \"ForStatement WhileStatement\": cx => /^\\s*else:/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                TryStatement: cx => /^\\s*(except[ :]|finally:|else:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                MatchStatement: cx => {\n                    if (/^\\s*case /.test(cx.textAfter))\n                        return cx.baseIndent + cx.unit;\n                    return cx.continue();\n                },\n                \"TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression\": /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.delimitedIndent)({ closing: \")\" }),\n                \"DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression\": /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.delimitedIndent)({ closing: \"}\" }),\n                \"ArrayExpression ArrayComprehensionExpression\": /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.delimitedIndent)({ closing: \"]\" }),\n                MemberExpression: cx => cx.baseIndent + cx.unit,\n                \"String FormatString\": () => null,\n                Script: context => {\n                    var _a;\n                    let inner = innerBody(context);\n                    return (_a = (inner && indentBody(context, inner))) !== null && _a !== void 0 ? _a : context.continue();\n                },\n            }),\n            /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.foldNodeProp.add({\n                \"ArrayExpression DictionaryExpression SetExpression TupleExpression\": _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.foldInside,\n                Body: (node, state) => ({ from: node.from + 1, to: node.to - (node.to == state.doc.length ? 0 : 1) }),\n                \"String FormatString\": (node, state) => ({ from: state.doc.lineAt(node.from).to, to: node.to })\n            })\n        ],\n    }),\n    languageData: {\n        closeBrackets: {\n            brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"'''\", '\"\"\"'],\n            stringPrefixes: [\"f\", \"fr\", \"rf\", \"r\", \"u\", \"b\", \"br\", \"rb\",\n                \"F\", \"FR\", \"RF\", \"R\", \"U\", \"B\", \"BR\", \"RB\"]\n        },\n        commentTokens: { line: \"#\" },\n        // Indent logic logic are triggered upon below input patterns\n        indentOnInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:|case\\s+[^:]*:?)$/,\n    }\n});\n/**\nPython language support.\n*/\nfunction python() {\n    return new _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.LanguageSupport(pythonLanguage, [\n        pythonLanguage.data.of({ autocomplete: localCompletionSource }),\n        pythonLanguage.data.of({ autocomplete: globalCompletion }),\n    ]);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGNvZGVtaXJyb3IrbGFuZy1weXRob25ANi4yLjEvbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xhbmctcHl0aG9uL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBdUM7QUFDbUc7QUFDcEY7QUFDa0M7O0FBRXhGLCtCQUErQixzREFBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsK0NBQStDLElBQUk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDREQUE0RCxPQUFPO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0EsZ0JBQWdCLG1EQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnRUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBLGlCQUFpQiwyRUFBaUIsUUFBUSxLQUFLLEdBQUcsT0FBTyxTQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsMkVBQWlCLFFBQVEsTUFBTSxLQUFLLFdBQVcsUUFBUTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLDJFQUFpQixXQUFXLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQiwyRUFBaUIsYUFBYSxXQUFXLE1BQU0sUUFBUTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLDJFQUFpQixRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsMkVBQWlCLFFBQVEsUUFBUSxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsMkVBQWlCLFVBQVUsS0FBSywwQkFBMEIsT0FBTyxhQUFhO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsMkVBQWlCLFdBQVcsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLDJFQUFpQixTQUFTLFFBQVEsU0FBUyxNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpRUFBTyw0QkFBNEIsMEVBQWdCOztBQUV6RjtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDREQUFVO0FBQzlDO0FBQ0EseUJBQXlCLGlEQUFNO0FBQy9CO0FBQ0EseUJBQXlCLGdFQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGtIQUFrSCxxRUFBZSxHQUFHLGNBQWM7QUFDbEosZ0lBQWdJLHFFQUFlLEdBQUcsV0FBVyxHQUFHO0FBQ2hLLDZFQUE2RSxxRUFBZSxHQUFHLGNBQWM7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYix5QkFBeUIsOERBQVk7QUFDckMsc0ZBQXNGLDREQUFVO0FBQ2hHLDBDQUEwQywwRUFBMEU7QUFDcEgsMkRBQTJELG1EQUFtRDtBQUM5RyxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsU0FBUztBQUNULHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRUFBZTtBQUM5QixpQ0FBaUMscUNBQXFDO0FBQ3RFLGlDQUFpQyxnQ0FBZ0M7QUFDakU7QUFDQTs7QUFFMkUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbmtpdGhyZWRkeS9EZXNrdG9wL2hhY2thdGhvbnMva2FnZ2xlZ2VtbWEvbGVyZXBhaXJib3RpbmZlcmVuY2UvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb2RlbWlycm9yK2xhbmctcHl0aG9uQDYuMi4xL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5nLXB5dGhvbi9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlciB9IGZyb20gJ0BsZXplci9weXRob24nO1xuaW1wb3J0IHsgc3ludGF4VHJlZSwgTFJMYW5ndWFnZSwgaW5kZW50Tm9kZVByb3AsIGRlbGltaXRlZEluZGVudCwgZm9sZE5vZGVQcm9wLCBmb2xkSW5zaWRlLCBMYW5ndWFnZVN1cHBvcnQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgeyBOb2RlV2Vha01hcCwgSXRlck1vZGUgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcbmltcG9ydCB7IHNuaXBwZXRDb21wbGV0aW9uLCBpZk5vdEluLCBjb21wbGV0ZUZyb21MaXN0IH0gZnJvbSAnQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlJztcblxuY29uc3QgY2FjaGUgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVXZWFrTWFwKCk7XG5jb25zdCBTY29wZU5vZGVzID0gLypAX19QVVJFX18qL25ldyBTZXQoW1xuICAgIFwiU2NyaXB0XCIsIFwiQm9keVwiLFxuICAgIFwiRnVuY3Rpb25EZWZpbml0aW9uXCIsIFwiQ2xhc3NEZWZpbml0aW9uXCIsIFwiTGFtYmRhRXhwcmVzc2lvblwiLFxuICAgIFwiRm9yU3RhdGVtZW50XCIsIFwiTWF0Y2hDbGF1c2VcIlxuXSk7XG5mdW5jdGlvbiBkZWZJRCh0eXBlKSB7XG4gICAgcmV0dXJuIChub2RlLCBkZWYsIG91dGVyKSA9PiB7XG4gICAgICAgIGlmIChvdXRlcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGlkID0gbm9kZS5ub2RlLmdldENoaWxkKFwiVmFyaWFibGVOYW1lXCIpO1xuICAgICAgICBpZiAoaWQpXG4gICAgICAgICAgICBkZWYoaWQsIHR5cGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuY29uc3QgZ2F0aGVyQ29tcGxldGlvbnMgPSB7XG4gICAgRnVuY3Rpb25EZWZpbml0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJmdW5jdGlvblwiKSxcbiAgICBDbGFzc0RlZmluaXRpb246IC8qQF9fUFVSRV9fKi9kZWZJRChcImNsYXNzXCIpLFxuICAgIEZvclN0YXRlbWVudChub2RlLCBkZWYsIG91dGVyKSB7XG4gICAgICAgIGlmIChvdXRlcilcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkID0gbm9kZS5ub2RlLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5hbWUgPT0gXCJWYXJpYWJsZU5hbWVcIilcbiAgICAgICAgICAgICAgICAgICAgZGVmKGNoaWxkLCBcInZhcmlhYmxlXCIpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLm5hbWUgPT0gXCJpblwiKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9LFxuICAgIEltcG9ydFN0YXRlbWVudChfbm9kZSwgZGVmKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCB7IG5vZGUgfSA9IF9ub2RlO1xuICAgICAgICBsZXQgaXNGcm9tID0gKChfYSA9IG5vZGUuZmlyc3RDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09IFwiZnJvbVwiO1xuICAgICAgICBmb3IgKGxldCBjaCA9IG5vZGUuZ2V0Q2hpbGQoXCJpbXBvcnRcIik7IGNoOyBjaCA9IGNoLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAoY2gubmFtZSA9PSBcIlZhcmlhYmxlTmFtZVwiICYmICgoX2IgPSBjaC5uZXh0U2libGluZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5hbWUpICE9IFwiYXNcIilcbiAgICAgICAgICAgICAgICBkZWYoY2gsIGlzRnJvbSA/IFwidmFyaWFibGVcIiA6IFwibmFtZXNwYWNlXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBBc3NpZ25TdGF0ZW1lbnQobm9kZSwgZGVmKSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gbm9kZS5ub2RlLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQubmFtZSA9PSBcIlZhcmlhYmxlTmFtZVwiKVxuICAgICAgICAgICAgICAgIGRlZihjaGlsZCwgXCJ2YXJpYWJsZVwiKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLm5hbWUgPT0gXCI6XCIgfHwgY2hpbGQubmFtZSA9PSBcIkFzc2lnbk9wXCIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFBhcmFtTGlzdChub2RlLCBkZWYpIHtcbiAgICAgICAgZm9yIChsZXQgcHJldiA9IG51bGwsIGNoaWxkID0gbm9kZS5ub2RlLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQubmFtZSA9PSBcIlZhcmlhYmxlTmFtZVwiICYmICghcHJldiB8fCAhL1xcKnxBc3NpZ25PcC8udGVzdChwcmV2Lm5hbWUpKSlcbiAgICAgICAgICAgICAgICBkZWYoY2hpbGQsIFwidmFyaWFibGVcIik7XG4gICAgICAgICAgICBwcmV2ID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIENhcHR1cmVQYXR0ZXJuOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJ2YXJpYWJsZVwiKSxcbiAgICBBc1BhdHRlcm46IC8qQF9fUFVSRV9fKi9kZWZJRChcInZhcmlhYmxlXCIpLFxuICAgIF9fcHJvdG9fXzogbnVsbFxufTtcbmZ1bmN0aW9uIGdldFNjb3BlKGRvYywgbm9kZSkge1xuICAgIGxldCBjYWNoZWQgPSBjYWNoZS5nZXQobm9kZSk7XG4gICAgaWYgKGNhY2hlZClcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICBsZXQgY29tcGxldGlvbnMgPSBbXSwgdG9wID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBkZWYobm9kZSwgdHlwZSkge1xuICAgICAgICBsZXQgbmFtZSA9IGRvYy5zbGljZVN0cmluZyhub2RlLmZyb20sIG5vZGUudG8pO1xuICAgICAgICBjb21wbGV0aW9ucy5wdXNoKHsgbGFiZWw6IG5hbWUsIHR5cGUgfSk7XG4gICAgfVxuICAgIG5vZGUuY3Vyc29yKEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpLml0ZXJhdGUobm9kZSA9PiB7XG4gICAgICAgIGlmIChub2RlLm5hbWUpIHtcbiAgICAgICAgICAgIGxldCBnYXRoZXIgPSBnYXRoZXJDb21wbGV0aW9uc1tub2RlLm5hbWVdO1xuICAgICAgICAgICAgaWYgKGdhdGhlciAmJiBnYXRoZXIobm9kZSwgZGVmLCB0b3ApIHx8ICF0b3AgJiYgU2NvcGVOb2Rlcy5oYXMobm9kZS5uYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB0b3AgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnRvIC0gbm9kZS5mcm9tID4gODE5Mikge1xuICAgICAgICAgICAgLy8gQWxsb3cgY2FjaGluZyBmb3IgYmlnZ2VyIGludGVybmFsIG5vZGVzXG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIGdldFNjb3BlKGRvYywgbm9kZS5ub2RlKSlcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9ucy5wdXNoKGMpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY2FjaGUuc2V0KG5vZGUsIGNvbXBsZXRpb25zKTtcbiAgICByZXR1cm4gY29tcGxldGlvbnM7XG59XG5jb25zdCBJZGVudGlmaWVyID0gL15bXFx3XFx4YTEtXFx1ZmZmZl1bXFx3XFxkXFx4YTEtXFx1ZmZmZl0qJC87XG5jb25zdCBkb250Q29tcGxldGUgPSBbXCJTdHJpbmdcIiwgXCJGb3JtYXRTdHJpbmdcIiwgXCJDb21tZW50XCIsIFwiUHJvcGVydHlOYW1lXCJdO1xuLyoqXG5Db21wbGV0aW9uIHNvdXJjZSB0aGF0IGxvb2tzIHVwIGxvY2FsbHkgZGVmaW5lZCBuYW1lcyBpblxuUHl0aG9uIGNvZGUuXG4qL1xuZnVuY3Rpb24gbG9jYWxDb21wbGV0aW9uU291cmNlKGNvbnRleHQpIHtcbiAgICBsZXQgaW5uZXIgPSBzeW50YXhUcmVlKGNvbnRleHQuc3RhdGUpLnJlc29sdmVJbm5lcihjb250ZXh0LnBvcywgLTEpO1xuICAgIGlmIChkb250Q29tcGxldGUuaW5kZXhPZihpbm5lci5uYW1lKSA+IC0xKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgaXNXb3JkID0gaW5uZXIubmFtZSA9PSBcIlZhcmlhYmxlTmFtZVwiIHx8XG4gICAgICAgIGlubmVyLnRvIC0gaW5uZXIuZnJvbSA8IDIwICYmIElkZW50aWZpZXIudGVzdChjb250ZXh0LnN0YXRlLnNsaWNlRG9jKGlubmVyLmZyb20sIGlubmVyLnRvKSk7XG4gICAgaWYgKCFpc1dvcmQgJiYgIWNvbnRleHQuZXhwbGljaXQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBvcHRpb25zID0gW107XG4gICAgZm9yIChsZXQgcG9zID0gaW5uZXI7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICBpZiAoU2NvcGVOb2Rlcy5oYXMocG9zLm5hbWUpKVxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMuY29uY2F0KGdldFNjb3BlKGNvbnRleHQuc3RhdGUuZG9jLCBwb3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZnJvbTogaXNXb3JkID8gaW5uZXIuZnJvbSA6IGNvbnRleHQucG9zLFxuICAgICAgICB2YWxpZEZvcjogSWRlbnRpZmllclxuICAgIH07XG59XG5jb25zdCBnbG9iYWxzID0gLypAX19QVVJFX18qL1tcbiAgICBcIl9fYW5ub3RhdGlvbnNfX1wiLCBcIl9fYnVpbHRpbnNfX1wiLCBcIl9fZGVidWdfX1wiLCBcIl9fZG9jX19cIiwgXCJfX2ltcG9ydF9fXCIsIFwiX19uYW1lX19cIixcbiAgICBcIl9fbG9hZGVyX19cIiwgXCJfX3BhY2thZ2VfX1wiLCBcIl9fc3BlY19fXCIsXG4gICAgXCJGYWxzZVwiLCBcIk5vbmVcIiwgXCJUcnVlXCJcbl0ubWFwKG4gPT4gKHsgbGFiZWw6IG4sIHR5cGU6IFwiY29uc3RhbnRcIiB9KSkuY29uY2F0KC8qQF9fUFVSRV9fKi9bXG4gICAgXCJBcml0aG1ldGljRXJyb3JcIiwgXCJBc3NlcnRpb25FcnJvclwiLCBcIkF0dHJpYnV0ZUVycm9yXCIsIFwiQmFzZUV4Y2VwdGlvblwiLCBcIkJsb2NraW5nSU9FcnJvclwiLFxuICAgIFwiQnJva2VuUGlwZUVycm9yXCIsIFwiQnVmZmVyRXJyb3JcIiwgXCJCeXRlc1dhcm5pbmdcIiwgXCJDaGlsZFByb2Nlc3NFcnJvclwiLCBcIkNvbm5lY3Rpb25BYm9ydGVkRXJyb3JcIixcbiAgICBcIkNvbm5lY3Rpb25FcnJvclwiLCBcIkNvbm5lY3Rpb25SZWZ1c2VkRXJyb3JcIiwgXCJDb25uZWN0aW9uUmVzZXRFcnJvclwiLCBcIkRlcHJlY2F0aW9uV2FybmluZ1wiLFxuICAgIFwiRU9GRXJyb3JcIiwgXCJFbGxpcHNpc1wiLCBcIkVuY29kaW5nV2FybmluZ1wiLCBcIkVudmlyb25tZW50RXJyb3JcIiwgXCJFeGNlcHRpb25cIiwgXCJGaWxlRXhpc3RzRXJyb3JcIixcbiAgICBcIkZpbGVOb3RGb3VuZEVycm9yXCIsIFwiRmxvYXRpbmdQb2ludEVycm9yXCIsIFwiRnV0dXJlV2FybmluZ1wiLCBcIkdlbmVyYXRvckV4aXRcIiwgXCJJT0Vycm9yXCIsXG4gICAgXCJJbXBvcnRFcnJvclwiLCBcIkltcG9ydFdhcm5pbmdcIiwgXCJJbmRlbnRhdGlvbkVycm9yXCIsIFwiSW5kZXhFcnJvclwiLCBcIkludGVycnVwdGVkRXJyb3JcIixcbiAgICBcIklzQURpcmVjdG9yeUVycm9yXCIsIFwiS2V5RXJyb3JcIiwgXCJLZXlib2FyZEludGVycnVwdFwiLCBcIkxvb2t1cEVycm9yXCIsIFwiTWVtb3J5RXJyb3JcIixcbiAgICBcIk1vZHVsZU5vdEZvdW5kRXJyb3JcIiwgXCJOYW1lRXJyb3JcIiwgXCJOb3RBRGlyZWN0b3J5RXJyb3JcIiwgXCJOb3RJbXBsZW1lbnRlZFwiLCBcIk5vdEltcGxlbWVudGVkRXJyb3JcIixcbiAgICBcIk9TRXJyb3JcIiwgXCJPdmVyZmxvd0Vycm9yXCIsIFwiUGVuZGluZ0RlcHJlY2F0aW9uV2FybmluZ1wiLCBcIlBlcm1pc3Npb25FcnJvclwiLCBcIlByb2Nlc3NMb29rdXBFcnJvclwiLFxuICAgIFwiUmVjdXJzaW9uRXJyb3JcIiwgXCJSZWZlcmVuY2VFcnJvclwiLCBcIlJlc291cmNlV2FybmluZ1wiLCBcIlJ1bnRpbWVFcnJvclwiLCBcIlJ1bnRpbWVXYXJuaW5nXCIsXG4gICAgXCJTdG9wQXN5bmNJdGVyYXRpb25cIiwgXCJTdG9wSXRlcmF0aW9uXCIsIFwiU3ludGF4RXJyb3JcIiwgXCJTeW50YXhXYXJuaW5nXCIsIFwiU3lzdGVtRXJyb3JcIixcbiAgICBcIlN5c3RlbUV4aXRcIiwgXCJUYWJFcnJvclwiLCBcIlRpbWVvdXRFcnJvclwiLCBcIlR5cGVFcnJvclwiLCBcIlVuYm91bmRMb2NhbEVycm9yXCIsIFwiVW5pY29kZURlY29kZUVycm9yXCIsXG4gICAgXCJVbmljb2RlRW5jb2RlRXJyb3JcIiwgXCJVbmljb2RlRXJyb3JcIiwgXCJVbmljb2RlVHJhbnNsYXRlRXJyb3JcIiwgXCJVbmljb2RlV2FybmluZ1wiLCBcIlVzZXJXYXJuaW5nXCIsXG4gICAgXCJWYWx1ZUVycm9yXCIsIFwiV2FybmluZ1wiLCBcIlplcm9EaXZpc2lvbkVycm9yXCJcbl0ubWFwKG4gPT4gKHsgbGFiZWw6IG4sIHR5cGU6IFwidHlwZVwiIH0pKSkuY29uY2F0KC8qQF9fUFVSRV9fKi9bXG4gICAgXCJib29sXCIsIFwiYnl0ZWFycmF5XCIsIFwiYnl0ZXNcIiwgXCJjbGFzc21ldGhvZFwiLCBcImNvbXBsZXhcIiwgXCJmbG9hdFwiLCBcImZyb3plbnNldFwiLCBcImludFwiLCBcImxpc3RcIixcbiAgICBcIm1hcFwiLCBcIm1lbW9yeXZpZXdcIiwgXCJvYmplY3RcIiwgXCJyYW5nZVwiLCBcInNldFwiLCBcInN0YXRpY21ldGhvZFwiLCBcInN0clwiLCBcInN1cGVyXCIsIFwidHVwbGVcIiwgXCJ0eXBlXCJcbl0ubWFwKG4gPT4gKHsgbGFiZWw6IG4sIHR5cGU6IFwiY2xhc3NcIiB9KSkpLmNvbmNhdCgvKkBfX1BVUkVfXyovW1xuICAgIFwiYWJzXCIsIFwiYWl0ZXJcIiwgXCJhbGxcIiwgXCJhbmV4dFwiLCBcImFueVwiLCBcImFzY2lpXCIsIFwiYmluXCIsIFwiYnJlYWtwb2ludFwiLCBcImNhbGxhYmxlXCIsIFwiY2hyXCIsXG4gICAgXCJjb21waWxlXCIsIFwiZGVsYXR0clwiLCBcImRpY3RcIiwgXCJkaXJcIiwgXCJkaXZtb2RcIiwgXCJlbnVtZXJhdGVcIiwgXCJldmFsXCIsIFwiZXhlY1wiLCBcImV4aXRcIiwgXCJmaWx0ZXJcIixcbiAgICBcImZvcm1hdFwiLCBcImdldGF0dHJcIiwgXCJnbG9iYWxzXCIsIFwiaGFzYXR0clwiLCBcImhhc2hcIiwgXCJoZWxwXCIsIFwiaGV4XCIsIFwiaWRcIiwgXCJpbnB1dFwiLCBcImlzaW5zdGFuY2VcIixcbiAgICBcImlzc3ViY2xhc3NcIiwgXCJpdGVyXCIsIFwibGVuXCIsIFwibGljZW5zZVwiLCBcImxvY2Fsc1wiLCBcIm1heFwiLCBcIm1pblwiLCBcIm5leHRcIiwgXCJvY3RcIiwgXCJvcGVuXCIsXG4gICAgXCJvcmRcIiwgXCJwb3dcIiwgXCJwcmludFwiLCBcInByb3BlcnR5XCIsIFwicXVpdFwiLCBcInJlcHJcIiwgXCJyZXZlcnNlZFwiLCBcInJvdW5kXCIsIFwic2V0YXR0clwiLCBcInNsaWNlXCIsXG4gICAgXCJzb3J0ZWRcIiwgXCJzdW1cIiwgXCJ2YXJzXCIsIFwiemlwXCJcbl0ubWFwKG4gPT4gKHsgbGFiZWw6IG4sIHR5cGU6IFwiZnVuY3Rpb25cIiB9KSkpO1xuY29uc3Qgc25pcHBldHMgPSBbXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiZGVmICR7bmFtZX0oJHtwYXJhbXN9KTpcXG5cXHQke31cIiwge1xuICAgICAgICBsYWJlbDogXCJkZWZcIixcbiAgICAgICAgZGV0YWlsOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiZm9yICR7bmFtZX0gaW4gJHtjb2xsZWN0aW9ufTpcXG5cXHQke31cIiwge1xuICAgICAgICBsYWJlbDogXCJmb3JcIixcbiAgICAgICAgZGV0YWlsOiBcImxvb3BcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJ3aGlsZSAke306XFxuXFx0JHt9XCIsIHtcbiAgICAgICAgbGFiZWw6IFwid2hpbGVcIixcbiAgICAgICAgZGV0YWlsOiBcImxvb3BcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJ0cnk6XFxuXFx0JHt9XFxuZXhjZXB0ICR7ZXJyb3J9OlxcblxcdCR7fVwiLCB7XG4gICAgICAgIGxhYmVsOiBcInRyeVwiLFxuICAgICAgICBkZXRhaWw6IFwiLyBleGNlcHQgYmxvY2tcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJpZiAke306XFxuXFx0XFxuXCIsIHtcbiAgICAgICAgbGFiZWw6IFwiaWZcIixcbiAgICAgICAgZGV0YWlsOiBcImJsb2NrXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiaWYgJHt9OlxcblxcdCR7fVxcbmVsc2U6XFxuXFx0JHt9XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiaWZcIixcbiAgICAgICAgZGV0YWlsOiBcIi8gZWxzZSBibG9ja1wiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImNsYXNzICR7bmFtZX06XFxuXFx0ZGVmIF9faW5pdF9fKHNlbGYsICR7cGFyYW1zfSk6XFxuXFx0XFx0XFx0JHt9XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiY2xhc3NcIixcbiAgICAgICAgZGV0YWlsOiBcImRlZmluaXRpb25cIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJpbXBvcnQgJHttb2R1bGV9XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiaW1wb3J0XCIsXG4gICAgICAgIGRldGFpbDogXCJzdGF0ZW1lbnRcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJmcm9tICR7bW9kdWxlfSBpbXBvcnQgJHtuYW1lc31cIiwge1xuICAgICAgICBsYWJlbDogXCJmcm9tXCIsXG4gICAgICAgIGRldGFpbDogXCJpbXBvcnRcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KVxuXTtcbi8qKlxuQXV0b2NvbXBsZXRpb24gZm9yIGJ1aWx0LWluIFB5dGhvbiBnbG9iYWxzIGFuZCBrZXl3b3Jkcy5cbiovXG5jb25zdCBnbG9iYWxDb21wbGV0aW9uID0gLypAX19QVVJFX18qL2lmTm90SW4oZG9udENvbXBsZXRlLCAvKkBfX1BVUkVfXyovY29tcGxldGVGcm9tTGlzdCgvKkBfX1BVUkVfXyovZ2xvYmFscy5jb25jYXQoc25pcHBldHMpKSk7XG5cbmZ1bmN0aW9uIGlubmVyQm9keShjb250ZXh0KSB7XG4gICAgbGV0IHsgbm9kZSwgcG9zIH0gPSBjb250ZXh0O1xuICAgIGxldCBsaW5lSW5kZW50ID0gY29udGV4dC5saW5lSW5kZW50KHBvcywgLTEpO1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZEJlZm9yZShwb3MpO1xuICAgICAgICBpZiAoIWJlZm9yZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmVmb3JlLm5hbWUgPT0gXCJDb21tZW50XCIpIHtcbiAgICAgICAgICAgIHBvcyA9IGJlZm9yZS5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJlZm9yZS5uYW1lID09IFwiQm9keVwiIHx8IGJlZm9yZS5uYW1lID09IFwiTWF0Y2hCb2R5XCIpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmJhc2VJbmRlbnRGb3IoYmVmb3JlKSArIGNvbnRleHQudW5pdCA8PSBsaW5lSW5kZW50KVxuICAgICAgICAgICAgICAgIGZvdW5kID0gYmVmb3JlO1xuICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiZWZvcmUubmFtZSA9PSBcIk1hdGNoQ2xhdXNlXCIpIHtcbiAgICAgICAgICAgIG5vZGUgPSBiZWZvcmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmVmb3JlLnR5cGUuaXMoXCJTdGF0ZW1lbnRcIikpIHtcbiAgICAgICAgICAgIG5vZGUgPSBiZWZvcmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBpbmRlbnRCb2R5KGNvbnRleHQsIG5vZGUpIHtcbiAgICBsZXQgYmFzZSA9IGNvbnRleHQuYmFzZUluZGVudEZvcihub2RlKTtcbiAgICBsZXQgbGluZSA9IGNvbnRleHQubGluZUF0KGNvbnRleHQucG9zLCAtMSksIHRvID0gbGluZS5mcm9tICsgbGluZS50ZXh0Lmxlbmd0aDtcbiAgICAvLyBEb24ndCBjb25zaWRlciBibGFuaywgZGVpbmRlbnRlZCBsaW5lcyBhdCB0aGUgZW5kIG9mIHRoZVxuICAgIC8vIGJsb2NrIHBhcnQgb2YgdGhlIGJsb2NrXG4gICAgaWYgKC9eXFxzKigkfCMpLy50ZXN0KGxpbmUudGV4dCkgJiZcbiAgICAgICAgY29udGV4dC5ub2RlLnRvIDwgdG8gKyAxMDAgJiZcbiAgICAgICAgIS9cXFMvLnRlc3QoY29udGV4dC5zdGF0ZS5zbGljZURvYyh0bywgY29udGV4dC5ub2RlLnRvKSkgJiZcbiAgICAgICAgY29udGV4dC5saW5lSW5kZW50KGNvbnRleHQucG9zLCAtMSkgPD0gYmFzZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gQSBub3JtYWxseSBkZWluZGVudGluZyBrZXl3b3JkIHRoYXQgYXBwZWFycyBhdCBhIGhpZ2hlclxuICAgIC8vIGluZGVudGF0aW9uIHRoYW4gdGhlIGJsb2NrIHNob3VsZCBwcm9iYWJseSBiZSBoYW5kbGVkIGJ5IHRoZSBuZXh0XG4gICAgLy8gbGV2ZWxcbiAgICBpZiAoL15cXHMqKGVsc2U6fGVsaWYgfGV4Y2VwdCB8ZmluYWxseTp8Y2FzZVxccytbXj06XSs6KS8udGVzdChjb250ZXh0LnRleHRBZnRlcikgJiYgY29udGV4dC5saW5lSW5kZW50KGNvbnRleHQucG9zLCAtMSkgPiBiYXNlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gYmFzZSArIGNvbnRleHQudW5pdDtcbn1cbi8qKlxuQSBsYW5ndWFnZSBwcm92aWRlciBiYXNlZCBvbiB0aGUgW0xlemVyIFB5dGhvblxucGFyc2VyXShodHRwczovL2dpdGh1Yi5jb20vbGV6ZXItcGFyc2VyL3B5dGhvbiksIGV4dGVuZGVkIHdpdGhcbmhpZ2hsaWdodGluZyBhbmQgaW5kZW50YXRpb24gaW5mb3JtYXRpb24uXG4qL1xuY29uc3QgcHl0aG9uTGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovTFJMYW5ndWFnZS5kZWZpbmUoe1xuICAgIG5hbWU6IFwicHl0aG9uXCIsXG4gICAgcGFyc2VyOiAvKkBfX1BVUkVfXyovcGFyc2VyLmNvbmZpZ3VyZSh7XG4gICAgICAgIHByb3BzOiBbXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovaW5kZW50Tm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBCb2R5OiBjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYm9keSA9IC9eXFxzKigjfCQpLy50ZXN0KGNvbnRleHQudGV4dEFmdGVyKSAmJiBpbm5lckJvZHkoY29udGV4dCkgfHwgY29udGV4dC5ub2RlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gaW5kZW50Qm9keShjb250ZXh0LCBib2R5KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29udGV4dC5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgTWF0Y2hCb2R5OiBjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBpbm5lckJvZHkoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2EgPSBpbmRlbnRCb2R5KGNvbnRleHQsIGlubmVyIHx8IGNvbnRleHQubm9kZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnRleHQuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIElmU3RhdGVtZW50OiBjeCA9PiAvXlxccyooZWxzZTp8ZWxpZiApLy50ZXN0KGN4LnRleHRBZnRlcikgPyBjeC5iYXNlSW5kZW50IDogY3guY29udGludWUoKSxcbiAgICAgICAgICAgICAgICBcIkZvclN0YXRlbWVudCBXaGlsZVN0YXRlbWVudFwiOiBjeCA9PiAvXlxccyplbHNlOi8udGVzdChjeC50ZXh0QWZ0ZXIpID8gY3guYmFzZUluZGVudCA6IGN4LmNvbnRpbnVlKCksXG4gICAgICAgICAgICAgICAgVHJ5U3RhdGVtZW50OiBjeCA9PiAvXlxccyooZXhjZXB0WyA6XXxmaW5hbGx5OnxlbHNlOikvLnRlc3QoY3gudGV4dEFmdGVyKSA/IGN4LmJhc2VJbmRlbnQgOiBjeC5jb250aW51ZSgpLFxuICAgICAgICAgICAgICAgIE1hdGNoU3RhdGVtZW50OiBjeCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvXlxccypjYXNlIC8udGVzdChjeC50ZXh0QWZ0ZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN4LmJhc2VJbmRlbnQgKyBjeC51bml0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3guY29udGludWUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiVHVwbGVFeHByZXNzaW9uIENvbXByZWhlbnNpb25FeHByZXNzaW9uIFBhcmFtTGlzdCBBcmdMaXN0IFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6IC8qQF9fUFVSRV9fKi9kZWxpbWl0ZWRJbmRlbnQoeyBjbG9zaW5nOiBcIilcIiB9KSxcbiAgICAgICAgICAgICAgICBcIkRpY3Rpb25hcnlFeHByZXNzaW9uIERpY3Rpb25hcnlDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiBTZXRFeHByZXNzaW9uIFNldENvbXByZWhlbnNpb25FeHByZXNzaW9uXCI6IC8qQF9fUFVSRV9fKi9kZWxpbWl0ZWRJbmRlbnQoeyBjbG9zaW5nOiBcIn1cIiB9KSxcbiAgICAgICAgICAgICAgICBcIkFycmF5RXhwcmVzc2lvbiBBcnJheUNvbXByZWhlbnNpb25FeHByZXNzaW9uXCI6IC8qQF9fUFVSRV9fKi9kZWxpbWl0ZWRJbmRlbnQoeyBjbG9zaW5nOiBcIl1cIiB9KSxcbiAgICAgICAgICAgICAgICBNZW1iZXJFeHByZXNzaW9uOiBjeCA9PiBjeC5iYXNlSW5kZW50ICsgY3gudW5pdCxcbiAgICAgICAgICAgICAgICBcIlN0cmluZyBGb3JtYXRTdHJpbmdcIjogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgICAgICBTY3JpcHQ6IGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGlubmVyQm9keShjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IChpbm5lciAmJiBpbmRlbnRCb2R5KGNvbnRleHQsIGlubmVyKSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnRleHQuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovZm9sZE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgXCJBcnJheUV4cHJlc3Npb24gRGljdGlvbmFyeUV4cHJlc3Npb24gU2V0RXhwcmVzc2lvbiBUdXBsZUV4cHJlc3Npb25cIjogZm9sZEluc2lkZSxcbiAgICAgICAgICAgICAgICBCb2R5OiAobm9kZSwgc3RhdGUpID0+ICh7IGZyb206IG5vZGUuZnJvbSArIDEsIHRvOiBub2RlLnRvIC0gKG5vZGUudG8gPT0gc3RhdGUuZG9jLmxlbmd0aCA/IDAgOiAxKSB9KSxcbiAgICAgICAgICAgICAgICBcIlN0cmluZyBGb3JtYXRTdHJpbmdcIjogKG5vZGUsIHN0YXRlKSA9PiAoeyBmcm9tOiBzdGF0ZS5kb2MubGluZUF0KG5vZGUuZnJvbSkudG8sIHRvOiBub2RlLnRvIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICBdLFxuICAgIH0pLFxuICAgIGxhbmd1YWdlRGF0YToge1xuICAgICAgICBjbG9zZUJyYWNrZXRzOiB7XG4gICAgICAgICAgICBicmFja2V0czogW1wiKFwiLCBcIltcIiwgXCJ7XCIsIFwiJ1wiLCAnXCInLCBcIicnJ1wiLCAnXCJcIlwiJ10sXG4gICAgICAgICAgICBzdHJpbmdQcmVmaXhlczogW1wiZlwiLCBcImZyXCIsIFwicmZcIiwgXCJyXCIsIFwidVwiLCBcImJcIiwgXCJiclwiLCBcInJiXCIsXG4gICAgICAgICAgICAgICAgXCJGXCIsIFwiRlJcIiwgXCJSRlwiLCBcIlJcIiwgXCJVXCIsIFwiQlwiLCBcIkJSXCIsIFwiUkJcIl1cbiAgICAgICAgfSxcbiAgICAgICAgY29tbWVudFRva2VuczogeyBsaW5lOiBcIiNcIiB9LFxuICAgICAgICAvLyBJbmRlbnQgbG9naWMgbG9naWMgYXJlIHRyaWdnZXJlZCB1cG9uIGJlbG93IGlucHV0IHBhdHRlcm5zXG4gICAgICAgIGluZGVudE9uSW5wdXQ6IC9eXFxzKihbXFx9XFxdXFwpXXxlbHNlOnxlbGlmIHxleGNlcHQgfGZpbmFsbHk6fGNhc2VcXHMrW146XSo6PykkLyxcbiAgICB9XG59KTtcbi8qKlxuUHl0aG9uIGxhbmd1YWdlIHN1cHBvcnQuXG4qL1xuZnVuY3Rpb24gcHl0aG9uKCkge1xuICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdXBwb3J0KHB5dGhvbkxhbmd1YWdlLCBbXG4gICAgICAgIHB5dGhvbkxhbmd1YWdlLmRhdGEub2YoeyBhdXRvY29tcGxldGU6IGxvY2FsQ29tcGxldGlvblNvdXJjZSB9KSxcbiAgICAgICAgcHl0aG9uTGFuZ3VhZ2UuZGF0YS5vZih7IGF1dG9jb21wbGV0ZTogZ2xvYmFsQ29tcGxldGlvbiB9KSxcbiAgICBdKTtcbn1cblxuZXhwb3J0IHsgZ2xvYmFsQ29tcGxldGlvbiwgbG9jYWxDb21wbGV0aW9uU291cmNlLCBweXRob24sIHB5dGhvbkxhbmd1YWdlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@codemirror+lang-python@6.2.1/node_modules/@codemirror/lang-python/dist/index.js\n");

/***/ })

};
;