"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+link@0.33.1";
exports.ids = ["vendor-chunks/@lexical+link@0.33.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@lexical+link@0.33.1/node_modules/@lexical/link/LexicalLink.dev.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+link@0.33.1/node_modules/@lexical/link/LexicalLink.dev.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createAutoLinkNode: () => (/* binding */ $createAutoLinkNode),\n/* harmony export */   $createLinkNode: () => (/* binding */ $createLinkNode),\n/* harmony export */   $isAutoLinkNode: () => (/* binding */ $isAutoLinkNode),\n/* harmony export */   $isLinkNode: () => (/* binding */ $isLinkNode),\n/* harmony export */   $toggleLink: () => (/* binding */ $toggleLink),\n/* harmony export */   AutoLinkNode: () => (/* binding */ AutoLinkNode),\n/* harmony export */   LinkNode: () => (/* binding */ LinkNode),\n/* harmony export */   TOGGLE_LINK_COMMAND: () => (/* binding */ TOGGLE_LINK_COMMAND),\n/* harmony export */   formatUrl: () => (/* binding */ formatUrl),\n/* harmony export */   toggleLink: () => (/* binding */ toggleLink)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/.pnpm/@lexical+utils@0.33.1/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/.pnpm/lexical@0.33.1/node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n\n/** @noInheritDoc */\nclass LinkNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  constructor(url = '', attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    this.updateLinkDOM(null, element, config);\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.link);\n    return element;\n  }\n  updateLinkDOM(prevNode, anchor, config) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement)(anchor)) {\n      if (!prevNode || prevNode.__url !== this.__url) {\n        anchor.href = this.sanitizeUrl(this.__url);\n      }\n      for (const attr of ['target', 'rel', 'title']) {\n        const key = `__${attr}`;\n        const value = this[key];\n        if (!prevNode || prevNode[key] !== value) {\n          if (value) {\n            anchor[attr] = value;\n          } else {\n            anchor.removeAttribute(attr);\n          }\n        }\n      }\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    this.updateLinkDOM(prevNode, anchor, config);\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: $convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setURL(serializedNode.url).setRel(serializedNode.rel || null).setTarget(serializedNode.target || null).setTitle(serializedNode.title || null);\n  }\n  sanitizeUrl(url) {\n    url = formatUrl(url);\n    try {\n      const parsedUrl = new URL(formatUrl(url));\n      // eslint-disable-next-line no-script-url\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch (_unused) {\n      return url;\n    }\n    return url;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      url: this.getURL()\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n    return writable;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n    return writable;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n    return writable;\n  }\n  getTitle() {\n    return this.getLatest().__title;\n  }\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n    return writable;\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const linkNode = $createLinkNode(this.__url, {\n      rel: this.__rel,\n      target: this.__target,\n      title: this.__title\n    });\n    this.insertAfter(linkNode, restoreSelection);\n    return linkNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n  isEmailURI() {\n    return this.__url.startsWith('mailto:');\n  }\n  isWebSiteURI() {\n    return this.__url.startsWith('https://') || this.__url.startsWith('http://');\n  }\n}\nfunction $convertAnchorElement(domNode) {\n  let node = null;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement)(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '' || domNode.children.length > 0) {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\n\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createLinkNode(url = '', attributes) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new LinkNode(url, attributes));\n}\n\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  /** @internal */\n  /** Indicates whether the autolink was ever unlinked. **/\n\n  constructor(url = '', attributes = {}, key) {\n    super(url, attributes, key);\n    this.__isUnlinked = attributes.isUnlinked !== undefined && attributes.isUnlinked !== null ? attributes.isUnlinked : false;\n  }\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      isUnlinked: node.__isUnlinked,\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  getIsUnlinked() {\n    return this.__isUnlinked;\n  }\n  setIsUnlinked(value) {\n    const self = this.getWritable();\n    self.__isUnlinked = value;\n    return self;\n  }\n  createDOM(config) {\n    if (this.__isUnlinked) {\n      return document.createElement('span');\n    } else {\n      return super.createDOM(config);\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;\n  }\n  static importJSON(serializedNode) {\n    return $createAutoLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setIsUnlinked(serializedNode.isUnlinked || false);\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      isUnlinked: this.__isUnlinked\n    };\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        isUnlinked: this.__isUnlinked,\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createAutoLinkNode(url = '', attributes) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new AutoLinkNode(url, attributes));\n}\n\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('TOGGLE_LINK_COMMAND');\nfunction $getPointNode(point, offset) {\n  if (point.type === 'element') {\n    const node = point.getNode();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      formatDevErrorMessage(`$getPointNode: element point is not an ElementNode`);\n    }\n    const childNode = node.getChildren()[point.offset + offset];\n    return childNode || null;\n  }\n  return null;\n}\n\n/**\n * Preserve the logical start/end of a RangeSelection in situations where\n * the point is an element that may be reparented in the callback.\n *\n * @param $fn The function to run\n * @returns The result of the callback\n */\nfunction $withSelectedNodes($fn) {\n  const initialSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(initialSelection)) {\n    return $fn();\n  }\n  const normalized = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(initialSelection);\n  const isBackwards = normalized.isBackward();\n  const anchorNode = $getPointNode(normalized.anchor, isBackwards ? -1 : 0);\n  const focusNode = $getPointNode(normalized.focus, isBackwards ? 0 : -1);\n  const rval = $fn();\n  if (anchorNode || focusNode) {\n    const updatedSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(updatedSelection)) {\n      const finalSelection = updatedSelection.clone();\n      if (anchorNode) {\n        const anchorParent = anchorNode.getParent();\n        if (anchorParent) {\n          finalSelection.anchor.set(anchorParent.getKey(), anchorNode.getIndexWithinParent() + (isBackwards ? 1 : 0), 'element');\n        }\n      }\n      if (focusNode) {\n        const focusParent = focusNode.getParent();\n        if (focusParent) {\n          finalSelection.focus.set(focusParent.getKey(), focusNode.getIndexWithinParent() + (isBackwards ? 0 : 1), 'element');\n        }\n      }\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(finalSelection));\n    }\n  }\n  return rval;\n}\n\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n */\nfunction $toggleLink(url, attributes = {}) {\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (selection === null || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n    return;\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n    const nodes = selection.getNodes();\n    if (nodes.length === 0) {\n      return;\n    }\n\n    // Handle all selected nodes\n    nodes.forEach(node => {\n      if (url === null) {\n        // Remove link\n        const linkParent = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (linkParent) {\n          linkParent.insertBefore(node);\n          if (linkParent.getChildren().length === 0) {\n            linkParent.remove();\n          }\n        }\n      } else {\n        // Add/Update link\n        const existingLink = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (existingLink) {\n          existingLink.setURL(url);\n          if (target !== undefined) {\n            existingLink.setTarget(target);\n          }\n          if (rel !== undefined) {\n            existingLink.setRel(rel);\n          }\n        } else {\n          const linkNode = $createLinkNode(url, {\n            rel,\n            target\n          });\n          node.insertBefore(linkNode);\n          linkNode.append(node);\n        }\n      }\n    });\n    return;\n  }\n\n  // Handle RangeSelection\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parentLink = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n      if (parentLink) {\n        const children = parentLink.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parentLink.insertBefore(children[i]);\n        }\n        parentLink.remove();\n      }\n    });\n    return;\n  }\n  const updatedNodes = new Set();\n  const updateLinkNode = linkNode => {\n    if (updatedNodes.has(linkNode.getKey())) {\n      return;\n    }\n    updatedNodes.add(linkNode.getKey());\n    linkNode.setURL(url);\n    if (target !== undefined) {\n      linkNode.setTarget(target);\n    }\n    if (rel !== undefined) {\n      linkNode.setRel(rel);\n    }\n    if (title !== undefined) {\n      linkNode.setTitle(title);\n    }\n  };\n  // Add or merge LinkNodes\n  if (nodes.length === 1) {\n    const firstNode = nodes[0];\n    // if the first node is a LinkNode or if its\n    // parent is a LinkNode, we update the URL, target and rel.\n    const linkNode = $getAncestor(firstNode, $isLinkNode);\n    if (linkNode !== null) {\n      return updateLinkNode(linkNode);\n    }\n  }\n  $withSelectedNodes(() => {\n    let linkNode = null;\n    for (const node of nodes) {\n      if (!node.isAttached()) {\n        continue;\n      }\n      const parentLinkNode = $getAncestor(node, $isLinkNode);\n      if (parentLinkNode) {\n        updateLinkNode(parentLinkNode);\n        continue;\n      }\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n        if (!node.isInline()) {\n          // Ignore block nodes, if there are any children we will see them\n          // later and wrap in a new LinkNode\n          continue;\n        }\n        if ($isLinkNode(node)) {\n          // If it's not an autolink node and we don't already have a LinkNode\n          // in this block then we can update it and re-use it\n          if (!$isAutoLinkNode(node) && (linkNode === null || !linkNode.getParentOrThrow().isParentOf(node))) {\n            updateLinkNode(node);\n            linkNode = node;\n            continue;\n          }\n          // Unwrap LinkNode, we already have one or it's an AutoLinkNode\n          for (const child of node.getChildren()) {\n            node.insertBefore(child);\n          }\n          node.remove();\n          continue;\n        }\n      }\n      const prevLinkNode = node.getPreviousSibling();\n      if ($isLinkNode(prevLinkNode) && prevLinkNode.is(linkNode)) {\n        prevLinkNode.append(node);\n        continue;\n      }\n      linkNode = $createLinkNode(url, {\n        rel,\n        target,\n        title\n      });\n      node.insertAfter(linkNode);\n      linkNode.append(node);\n    }\n  });\n}\n/** @deprecated renamed to {@link $toggleLink} by @lexical/eslint-plugin rules-of-lexical */\nconst toggleLink = $toggleLink;\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\nconst PHONE_NUMBER_REGEX = /^\\+?[0-9\\s()-]{5,}$/;\n\n/**\n * Formats a URL string by adding appropriate protocol if missing\n *\n * @param url - URL to format\n * @returns Formatted URL with appropriate protocol\n */\nfunction formatUrl(url) {\n  // Check if URL already has a protocol\n  if (url.match(/^[a-z][a-z0-9+.-]*:/i)) {\n    // URL already has a protocol, leave it as is\n    return url;\n  }\n  // Check if it's a relative path (starting with '/', '.', or '#')\n  else if (url.match(/^[/#.]/)) {\n    // Relative path, leave it as is\n    return url;\n  }\n\n  // Check for email address\n  else if (url.includes('@')) {\n    return `mailto:${url}`;\n  }\n\n  // Check for phone number\n  else if (PHONE_NUMBER_REGEX.test(url)) {\n    return `tel:${url}`;\n  }\n\n  // For everything else, return with https:// prefix\n  return `https://${url}`;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrbGlua0AwLjMzLjEvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2xpbmsvTGV4aWNhbExpbmsuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0c7QUFDZ0c7O0FBRWxNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVCQUF1QixnREFBVztBQUNsQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0VBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDREQUFtQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFxQjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOERBQXFCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1REFBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNEQUFhO0FBQ3hDLE9BQU8sMERBQWlCO0FBQ3hCO0FBQ0E7QUFDQSxxQkFBcUIsMEVBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQWE7QUFDMUMsUUFBUSwwREFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNEQUFhLENBQUMsMEVBQWlDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9CQUFvQixzREFBYTtBQUNqQyw2QkFBNkIsMERBQWlCLGdCQUFnQix5REFBZ0I7QUFDOUU7QUFDQTtBQUNBLE1BQU0seURBQWdCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1FQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSw2QkFBNkIsbUVBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtRUFBbUI7QUFDNUM7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVEQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsR0FBRzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLElBQUk7QUFDekI7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCOztBQUVBO0FBQ0Esb0JBQW9CLElBQUk7QUFDeEI7O0FBRStKIiwic291cmNlcyI6WyIvVXNlcnMvYW5raXRocmVkZHkvRGVza3RvcC9oYWNrYXRob25zL2thZ2dsZWdlbW1hL2xlcmVwYWlyYm90aW5mZXJlbmNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9AbGV4aWNhbCtsaW5rQDAuMzMuMS9ub2RlX21vZHVsZXMvQGxleGljYWwvbGluay9MZXhpY2FsTGluay5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCwgaXNIVE1MQW5jaG9yRWxlbWVudCwgJGZpbmRNYXRjaGluZ1BhcmVudCB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUNvbW1hbmQsIEVsZW1lbnROb2RlLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGFwcGx5Tm9kZVJlcGxhY2VtZW50LCAkaXNFbGVtZW50Tm9kZSwgJGdldFNlbGVjdGlvbiwgJGlzTm9kZVNlbGVjdGlvbiwgJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMLCAkc2V0U2VsZWN0aW9uIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLy8gRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgYGludmFyaWFudGAgY2FsbHMuXG5cbmZ1bmN0aW9uIGZvcm1hdERldkVycm9yTWVzc2FnZShtZXNzYWdlKSB7XG4gIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuY29uc3QgU1VQUE9SVEVEX1VSTF9QUk9UT0NPTFMgPSBuZXcgU2V0KFsnaHR0cDonLCAnaHR0cHM6JywgJ21haWx0bzonLCAnc21zOicsICd0ZWw6J10pO1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgTGlua05vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2xpbmsnO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5rTm9kZShub2RlLl9fdXJsLCB7XG4gICAgICByZWw6IG5vZGUuX19yZWwsXG4gICAgICB0YXJnZXQ6IG5vZGUuX190YXJnZXQsXG4gICAgICB0aXRsZTogbm9kZS5fX3RpdGxlXG4gICAgfSwgbm9kZS5fX2tleSk7XG4gIH1cbiAgY29uc3RydWN0b3IodXJsID0gJycsIGF0dHJpYnV0ZXMgPSB7fSwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXQgPSBudWxsLFxuICAgICAgcmVsID0gbnVsbCxcbiAgICAgIHRpdGxlID0gbnVsbFxuICAgIH0gPSBhdHRyaWJ1dGVzO1xuICAgIHRoaXMuX191cmwgPSB1cmw7XG4gICAgdGhpcy5fX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLl9fcmVsID0gcmVsO1xuICAgIHRoaXMuX190aXRsZSA9IHRpdGxlO1xuICB9XG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIHRoaXMudXBkYXRlTGlua0RPTShudWxsLCBlbGVtZW50LCBjb25maWcpO1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLmxpbmspO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHVwZGF0ZUxpbmtET00ocHJldk5vZGUsIGFuY2hvciwgY29uZmlnKSB7XG4gICAgaWYgKGlzSFRNTEFuY2hvckVsZW1lbnQoYW5jaG9yKSkge1xuICAgICAgaWYgKCFwcmV2Tm9kZSB8fCBwcmV2Tm9kZS5fX3VybCAhPT0gdGhpcy5fX3VybCkge1xuICAgICAgICBhbmNob3IuaHJlZiA9IHRoaXMuc2FuaXRpemVVcmwodGhpcy5fX3VybCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgWyd0YXJnZXQnLCAncmVsJywgJ3RpdGxlJ10pIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYF9fJHthdHRyfWA7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1trZXldO1xuICAgICAgICBpZiAoIXByZXZOb2RlIHx8IHByZXZOb2RlW2tleV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBhbmNob3JbYXR0cl0gPSB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBhbmNob3IsIGNvbmZpZykge1xuICAgIHRoaXMudXBkYXRlTGlua0RPTShwcmV2Tm9kZSwgYW5jaG9yLCBjb25maWcpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0QW5jaG9yRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDFcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiAkY3JlYXRlTGlua05vZGUoKS51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSk7XG4gIH1cbiAgdXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gc3VwZXIudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpLnNldFVSTChzZXJpYWxpemVkTm9kZS51cmwpLnNldFJlbChzZXJpYWxpemVkTm9kZS5yZWwgfHwgbnVsbCkuc2V0VGFyZ2V0KHNlcmlhbGl6ZWROb2RlLnRhcmdldCB8fCBudWxsKS5zZXRUaXRsZShzZXJpYWxpemVkTm9kZS50aXRsZSB8fCBudWxsKTtcbiAgfVxuICBzYW5pdGl6ZVVybCh1cmwpIHtcbiAgICB1cmwgPSBmb3JtYXRVcmwodXJsKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTChmb3JtYXRVcmwodXJsKSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2NyaXB0LXVybFxuICAgICAgaWYgKCFTVVBQT1JURURfVVJMX1BST1RPQ09MUy5oYXMocGFyc2VkVXJsLnByb3RvY29sKSkge1xuICAgICAgICByZXR1cm4gJ2Fib3V0OmJsYW5rJztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIHJlbDogdGhpcy5nZXRSZWwoKSxcbiAgICAgIHRhcmdldDogdGhpcy5nZXRUYXJnZXQoKSxcbiAgICAgIHRpdGxlOiB0aGlzLmdldFRpdGxlKCksXG4gICAgICB1cmw6IHRoaXMuZ2V0VVJMKClcbiAgICB9O1xuICB9XG4gIGdldFVSTCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX3VybDtcbiAgfVxuICBzZXRVUkwodXJsKSB7XG4gICAgY29uc3Qgd3JpdGFibGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgd3JpdGFibGUuX191cmwgPSB1cmw7XG4gICAgcmV0dXJuIHdyaXRhYmxlO1xuICB9XG4gIGdldFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX3RhcmdldDtcbiAgfVxuICBzZXRUYXJnZXQodGFyZ2V0KSB7XG4gICAgY29uc3Qgd3JpdGFibGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgd3JpdGFibGUuX190YXJnZXQgPSB0YXJnZXQ7XG4gICAgcmV0dXJuIHdyaXRhYmxlO1xuICB9XG4gIGdldFJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX3JlbDtcbiAgfVxuICBzZXRSZWwocmVsKSB7XG4gICAgY29uc3Qgd3JpdGFibGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgd3JpdGFibGUuX19yZWwgPSByZWw7XG4gICAgcmV0dXJuIHdyaXRhYmxlO1xuICB9XG4gIGdldFRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fdGl0bGU7XG4gIH1cbiAgc2V0VGl0bGUodGl0bGUpIHtcbiAgICBjb25zdCB3cml0YWJsZSA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICB3cml0YWJsZS5fX3RpdGxlID0gdGl0bGU7XG4gICAgcmV0dXJuIHdyaXRhYmxlO1xuICB9XG4gIGluc2VydE5ld0FmdGVyKF8sIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgbGlua05vZGUgPSAkY3JlYXRlTGlua05vZGUodGhpcy5fX3VybCwge1xuICAgICAgcmVsOiB0aGlzLl9fcmVsLFxuICAgICAgdGFyZ2V0OiB0aGlzLl9fdGFyZ2V0LFxuICAgICAgdGl0bGU6IHRoaXMuX190aXRsZVxuICAgIH0pO1xuICAgIHRoaXMuaW5zZXJ0QWZ0ZXIobGlua05vZGUsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIHJldHVybiBsaW5rTm9kZTtcbiAgfVxuICBjYW5JbnNlcnRUZXh0QmVmb3JlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5JbnNlcnRUZXh0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNhbkJlRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlzSW5saW5lKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQsIHNlbGVjdGlvbiwgZGVzdGluYXRpb24pIHtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMuaXNQYXJlbnRPZihhbmNob3JOb2RlKSAmJiB0aGlzLmlzUGFyZW50T2YoZm9jdXNOb2RlKSAmJiBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGggPiAwO1xuICB9XG4gIGlzRW1haWxVUkkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX191cmwuc3RhcnRzV2l0aCgnbWFpbHRvOicpO1xuICB9XG4gIGlzV2ViU2l0ZVVSSSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3VybC5zdGFydHNXaXRoKCdodHRwczovLycpIHx8IHRoaXMuX191cmwuc3RhcnRzV2l0aCgnaHR0cDovLycpO1xuICB9XG59XG5mdW5jdGlvbiAkY29udmVydEFuY2hvckVsZW1lbnQoZG9tTm9kZSkge1xuICBsZXQgbm9kZSA9IG51bGw7XG4gIGlmIChpc0hUTUxBbmNob3JFbGVtZW50KGRvbU5vZGUpKSB7XG4gICAgY29uc3QgY29udGVudCA9IGRvbU5vZGUudGV4dENvbnRlbnQ7XG4gICAgaWYgKGNvbnRlbnQgIT09IG51bGwgJiYgY29udGVudCAhPT0gJycgfHwgZG9tTm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBub2RlID0gJGNyZWF0ZUxpbmtOb2RlKGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgJycsIHtcbiAgICAgICAgcmVsOiBkb21Ob2RlLmdldEF0dHJpYnV0ZSgncmVsJyksXG4gICAgICAgIHRhcmdldDogZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpLFxuICAgICAgICB0aXRsZTogZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3RpdGxlJylcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG5vZGVcbiAgfTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIFVSTCBhbmQgY3JlYXRlcyBhIExpbmtOb2RlLlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdGhlIExpbmtOb2RlIHNob3VsZCBkaXJlY3QgdG8uXG4gKiBAcGFyYW0gYXR0cmlidXRlcyAtIE9wdGlvbmFsIEhUTUwgYSB0YWcgYXR0cmlidXRlcyBcXFxceyB0YXJnZXQsIHJlbCwgdGl0bGUgXFxcXH1cbiAqIEByZXR1cm5zIFRoZSBMaW5rTm9kZS5cbiAqL1xuZnVuY3Rpb24gJGNyZWF0ZUxpbmtOb2RlKHVybCA9ICcnLCBhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IExpbmtOb2RlKHVybCwgYXR0cmlidXRlcykpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgbm9kZSBpcyBhIExpbmtOb2RlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgdHJ1ZSBpZiBub2RlIGlzIGEgTGlua05vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gJGlzTGlua05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIExpbmtOb2RlO1xufVxuLy8gQ3VzdG9tIG5vZGUgdHlwZSB0byBvdmVycmlkZSBgY2FuSW5zZXJ0VGV4dEFmdGVyYCB0aGF0IHdpbGxcbi8vIGFsbG93IHR5cGluZyB3aXRoaW4gdGhlIGxpbmtcbmNsYXNzIEF1dG9MaW5rTm9kZSBleHRlbmRzIExpbmtOb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICAvKiogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGF1dG9saW5rIHdhcyBldmVyIHVubGlua2VkLiAqKi9cblxuICBjb25zdHJ1Y3Rvcih1cmwgPSAnJywgYXR0cmlidXRlcyA9IHt9LCBrZXkpIHtcbiAgICBzdXBlcih1cmwsIGF0dHJpYnV0ZXMsIGtleSk7XG4gICAgdGhpcy5fX2lzVW5saW5rZWQgPSBhdHRyaWJ1dGVzLmlzVW5saW5rZWQgIT09IHVuZGVmaW5lZCAmJiBhdHRyaWJ1dGVzLmlzVW5saW5rZWQgIT09IG51bGwgPyBhdHRyaWJ1dGVzLmlzVW5saW5rZWQgOiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2F1dG9saW5rJztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgQXV0b0xpbmtOb2RlKG5vZGUuX191cmwsIHtcbiAgICAgIGlzVW5saW5rZWQ6IG5vZGUuX19pc1VubGlua2VkLFxuICAgICAgcmVsOiBub2RlLl9fcmVsLFxuICAgICAgdGFyZ2V0OiBub2RlLl9fdGFyZ2V0LFxuICAgICAgdGl0bGU6IG5vZGUuX190aXRsZVxuICAgIH0sIG5vZGUuX19rZXkpO1xuICB9XG4gIGdldElzVW5saW5rZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pc1VubGlua2VkO1xuICB9XG4gIHNldElzVW5saW5rZWQodmFsdWUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19pc1VubGlua2VkID0gdmFsdWU7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGlmICh0aGlzLl9faXNVbmxpbmtlZCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZURPTShjb25maWcpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGFuY2hvciwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZURPTShwcmV2Tm9kZSwgYW5jaG9yLCBjb25maWcpIHx8IHByZXZOb2RlLl9faXNVbmxpbmtlZCAhPT0gdGhpcy5fX2lzVW5saW5rZWQ7XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUF1dG9MaW5rTm9kZSgpLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKTtcbiAgfVxuICB1cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiBzdXBlci51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSkuc2V0SXNVbmxpbmtlZChzZXJpYWxpemVkTm9kZS5pc1VubGlua2VkIHx8IGZhbHNlKTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIC8vIFRPRE86IFNob3VsZCBsaW5rIG5vZGUgc2hvdWxkIGhhbmRsZSB0aGUgaW1wb3J0IG92ZXIgYXV0b2xpbms/XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgaXNVbmxpbmtlZDogdGhpcy5fX2lzVW5saW5rZWRcbiAgICB9O1xuICB9XG4gIGluc2VydE5ld0FmdGVyKHNlbGVjdGlvbiwgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCkuaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoZWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IGxpbmtOb2RlID0gJGNyZWF0ZUF1dG9MaW5rTm9kZSh0aGlzLl9fdXJsLCB7XG4gICAgICAgIGlzVW5saW5rZWQ6IHRoaXMuX19pc1VubGlua2VkLFxuICAgICAgICByZWw6IHRoaXMuX19yZWwsXG4gICAgICAgIHRhcmdldDogdGhpcy5fX3RhcmdldCxcbiAgICAgICAgdGl0bGU6IHRoaXMuX190aXRsZVxuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmFwcGVuZChsaW5rTm9kZSk7XG4gICAgICByZXR1cm4gbGlua05vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogVGFrZXMgYSBVUkwgYW5kIGNyZWF0ZXMgYW4gQXV0b0xpbmtOb2RlLiBBdXRvTGlua05vZGVzIGFyZSBnZW5lcmFsbHkgYXV0b21hdGljYWxseSBnZW5lcmF0ZWRcbiAqIGR1cmluZyB0eXBpbmcsIHdoaWNoIGlzIGVzcGVjaWFsbHkgdXNlZnVsIHdoZW4gYSBidXR0b24gdG8gZ2VuZXJhdGUgYSBMaW5rTm9kZSBpcyBub3QgcHJhY3RpY2FsLlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdGhlIExpbmtOb2RlIHNob3VsZCBkaXJlY3QgdG8uXG4gKiBAcGFyYW0gYXR0cmlidXRlcyAtIE9wdGlvbmFsIEhUTUwgYSB0YWcgYXR0cmlidXRlcy4gXFxcXHsgdGFyZ2V0LCByZWwsIHRpdGxlIFxcXFx9XG4gKiBAcmV0dXJucyBUaGUgTGlua05vZGUuXG4gKi9cbmZ1bmN0aW9uICRjcmVhdGVBdXRvTGlua05vZGUodXJsID0gJycsIGF0dHJpYnV0ZXMpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgQXV0b0xpbmtOb2RlKHVybCwgYXR0cmlidXRlcykpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgbm9kZSBpcyBhbiBBdXRvTGlua05vZGUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIG5vZGUgaXMgYW4gQXV0b0xpbmtOb2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uICRpc0F1dG9MaW5rTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgQXV0b0xpbmtOb2RlO1xufVxuY29uc3QgVE9HR0xFX0xJTktfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1RPR0dMRV9MSU5LX0NPTU1BTkQnKTtcbmZ1bmN0aW9uICRnZXRQb2ludE5vZGUocG9pbnQsIG9mZnNldCkge1xuICBpZiAocG9pbnQudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgY29uc3Qgbm9kZSA9IHBvaW50LmdldE5vZGUoKTtcbiAgICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRnZXRQb2ludE5vZGU6IGVsZW1lbnQgcG9pbnQgaXMgbm90IGFuIEVsZW1lbnROb2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkTm9kZSA9IG5vZGUuZ2V0Q2hpbGRyZW4oKVtwb2ludC5vZmZzZXQgKyBvZmZzZXRdO1xuICAgIHJldHVybiBjaGlsZE5vZGUgfHwgbnVsbDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBQcmVzZXJ2ZSB0aGUgbG9naWNhbCBzdGFydC9lbmQgb2YgYSBSYW5nZVNlbGVjdGlvbiBpbiBzaXR1YXRpb25zIHdoZXJlXG4gKiB0aGUgcG9pbnQgaXMgYW4gZWxlbWVudCB0aGF0IG1heSBiZSByZXBhcmVudGVkIGluIHRoZSBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0gJGZuIFRoZSBmdW5jdGlvbiB0byBydW5cbiAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uICR3aXRoU2VsZWN0ZWROb2RlcygkZm4pIHtcbiAgY29uc3QgaW5pdGlhbFNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihpbml0aWFsU2VsZWN0aW9uKSkge1xuICAgIHJldHVybiAkZm4oKTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkID0gJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMKGluaXRpYWxTZWxlY3Rpb24pO1xuICBjb25zdCBpc0JhY2t3YXJkcyA9IG5vcm1hbGl6ZWQuaXNCYWNrd2FyZCgpO1xuICBjb25zdCBhbmNob3JOb2RlID0gJGdldFBvaW50Tm9kZShub3JtYWxpemVkLmFuY2hvciwgaXNCYWNrd2FyZHMgPyAtMSA6IDApO1xuICBjb25zdCBmb2N1c05vZGUgPSAkZ2V0UG9pbnROb2RlKG5vcm1hbGl6ZWQuZm9jdXMsIGlzQmFja3dhcmRzID8gMCA6IC0xKTtcbiAgY29uc3QgcnZhbCA9ICRmbigpO1xuICBpZiAoYW5jaG9yTm9kZSB8fCBmb2N1c05vZGUpIHtcbiAgICBjb25zdCB1cGRhdGVkU2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbih1cGRhdGVkU2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgZmluYWxTZWxlY3Rpb24gPSB1cGRhdGVkU2VsZWN0aW9uLmNsb25lKCk7XG4gICAgICBpZiAoYW5jaG9yTm9kZSkge1xuICAgICAgICBjb25zdCBhbmNob3JQYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAoYW5jaG9yUGFyZW50KSB7XG4gICAgICAgICAgZmluYWxTZWxlY3Rpb24uYW5jaG9yLnNldChhbmNob3JQYXJlbnQuZ2V0S2V5KCksIGFuY2hvck5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIChpc0JhY2t3YXJkcyA/IDEgOiAwKSwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvY3VzTm9kZSkge1xuICAgICAgICBjb25zdCBmb2N1c1BhcmVudCA9IGZvY3VzTm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKGZvY3VzUGFyZW50KSB7XG4gICAgICAgICAgZmluYWxTZWxlY3Rpb24uZm9jdXMuc2V0KGZvY3VzUGFyZW50LmdldEtleSgpLCBmb2N1c05vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIChpc0JhY2t3YXJkcyA/IDAgOiAxKSwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgJHNldFNlbGVjdGlvbigkbm9ybWFsaXplU2VsZWN0aW9uX19FWFBFUklNRU5UQUwoZmluYWxTZWxlY3Rpb24pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIG9yIHVwZGF0ZXMgYSBMaW5rTm9kZS4gSXQgY2FuIGFsc28gZGVsZXRlIGEgTGlua05vZGUgaWYgdGhlIFVSTCBpcyBudWxsLFxuICogYnV0IHNhdmVzIGFueSBjaGlsZHJlbiBhbmQgYnJpbmdzIHRoZW0gdXAgdG8gdGhlIHBhcmVudCBub2RlLlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdGhlIGxpbmsgZGlyZWN0cyB0by5cbiAqIEBwYXJhbSBhdHRyaWJ1dGVzIC0gT3B0aW9uYWwgSFRNTCBhIHRhZyBhdHRyaWJ1dGVzLiBcXFxceyB0YXJnZXQsIHJlbCwgdGl0bGUgXFxcXH1cbiAqL1xuZnVuY3Rpb24gJHRvZ2dsZUxpbmsodXJsLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHRhcmdldCxcbiAgICB0aXRsZVxuICB9ID0gYXR0cmlidXRlcztcbiAgY29uc3QgcmVsID0gYXR0cmlidXRlcy5yZWwgPT09IHVuZGVmaW5lZCA/ICdub3JlZmVycmVyJyA6IGF0dHJpYnV0ZXMucmVsO1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmIChzZWxlY3Rpb24gPT09IG51bGwgfHwgISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgISRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGFsbCBzZWxlY3RlZCBub2Rlc1xuICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBpZiAodXJsID09PSBudWxsKSB7XG4gICAgICAgIC8vIFJlbW92ZSBsaW5rXG4gICAgICAgIGNvbnN0IGxpbmtQYXJlbnQgPSAkZmluZE1hdGNoaW5nUGFyZW50KG5vZGUsIHBhcmVudCA9PiAhJGlzQXV0b0xpbmtOb2RlKHBhcmVudCkgJiYgJGlzTGlua05vZGUocGFyZW50KSk7XG4gICAgICAgIGlmIChsaW5rUGFyZW50KSB7XG4gICAgICAgICAgbGlua1BhcmVudC5pbnNlcnRCZWZvcmUobm9kZSk7XG4gICAgICAgICAgaWYgKGxpbmtQYXJlbnQuZ2V0Q2hpbGRyZW4oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxpbmtQYXJlbnQucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGQvVXBkYXRlIGxpbmtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdMaW5rID0gJGZpbmRNYXRjaGluZ1BhcmVudChub2RlLCBwYXJlbnQgPT4gISRpc0F1dG9MaW5rTm9kZShwYXJlbnQpICYmICRpc0xpbmtOb2RlKHBhcmVudCkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdMaW5rKSB7XG4gICAgICAgICAgZXhpc3RpbmdMaW5rLnNldFVSTCh1cmwpO1xuICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhpc3RpbmdMaW5rLnNldFRhcmdldCh0YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4aXN0aW5nTGluay5zZXRSZWwocmVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbGlua05vZGUgPSAkY3JlYXRlTGlua05vZGUodXJsLCB7XG4gICAgICAgICAgICByZWwsXG4gICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBub2RlLmluc2VydEJlZm9yZShsaW5rTm9kZSk7XG4gICAgICAgICAgbGlua05vZGUuYXBwZW5kKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSGFuZGxlIFJhbmdlU2VsZWN0aW9uXG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmV4dHJhY3QoKTtcbiAgaWYgKHVybCA9PT0gbnVsbCkge1xuICAgIC8vIFJlbW92ZSBMaW5rTm9kZXNcbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgY29uc3QgcGFyZW50TGluayA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgcGFyZW50ID0+ICEkaXNBdXRvTGlua05vZGUocGFyZW50KSAmJiAkaXNMaW5rTm9kZShwYXJlbnQpKTtcbiAgICAgIGlmIChwYXJlbnRMaW5rKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50TGluay5nZXRDaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcGFyZW50TGluay5pbnNlcnRCZWZvcmUoY2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudExpbmsucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgdXBkYXRlTGlua05vZGUgPSBsaW5rTm9kZSA9PiB7XG4gICAgaWYgKHVwZGF0ZWROb2Rlcy5oYXMobGlua05vZGUuZ2V0S2V5KCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHVwZGF0ZWROb2Rlcy5hZGQobGlua05vZGUuZ2V0S2V5KCkpO1xuICAgIGxpbmtOb2RlLnNldFVSTCh1cmwpO1xuICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGlua05vZGUuc2V0VGFyZ2V0KHRhcmdldCk7XG4gICAgfVxuICAgIGlmIChyZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGlua05vZGUuc2V0UmVsKHJlbCk7XG4gICAgfVxuICAgIGlmICh0aXRsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsaW5rTm9kZS5zZXRUaXRsZSh0aXRsZSk7XG4gICAgfVxuICB9O1xuICAvLyBBZGQgb3IgbWVyZ2UgTGlua05vZGVzXG4gIGlmIChub2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBmaXJzdE5vZGUgPSBub2Rlc1swXTtcbiAgICAvLyBpZiB0aGUgZmlyc3Qgbm9kZSBpcyBhIExpbmtOb2RlIG9yIGlmIGl0c1xuICAgIC8vIHBhcmVudCBpcyBhIExpbmtOb2RlLCB3ZSB1cGRhdGUgdGhlIFVSTCwgdGFyZ2V0IGFuZCByZWwuXG4gICAgY29uc3QgbGlua05vZGUgPSAkZ2V0QW5jZXN0b3IoZmlyc3ROb2RlLCAkaXNMaW5rTm9kZSk7XG4gICAgaWYgKGxpbmtOb2RlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdXBkYXRlTGlua05vZGUobGlua05vZGUpO1xuICAgIH1cbiAgfVxuICAkd2l0aFNlbGVjdGVkTm9kZXMoKCkgPT4ge1xuICAgIGxldCBsaW5rTm9kZSA9IG51bGw7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICBpZiAoIW5vZGUuaXNBdHRhY2hlZCgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50TGlua05vZGUgPSAkZ2V0QW5jZXN0b3Iobm9kZSwgJGlzTGlua05vZGUpO1xuICAgICAgaWYgKHBhcmVudExpbmtOb2RlKSB7XG4gICAgICAgIHVwZGF0ZUxpbmtOb2RlKHBhcmVudExpbmtOb2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgICAgaWYgKCFub2RlLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYmxvY2sgbm9kZXMsIGlmIHRoZXJlIGFyZSBhbnkgY2hpbGRyZW4gd2Ugd2lsbCBzZWUgdGhlbVxuICAgICAgICAgIC8vIGxhdGVyIGFuZCB3cmFwIGluIGEgbmV3IExpbmtOb2RlXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRpc0xpbmtOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgLy8gSWYgaXQncyBub3QgYW4gYXV0b2xpbmsgbm9kZSBhbmQgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGEgTGlua05vZGVcbiAgICAgICAgICAvLyBpbiB0aGlzIGJsb2NrIHRoZW4gd2UgY2FuIHVwZGF0ZSBpdCBhbmQgcmUtdXNlIGl0XG4gICAgICAgICAgaWYgKCEkaXNBdXRvTGlua05vZGUobm9kZSkgJiYgKGxpbmtOb2RlID09PSBudWxsIHx8ICFsaW5rTm9kZS5nZXRQYXJlbnRPclRocm93KCkuaXNQYXJlbnRPZihub2RlKSkpIHtcbiAgICAgICAgICAgIHVwZGF0ZUxpbmtOb2RlKG5vZGUpO1xuICAgICAgICAgICAgbGlua05vZGUgPSBub2RlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVud3JhcCBMaW5rTm9kZSwgd2UgYWxyZWFkeSBoYXZlIG9uZSBvciBpdCdzIGFuIEF1dG9MaW5rTm9kZVxuICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5nZXRDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICBub2RlLmluc2VydEJlZm9yZShjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZMaW5rTm9kZSA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBpZiAoJGlzTGlua05vZGUocHJldkxpbmtOb2RlKSAmJiBwcmV2TGlua05vZGUuaXMobGlua05vZGUpKSB7XG4gICAgICAgIHByZXZMaW5rTm9kZS5hcHBlbmQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGlua05vZGUgPSAkY3JlYXRlTGlua05vZGUodXJsLCB7XG4gICAgICAgIHJlbCxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0aXRsZVxuICAgICAgfSk7XG4gICAgICBub2RlLmluc2VydEFmdGVyKGxpbmtOb2RlKTtcbiAgICAgIGxpbmtOb2RlLmFwcGVuZChub2RlKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8ge0BsaW5rICR0b2dnbGVMaW5rfSBieSBAbGV4aWNhbC9lc2xpbnQtcGx1Z2luIHJ1bGVzLW9mLWxleGljYWwgKi9cbmNvbnN0IHRvZ2dsZUxpbmsgPSAkdG9nZ2xlTGluaztcbmZ1bmN0aW9uICRnZXRBbmNlc3Rvcihub2RlLCBwcmVkaWNhdGUpIHtcbiAgbGV0IHBhcmVudCA9IG5vZGU7XG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwgJiYgcGFyZW50LmdldFBhcmVudCgpICE9PSBudWxsICYmICFwcmVkaWNhdGUocGFyZW50KSkge1xuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnRPclRocm93KCk7XG4gIH1cbiAgcmV0dXJuIHByZWRpY2F0ZShwYXJlbnQpID8gcGFyZW50IDogbnVsbDtcbn1cbmNvbnN0IFBIT05FX05VTUJFUl9SRUdFWCA9IC9eXFwrP1swLTlcXHMoKS1dezUsfSQvO1xuXG4vKipcbiAqIEZvcm1hdHMgYSBVUkwgc3RyaW5nIGJ5IGFkZGluZyBhcHByb3ByaWF0ZSBwcm90b2NvbCBpZiBtaXNzaW5nXG4gKlxuICogQHBhcmFtIHVybCAtIFVSTCB0byBmb3JtYXRcbiAqIEByZXR1cm5zIEZvcm1hdHRlZCBVUkwgd2l0aCBhcHByb3ByaWF0ZSBwcm90b2NvbFxuICovXG5mdW5jdGlvbiBmb3JtYXRVcmwodXJsKSB7XG4gIC8vIENoZWNrIGlmIFVSTCBhbHJlYWR5IGhhcyBhIHByb3RvY29sXG4gIGlmICh1cmwubWF0Y2goL15bYS16XVthLXowLTkrLi1dKjovaSkpIHtcbiAgICAvLyBVUkwgYWxyZWFkeSBoYXMgYSBwcm90b2NvbCwgbGVhdmUgaXQgYXMgaXNcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIC8vIENoZWNrIGlmIGl0J3MgYSByZWxhdGl2ZSBwYXRoIChzdGFydGluZyB3aXRoICcvJywgJy4nLCBvciAnIycpXG4gIGVsc2UgaWYgKHVybC5tYXRjaCgvXlsvIy5dLykpIHtcbiAgICAvLyBSZWxhdGl2ZSBwYXRoLCBsZWF2ZSBpdCBhcyBpc1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgZW1haWwgYWRkcmVzc1xuICBlbHNlIGlmICh1cmwuaW5jbHVkZXMoJ0AnKSkge1xuICAgIHJldHVybiBgbWFpbHRvOiR7dXJsfWA7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgcGhvbmUgbnVtYmVyXG4gIGVsc2UgaWYgKFBIT05FX05VTUJFUl9SRUdFWC50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gYHRlbDoke3VybH1gO1xuICB9XG5cbiAgLy8gRm9yIGV2ZXJ5dGhpbmcgZWxzZSwgcmV0dXJuIHdpdGggaHR0cHM6Ly8gcHJlZml4XG4gIHJldHVybiBgaHR0cHM6Ly8ke3VybH1gO1xufVxuXG5leHBvcnQgeyAkY3JlYXRlQXV0b0xpbmtOb2RlLCAkY3JlYXRlTGlua05vZGUsICRpc0F1dG9MaW5rTm9kZSwgJGlzTGlua05vZGUsICR0b2dnbGVMaW5rLCBBdXRvTGlua05vZGUsIExpbmtOb2RlLCBUT0dHTEVfTElOS19DT01NQU5ELCBmb3JtYXRVcmwsIHRvZ2dsZUxpbmsgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lexical+link@0.33.1/node_modules/@lexical/link/LexicalLink.dev.mjs\n");

/***/ })

};
;